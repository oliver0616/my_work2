
W. Bruce Croft
Donald Metzler
Trevor Strohman

Search Engines

Information Retrieval in Practice

©W.B. Croft, D. Metzler, T. Strohman, 2015
This book was previously published by: Pearson Education, Inc.





Preface

This book provides an overview of the important issues in information retrieval,
and how those issues affect the design and implementation of search engines. Not
every topic is covered at the same level of detail. We focus instead on what we
consider to be the most important alternatives to implementing search engine
components and the information retrieval models underlying them. Web search
engines are obviously a major topic, and we base our coverage primarily on the
technology we all use on theWeb,1 but search engines are also used inmany other
applications. That is the reason for the strong emphasis on the information re-
trieval theories and concepts that underlie all search engines.

The target audience for the book is primarily undergraduates in computer sci-
ence or computer engineering, but graduate students should also find this useful.
We also consider the book to be suitable for most students in information sci-
ence programs. Finally, practicing search engineers should benefit from the book,
whatever their background. There is mathematics in the book, but nothing too
esoteric. There are also code and programming exercises in the book, but nothing
beyond the capabilities of someone who has taken some basic computer science
and programming classes.

The exercises at the end of each chapter make extensive use of a Java™-based
open source search engine called Galago. Galago was designed both for this book
and to incorporate lessons learned from experience with the Lemur and Indri
projects. In other words, this is a fully functional search engine that can be used
to support real applications. Many of the programming exercises require the use,
modification, and extension of Galago components.

1 In keeping with common usage, most uses of the word “web” in this book are not cap-
italized, except when we refer to the World Wide Web as a separate entity.



VI Preface

Contents

In the first chapter, we provide a high-level review of the field of information re-
trieval and its relationship to search engines. In the second chapter, we describe
the architecture of a search engine. This is done to introduce the entire range of
search engine components without getting stuck in the details of any particular
aspect. InChapter 3, we focus on crawling, document feeds, and other techniques
for acquiring the information that will be searched. Chapter 4 describes the sta-
tistical nature of text and the techniques that are used to process it, recognize im-
portant features, and prepare it for indexing. Chapter 5 describes how to create
indexes for efficient search and how those indexes are used to process queries. In
Chapter 6, we describe the techniques that are used to process queries and trans-
form them into better representations of the user’s information need.

Ranking algorithms and the retrieval models they are based on are covered
in Chapter 7. This chapter also includes an overview of machine learning tech-
niques and how they relate to information retrieval and search engines. Chapter
8 describes the evaluation and performance metrics that are used to compare and
tune search engines. Chapter 9 covers the important classes of techniques used for
classification, filtering, clustering, and dealing with spam. Social search is a term
used to describe search applications that involve communities of people in tag-
ging content or answering questions. Search techniques for these applications and
peer-to-peer search are described inChapter 10. Finally, inChapter 11, we give an
overview of advanced techniques that capture more of the content of documents
than simple word-based approaches. This includes techniques that use linguistic
features, the document structure, and the content of nontextual media, such as
images or music.

Information retrieval theory and the design, implementation, evaluation, and
use of search engines cover too many topics to describe them all in depth in one
book. We have tried to focus on the most important topics while giving some
coverage to all aspects of this challenging and rewarding subject.

Supplements

A range of supplementary material is provided for the book. This material is de-
signed both for those taking a course based on the book and for those giving the
course. Specifically, this includes:

• Extensive lecture slides (in PDF and PPT format)



Preface VII

• Solutions to selected end–of–chapter problems (instructors only)
• Test collections for exercises
• Galago search engine

The supplements are available at www.search-engines-book.com.

Acknowledgments

First and foremost, this book would not have happened without the tremen-
dous support and encouragement from our wives, Pam Aselton, Anne-Marie
Strohman, and ShelleyWang.TheUniversity ofMassachusettsAmherst provided
material support for the preparation of the book and awarded aConti Faculty Fel-
lowship toCroft, which sped up our progress significantly.The staff at the Center
for Intelligent Information Retrieval ( Jean Joyce, Kate Moruzzi, Glenn Stowell,
and Andre Gauthier) made our lives easier in many ways, and our colleagues and
students in the Center provided the stimulating environment that makes work-
ing in this area so rewarding. A number of people reviewed parts of the book and
we appreciated their comments. Finally, we have to mention our children, Doug,
Eric, Evan, and Natalie, or they would never forgive us.

B???? C????
D?? M??????

T????? S???????

2015 Update

This version of the book is being made available for free download. It has been
edited to correct the minor errors noted in the 5 years since the book’s publica-
tion. The authors, meanwhile, are working on a second edition.





Contents

1 Search Engines and Information Retrieval . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 What Is Information Retrieval? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 The Big Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3 Search Engines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.4 Search Engineers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2 Architecture of a Search Engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.1 What Is an Architecture? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.2 Basic Building Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3 Breaking It Down . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

2.3.1 Text Acquisition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.2 Text Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.3.3 Index Creation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.3.4 User Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.3.5 Ranking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.6 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

2.4 How Does It ReallyWork? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

3 Crawls and Feeds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.1 Deciding What to Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2 Crawling the Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

3.2.1 Retrieving Web Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.2.2 The Web Crawler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.2.3 Freshness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.2.4 Focused Crawling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
3.2.5 Deep Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41



X Contents

3.2.6 Sitemaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.2.7 Distributed Crawling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

3.3 Crawling Documents and Email . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.4 Document Feeds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.5 The Conversion Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

3.5.1 Character Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3.6 Storing the Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

3.6.1 Using a Database System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.6.2 Random Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.6.3 Compression and Large Files . . . . . . . . . . . . . . . . . . . . . . . . . . 54
3.6.4 Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
3.6.5 BigTable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

3.7 Detecting Duplicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
3.8 Removing Noise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

4 Processing Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.1 From Words to Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.2 Text Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

4.2.1 Vocabulary Growth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.2.2 Estimating Collection and Result Set Sizes . . . . . . . . . . . . . . 83

4.3 Document Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
4.3.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
4.3.2 Tokenizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.3.3 Stopping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.3.4 Stemming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.3.5 Phrases and N-grams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

4.4 Document Structure and Markup . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.5 Link Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

4.5.1 Anchor Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
4.5.2 PageRank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
4.5.3 Link Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

4.6 Information Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
4.6.1 Hidden Markov Models for Extraction . . . . . . . . . . . . . . . . . 115

4.7 Internationalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118



Contents XI

5 Ranking with Indexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
5.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
5.2 Abstract Model of Ranking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
5.3 Inverted Indexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129

5.3.1 Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.3.2 Counts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.3.3 Positions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.3.4 Fields and Extents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
5.3.5 Scores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
5.3.6 Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

5.4 Compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
5.4.1 Entropy and Ambiguity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
5.4.2 Delta Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
5.4.3 Bit-Aligned Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
5.4.4 Byte-Aligned Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
5.4.5 Compression in Practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
5.4.6 Looking Ahead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
5.4.7 Skipping and Skip Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

5.5 Auxiliary Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
5.6 Index Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

5.6.1 Simple Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
5.6.2 Merging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
5.6.3 Parallelism and Distribution . . . . . . . . . . . . . . . . . . . . . . . . . . 158
5.6.4 Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164

5.7 Query Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
5.7.1 Document-at-a-time Evaluation . . . . . . . . . . . . . . . . . . . . . . . 166
5.7.2 Term-at-a-time Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.7.3 Optimization Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
5.7.4 Structured Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
5.7.5 Distributed Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
5.7.6 Caching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181

6 Queries and Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
6.1 Information Needs and Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
6.2 Query Transformation and Refinement . . . . . . . . . . . . . . . . . . . . . . . 190

6.2.1 Stopping and Stemming Revisited . . . . . . . . . . . . . . . . . . . . . 190
6.2.2 Spell Checking and Suggestions . . . . . . . . . . . . . . . . . . . . . . . 193



XII Contents

6.2.3 Query Expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
6.2.4 Relevance Feedback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
6.2.5 Context and Personalization . . . . . . . . . . . . . . . . . . . . . . . . . . 211

6.3 Showing the Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
6.3.1 Result Pages and Snippets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
6.3.2 Advertising and Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
6.3.3 Clustering the Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221

6.4 Cross-Language Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226

7 Retrieval Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
7.1 Overview of Retrieval Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233

7.1.1 Boolean Retrieval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
7.1.2 The Vector Space Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237

7.2 Probabilistic Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
7.2.1 Information Retrieval as Classification . . . . . . . . . . . . . . . . . 244
7.2.2 The BM25 Ranking Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 250

7.3 Ranking Based on Language Models . . . . . . . . . . . . . . . . . . . . . . . . . 252
7.3.1 Query Likelihood Ranking . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
7.3.2 Relevance Models and Pseudo-Relevance Feedback . . . . . . 261

7.4 Complex Queries and Combining Evidence . . . . . . . . . . . . . . . . . . . 267
7.4.1 The Inference Network Model . . . . . . . . . . . . . . . . . . . . . . . . 268
7.4.2 The Galago Query Language . . . . . . . . . . . . . . . . . . . . . . . . . . 273

7.5 Web Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
7.6 Machine Learning and Information Retrieval . . . . . . . . . . . . . . . . . . 283

7.6.1 Learning to Rank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
7.6.2 Topic Models and Vocabulary Mismatch . . . . . . . . . . . . . . . . 288

7.7 Application-Based Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291

8 Evaluating Search Engines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
8.1 Why Evaluate? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
8.2 The Evaluation Corpus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
8.3 Logging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
8.4 Effectiveness Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308

8.4.1 Recall and Precision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
8.4.2 Averaging and Interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . 313
8.4.3 Focusing on the Top Documents . . . . . . . . . . . . . . . . . . . . . . 318
8.4.4 Using Preferences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321



Contents XIII

8.5 Efficiency Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
8.6 Training, Testing, and Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325

8.6.1 Significance Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
8.6.2 Setting Parameter Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
8.6.3 Online Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332

8.7 The Bottom Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333

9 Classification and Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
9.1 Classification and Categorization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340

9.1.1 Naïve Bayes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
9.1.2 Support Vector Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
9.1.3 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
9.1.4 Classifier and Feature Selection . . . . . . . . . . . . . . . . . . . . . . . . 359
9.1.5 Spam, Sentiment, and Online Advertising . . . . . . . . . . . . . . 364

9.2 Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
9.2.1 Hierarchical andK-Means Clustering . . . . . . . . . . . . . . . . . . 375
9.2.2 K Nearest Neighbor Clustering . . . . . . . . . . . . . . . . . . . . . . . 384
9.2.3 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386
9.2.4 How to ChooseK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387
9.2.5 Clustering and Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389

10 Social Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
10.1 What Is Social Search? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
10.2 User Tags and Manual Indexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400

10.2.1 Searching Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
10.2.2 Inferring Missing Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
10.2.3 Browsing and Tag Clouds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406

10.3 Searching with Communities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
10.3.1 What Is a Community? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
10.3.2 Finding Communities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
10.3.3 Community-Based Question Answering . . . . . . . . . . . . . . . . 415
10.3.4 Collaborative Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420

10.4 Filtering and Recommending . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
10.4.1 Document Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
10.4.2 Collaborative Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 432

10.5 Peer-to-Peer and Metasearch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
10.5.1 Distributed Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438



XIV Contents

10.5.2 P2P Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442

11 Beyond Bag of Words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
11.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
11.2 Feature-Based Retrieval Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
11.3 Term Dependence Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
11.4 Structure Revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459

11.4.1 XML Retrieval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461
11.4.2 Entity Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464

11.5 Longer Questions, Better Answers . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
11.6 Words, Pictures, and Music . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470
11.7 One Search Fits All? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479

References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487

Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511



List of Figures

1.1 Search engine design and the core information retrieval issues . . . 9

2.1 The indexing process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2 The query process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.1 A uniform resource locator (URL), split into three parts . . . . . . . 33
3.2 Crawling the Web. The web crawler connects to web servers to

find pages. Pages may link to other pages on the same server or
on different servers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

3.3 An example robots.txt file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.4 A simple crawling thread implementation . . . . . . . . . . . . . . . . . . . . 37
3.5 An HTTP HEAD request and server response . . . . . . . . . . . . . . . 38
3.6 Age and freshness of a single page over time . . . . . . . . . . . . . . . . . . 39
3.7 Expected age of a page with mean change frequency ? = 1/7

(one week) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.8 An example sitemap file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.9 An example RSS 2.0 feed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.10 An example of text in the TREC Web compound document

format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3.11 An example link with anchor text . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
3.12 BigTable stores data in a single logical table, which is split into

many smaller tablets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3.13 A BigTable row . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.14 Example of fingerprinting process . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.15 Example of simhash fingerprinting process . . . . . . . . . . . . . . . . . . . 64
3.16 Main content block in a web page . . . . . . . . . . . . . . . . . . . . . . . . . . . 65



XVI List of Figures

3.17 Tag counts used to identify text blocks in a web page . . . . . . . . . . . 66
3.18 Part of the DOM structure for the example web page . . . . . . . . . . 67

4.1 Rank versus probability of occurrence for words assuming
Zipf ’s law (rank× probability = 0.1) . . . . . . . . . . . . . . . . . . . . . . . . 76

4.2 A log-log plot of Zipf ’s law compared to real data from AP89.
The predicted relationship between probability of occurrence
and rank breaks down badly at high ranks. . . . . . . . . . . . . . . . . . . . 79

4.3 Vocabulary growth for the TREC AP89 collection compared
to Heaps’ law . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

4.4 Vocabulary growth for the TREC GOV2 collection compared
to Heaps’ law . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

4.5 Result size estimate for web search . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.6 Comparison of stemmer output for a TREC query. Stopwords

have also been removed. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
4.7 Output of a POS tagger for a TREC query . . . . . . . . . . . . . . . . . . . 98
4.8 Part of a web page from Wikipedia . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.9 HTML source for example Wikipedia page . . . . . . . . . . . . . . . . . . 103
4.10 A sample “Internet” consisting of just three web pages. The

arrows denote links between the pages. . . . . . . . . . . . . . . . . . . . . . . 108
4.11 Pseudocode for the iterative PageRank algorithm . . . . . . . . . . . . . . 110
4.12 Trackback links in blog postings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
4.13 Text tagged by information extraction . . . . . . . . . . . . . . . . . . . . . . . 114
4.14 Sentence model for statistical entity extractor . . . . . . . . . . . . . . . . . 116
4.15 Chinese segmentation and bigrams . . . . . . . . . . . . . . . . . . . . . . . . . . 119

5.1 The components of the abstract model of ranking: documents,
features, queries, the retrieval function, and document scores . . . . 127

5.2 A more concrete model of ranking. Notice how both the query
and the document have feature functions in this model. . . . . . . . . 128

5.3 An inverted index for the documents (sentences) in Table 5.1 . . . 132
5.4 An inverted index, with word counts, for the documents in

Table 5.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.5 An inverted index, with word positions, for the documents in

Table 5.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
5.6 Aligning posting lists for “tropical” and “fish” to find the phrase

“tropical fish” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136



List of Figures XVII

5.7 Aligning posting lists for “fish” and title to find matches of the
word “fish” in the title field of a document. . . . . . . . . . . . . . . . . . . . 138

5.8 Pseudocode for a simple indexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
5.9 An example of index merging. The first and second indexes are

merged together to produce the combined index. . . . . . . . . . . . . . 158
5.10 MapReduce . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
5.11 Mapper for a credit card summing algorithm. . . . . . . . . . . . . . . . . . 162
5.12 Reducer for a credit card summing algorithm . . . . . . . . . . . . . . . . . 162
5.13 Mapper for documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
5.14 Reducer for word postings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
5.15 Document-at-a-time query evaluation. The numbers (x:y)

represent a document number (x) and a word count (y). . . . . . . . 166
5.16 A simple document-at-a-time retrieval algorithm . . . . . . . . . . . . . . 167
5.17 Term-at-a-time query evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.18 A simple term-at-a-time retrieval algorithm . . . . . . . . . . . . . . . . . . . 169
5.19 Skip pointers in an inverted list. The gray boxes show skip

pointers, which point into the white boxes, which are inverted
list postings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

5.20 A term-at-a-time retrieval algorithm with conjunctive processing 173
5.21 A document-at-a-time retrieval algorithm with conjunctive

processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
5.22 MaxScore retrieval with the query “eucalyptus tree”. The gray

boxes indicate postings that can be safely ignored during scoring. 176
5.23 Evaluation tree for the structured query #combine(#od:1(tropical

fish) #od:1(aquarium fish) fish) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179

6.1 Top ten results for the query “tropical fish” . . . . . . . . . . . . . . . . . . . 209
6.2 Geographic representation of Cape Cod using bounding

rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
6.3 Typical document summary for a web search . . . . . . . . . . . . . . . . . . 215
6.4 An example of a text span of words (w) bracketed by significant

words (s) using Luhn’s algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
6.5 Advertisements displayed by a search engine for the query “fish

tanks” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
6.6 Clusters formed by a search engine from top-ranked documents

for the query “tropical fish”. Numbers in brackets are the
number of documents in the cluster. . . . . . . . . . . . . . . . . . . . . . . . . . 222



XVIII List of Figures

6.7 Categories returned for the query “tropical fish” in a popular
online retailer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225

6.8 Subcategories and facets for the “Home & Garden” category . . . . 225
6.9 Cross-language search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
6.10 A French web page in the results list for the query “pecheur

france” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228

7.1 Term-document matrix for a collection of four documents . . . . . . 239
7.2 Vector representation of documents and queries . . . . . . . . . . . . . . . 240
7.3 Classifying a document as relevant or non-relevant . . . . . . . . . . . . 245
7.4 Example inference network model . . . . . . . . . . . . . . . . . . . . . . . . . . 269
7.5 Inference network with three nodes . . . . . . . . . . . . . . . . . . . . . . . . . 271
7.6 Galago query for the dependence model . . . . . . . . . . . . . . . . . . . . . 282
7.7 Galago query for web data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282

8.1 Example of a TREC topic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
8.2 Recall and precision values for two rankings of six relevant

documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
8.3 Recall and precision values for rankings from two different queries314
8.4 Recall-precision graphs for two queries . . . . . . . . . . . . . . . . . . . . . . . 315
8.5 Interpolated recall-precision graphs for two queries . . . . . . . . . . . . 316
8.6 Average recall-precision graph using standard recall levels . . . . . . . 317
8.7 Typical recall-precision graph for 50 queries from TREC . . . . . . . 318
8.8 Probability distribution for test statistic values assuming the

null hypothesis. The shaded area is the region of rejection for a
one-sided test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327

8.9 Example distribution of query effectiveness improvements . . . . . . 335

9.1 Illustration of how documents are represented in the multiple-
Bernoulli event space. In this example, there are 10 documents
(each with a unique id), two classes (spam and not spam), and a
vocabulary that consists of the terms “cheap”, “buy”, “banking”,
“dinner”, and “the”. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346

9.2 Illustration of how documents are represented in the
multinomial event space. In this example, there are 10
documents (each with a unique id), two classes (spam and not
spam), and a vocabulary that consists of the terms “cheap”,
“buy”, “banking”, “dinner”, and “the”. . . . . . . . . . . . . . . . . . . . . . . . . . 349



List of Figures XIX

9.3 Data set that consists of two classes (pluses and minuses). The
data set on the left is linearly separable, whereas the one on the
right is not. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352

9.4 Graphical illustration of Support Vector Machines for the
linearly separable case. Here, the hyperplane defined by w is
shown, as well as the margin, the decision regions, and the
support vectors, which are indicated by circles. . . . . . . . . . . . . . . . . 353

9.5 Generative process used by the Naïve Bayes model. First, a class
is chosen according to P (c), and then a document is chosen
according to P (d|c). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360

9.6 Example data set where non-parametric learning algorithms,
such as a nearest neighbor classifier, may outperform parametric
algorithms. The pluses and minuses indicate positive and
negative training examples, respectively. The solid gray line
shows the actual decision boundary, which is highly non-linear. . 361

9.7 Example output of SpamAssassin email spam filter . . . . . . . . . . . . 365
9.8 Example of web page spam, showing the main page and some

of the associated term and link spam . . . . . . . . . . . . . . . . . . . . . . . . . 367
9.9 Example product review incorporating sentiment . . . . . . . . . . . . . 370
9.10 Example semantic class match between a web page about

rainbow fish (a type of tropical fish) and an advertisement
for tropical fish food. The nodes “Aquariums”, “Fish”, and
“Supplies” are example nodes within a semantic hierarchy.
The web page is classified as “Aquariums - Fish” and the ad is
classified as “Supplies - Fish”. Here, “Aquariums” is the least
common ancestor. Although the web page and ad do not share
any terms in common, they can be matched because of their
semantic similarity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372

9.11 Example of divisive clustering with K = 4. The clustering
proceeds from left to right and top to bottom, resulting in four
clusters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376

9.12 Example of agglomerative clustering with K = 4. The
clustering proceeds from left to right and top to bottom,
resulting in four clusters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377

9.13 Dendrogram that illustrates the agglomerative clustering of the
points from Figure 9.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377



XX List of Figures

9.14 Examples of clusters in a graph formed by connecting nodes
representing instances. A link represents a distance between the
two instances that is less than some threshold value. . . . . . . . . . . . . 379

9.15 Illustration of how various clustering cost functions are computed 381
9.16 Example of overlapping clustering using nearest neighbor

clustering withK = 5. The overlapping clusters for the black
points (A, B, C, and D) are shown. The five nearest neighbors
for each black point are shaded gray and labeled accordingly. . . . . 385

9.17 Example of overlapping clustering using Parzen windows. The
clusters for the black points (A, B, C, and D) are shown. The
shaded circles indicate the windows used to determine cluster
membership. The neighbors for each black point are shaded
gray and labeled accordingly. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388

9.18 Cluster hypothesis tests on two TREC collections. The top
two compare the distributions of similarity values between
relevant-relevant and relevant-nonrelevant pairs (light gray) of
documents. The bottom two show the local precision of the
relevant documents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390

10.1 Search results used to enrich a tag representation. In this
example, the tag being expanded is “tropical fish”. The query
“tropical fish” is run against a search engine, and the snippets
returned are then used to generate a distribution over related
terms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403

10.2 Example of a tag cloud in the form of a weighted list. The
tags are in alphabetical order and weighted according to some
criteria, such as popularity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407

10.3 Illustration of the HITS algorithm. Each row corresponds to a
single iteration of the algorithm and each column corresponds
to a specific step of the algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . 412

10.4 Example of how nodes within a directed graph can be
represented as vectors. For a given node p, its vector
representation has component q set to 1 if p? q. . . . . . . . . . . . . . 413



List of Figures XXI

10.5 Overview of the two common collaborative search scenarios.
On the left is co-located collaborative search, which involves
multiple participants in the same location at the same time.
On the right is remote collaborative search, where participants
are in different locations and not necessarily all online and
searching at the same time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421

10.6 Example of a static filtering system. Documents arrive over time
and are compared against each profile. Arrows from documents
to profiles indicate the document matches the profile and is
retrieved. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425

10.7 Example of an adaptive filtering system. Documents arrive
over time and are compared against each profile. Arrows from
documents to profiles indicate the document matches the
profile and is retrieved. Unlike static filtering, where profiles are
static over time, profiles are updated dynamically (e.g., when a
new match occurs). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428

10.8 A set of users within a recommender system. Users and their
ratings for some item are given. Users with question marks
above their heads have not yet rated the item. It is the goal of
the recommender system to fill in these question marks. . . . . . . . . 434

10.9 Illustration of collaborative filtering using clustering. Groups
of similar users are outlined with dashed lines. Users and their
ratings for some item are given. In each group, there is a single
user who has not judged the item. For these users, the unjudged
item is assigned an automatic rating based on the ratings of
similar users. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435

10.10Metasearch engine architecture. The query is broadcast to
multiple web search engines and result lists are merged. . . . . . . . . 439

10.11Network architectures for distributed search: (a) central hub;
(b) pure P2P; and (c) hierarchical P2P. Dark circles are hub
or superpeer nodes, gray circles are provider nodes, and white
circles are consumer nodes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443

10.12Neighborhoods (Ni) of a hub node (H) in a hierarchical P2P
network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445



XXII List of Figures

11.1 Example Markov Random Field model assumptions, including
full independence (top left), sequential dependence (top
right), full dependence (bottom left), and general dependence
(bottom right) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455

11.2 Graphical model representations of the relevance model
technique (top) and latent concept expansion (bottom) used
for pseudo-relevance feedback with the query “hubble telescope
achievements” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459

11.3 Functions provided by a search engine interacting with a simple
database system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461

11.4 Example of an entity search for organizations using the TREC
Wall Street Journal 1987 Collection . . . . . . . . . . . . . . . . . . . . . . . . . 464

11.5 Question answering system architecture . . . . . . . . . . . . . . . . . . . . . . 467
11.6 Examples of OCR errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
11.7 Examples of speech recognizer errors . . . . . . . . . . . . . . . . . . . . . . . . 473
11.8 Two images (a fish and a flower bed) with color histograms.

The horizontal axis is hue value. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474
11.9 Three examples of content-based image retrieval. The collection

for the first two consists of 1,560 images of cars, faces, apes,
and other miscellaneous subjects. The last example is from a
collection of 2,048 trademark images. In each case, the leftmost
image is the query. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475

11.10Key frames extracted from a TREC video clip . . . . . . . . . . . . . . . . 476
11.11Examples of automatic text annotation of images . . . . . . . . . . . . . . 477
11.12Three representations of Bach’s “Fugue #10”: audio, MIDI, and

conventional music notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478



List of Tables

1.1 Some dimensions of information retrieval . . . . . . . . . . . . . . . . . . . . 4

3.1 UTF-8 encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

4.1 Statistics for the AP89 collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.2 Most frequent 50 words from AP89 . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.3 Low-frequency words from AP89 . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.4 Example word frequency ranking . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.5 Proportions of words occurring n times in 336,310 documents

from the TREC Volume 3 corpus. The total vocabulary size
(number of unique words) is 508,209. . . . . . . . . . . . . . . . . . . . . . . . 80

4.6 Document frequencies and estimated frequencies for word
combinations (assuming independence) in the GOV2 Web
collection. Collection size (N ) is 25,205,179. . . . . . . . . . . . . . . . . . 84

4.7 Examples of errors made by the original Porter stemmer. False
positives are pairs of words that have the same stem. False
negatives are pairs that have different stems. . . . . . . . . . . . . . . . . . . 93

4.8 Examples of words with the Arabic root ktb . . . . . . . . . . . . . . . . . . 96
4.9 High-frequency noun phrases from a TREC collection and

U.S. patents from 1996 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.10 Statistics for the Google n-gram sample . . . . . . . . . . . . . . . . . . . . . . 101

5.1 Four sentences from the Wikipedia entry for tropical fish . . . . . . . 132
5.2 Elias-? code examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
5.3 Elias-? code examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
5.4 Space requirements for numbers encoded in v-byte . . . . . . . . . . . . 149



XXIV List of Tables

5.5 Sample encodings for v-byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
5.6 Skip lengths (k) and expected processing steps . . . . . . . . . . . . . . . . 152

6.1 Partial entry for the Medical Subject (MeSH) Heading “Neck
Pain” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

6.2 Term association measures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
6.3 Most strongly associated words for “tropical” in a collection of

TREC news stories. Co-occurrence counts are measured at the
document level. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204

6.4 Most strongly associated words for “fish” in a collection of
TREC news stories. Co-occurrence counts are measured at the
document level. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205

6.5 Most strongly associated words for “fish” in a collection of
TREC news stories. Co-occurrence counts are measured in
windows of five words. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205

7.1 Contingency table of term occurrences for a particular query . . . 248
7.2 BM25 scores for an example document . . . . . . . . . . . . . . . . . . . . . . 252
7.3 Query likelihood scores for an example document . . . . . . . . . . . . . 260
7.4 Highest-probability terms from relevance model for four

example queries (estimated using top 10 documents) . . . . . . . . . . . 266
7.5 Highest-probability terms from relevance model for four

example queries (estimated using top 50 documents) . . . . . . . . . . . 267
7.6 Conditional probabilities for example network . . . . . . . . . . . . . . . 272
7.7 Highest-probability terms from four topics in LDA model . . . . . 290

8.1 Statistics for three example text collections.The average number
of words per document is calculated without stemming. . . . . . . . . 301

8.2 Statistics for queries from example text collections . . . . . . . . . . . . . 301
8.3 Sets of documents defined by a simple search with binary

relevance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
8.4 Precision values at standard recall levels calculated using

interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
8.5 Definitions of some important efficiency metrics . . . . . . . . . . . . . . 323
8.6 Artificial effectiveness data for two retrieval algorithms (A and

B) over 10 queries. The column B – A gives the difference in
effectiveness. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328



List of Tables XXV

9.1 A list of kernels that are typically used with SVMs. For each
kernel, the name, value, and implicit dimensionality are given. . . 357

10.1 Example questions submitted to Yahoo! Answers . . . . . . . . . . . . . . 416
10.2 Translations automatically learned from a set of question and

answer pairs. The 10 most likely translations for the terms
“everest”, “xp”, and “search” are given. . . . . . . . . . . . . . . . . . . . . . . . . . 419

10.3 Summary of static and adaptive filtering models. For each, the
profile representation and profile updating algorithm are given. . 430

10.4 Contingency table for the possible outcomes of a filtering
system. Here, TP (true positive) is the number of relevant
documents retrieved, FN (false negative) is the number of
relevant documents not retrieved, FP (false positive) is the
number of non-relevant documents retrieved, and TN (true
negative) is the number of non-relevant documents not retrieved. 431

11.1 Most likely one- and two-word concepts produced using latent
concept expansion with the top 25 documents retrieved for
the query “hubble telescope achievements” on the TREC
ROBUST collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460

11.2 Example TREC QA questions and their corresponding
question categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469





1
Search Engines and Information
Retrieval

“Mr. Helpmann, I’m keen to get into
Information Retrieval.”

Sam Lowry, Brazil

1.1 What Is Information Retrieval?

This book is designed to help people understand search engines, evaluate and
compare them, and modify them for specific applications. Searching for infor-
mation on the Web is, for most people, a daily activity. Search and communi-
cation are by far the most popular uses of the computer. Not surprisingly, many
people in companies and universities are trying to improve search by coming up
with easier and faster ways to find the right information. These people, whether
they call themselves computer scientists, software engineers, information scien-
tists, search engine optimizers, or something else, are working in the field of In-
formation Retrieval.1 So, before we launch into a detailed journey through the
internals of search engines, we will take a few pages to provide a context for the
rest of the book.

Gerard Salton, a pioneer in information retrieval and one of the leading figures
from the 1960s to the 1990s, proposed the following definition in his classic 1968
textbook (Salton, 1968):

Information retrieval is a field concerned with the structure, analysis, or-
ganization, storage, searching, and retrieval of information.

Despite the huge advances in the understanding and technology of search in the
past 40 years, this definition is still appropriate and accurate. The term “informa-
1 Information retrieval is often abbreviated as IR. In this book, we mostly use the full
term.This has nothing to do with the fact that many people think IRmeans “infrared”
or something else.



2 1 Search Engines and Information Retrieval

tion” is very general, and information retrieval includes work on a wide range of
types of information and a variety of applications related to search.

The primary focus of the field since the 1950s has been on text and text docu-
ments. Web pages, email, scholarly papers, books, and news stories are just a few
of the many examples of documents. All of these documents have some amount
of structure, such as the title, author, date, and abstract information associated
with the content of papers that appear in scientific journals. The elements of this
structure are called attributes, or fields, when referring to database records. The
important distinction between a document and a typical database record, such as
a bank account record or a flight reservation, is that most of the information in
the document is in the form of text, which is relatively unstructured.

To illustrate this difference, consider the information contained in two typical
attributes of an account record, the accountnumber and current balance. Both are
very well defined, both in terms of their format (for example, a six-digit integer
for an account number and a real number with two decimal places for balance)
and their meaning. It is very easy to compare values of these attributes, and conse-
quently it is straightforward to implement algorithms to identify the records that
satisfy queries such as “Find account number 321456” or “Find accounts with
balances greater than $50,000.00”.

Now consider a news story about themerger of two banks.The story will have
some attributes, such as the headline and source of the story, but the primary con-
tent is the story itself. In a database system, this critical piece of informationwould
typically be stored as a single large attribute with no internal structure. Most of
the queries submitted to a web search engine such as Google2 that relate to this
story will be of the form “bank merger” or “bank takeover”. To do this search,
we must design algorithms that can compare the text of the queries with the text
of the story and decide whether the story contains the information that is being
sought. Defining themeaning of a word, a sentence, a paragraph, or a whole news
story is much more difficult than defining an account number, and consequently
comparing text is not easy. Understanding and modeling how people compare
texts, and designing computer algorithms to accurately perform this comparison,
is at the core of information retrieval.

Increasingly, applications of information retrieval involve multimedia docu-
ments with structure, significant text content, and other media. Popular infor-
mation media include pictures, video, and audio, including music and speech. In

2 http://www.google.com



1.1 What Is Information Retrieval? 3

some applications, such as in legal support, scanned document images are also
important. These media have content that, like text, is difficult to describe and
compare.The current technology for searching non-text documents relies on text
descriptions of their content rather than the contents themselves, but progress is
being made on techniques for direct comparison of images, for example.

In addition to a range of media, information retrieval involves a range of tasks
and applications.The usual search scenario involves someone typing in a query to
a search engine and receiving answers in the form of a list of documents in ranked
order. Although searching the World Wide Web (web search) is by far the most
common application involving information retrieval, search is also a crucial part
of applications in corporations, government, and many other domains. Vertical
search is a specialized form of web search where the domain of the search is re-
stricted to a particular topic.Enterprise search involves finding the required infor-
mation in the huge variety of computer files scattered across a corporate intranet.
Web pages are certainly a part of that distributed information store, but most
information will be found in sources such as email, reports, presentations, spread-
sheets, and structured data in corporate databases. Desktop search is the personal
version of enterprise search, where the information sources are the files stored
on an individual computer, including email messages and web pages that have re-
cently been browsed.Peer-to-peer search involves finding information in networks
of nodes or computers without any centralized control. This type of search began
as a file sharing tool for music but can be used in any community based on shared
interests, or even shared locality in the case of mobile devices. Search and related
information retrieval techniques are used for advertising, for intelligence analy-
sis, for scientific discovery, for health care, for customer support, for real estate,
and so on. Any application that involves a collection3of text or other unstructured
information will need to organize and search that information.

Search based on a user query (sometimes called ad hoc search because the range
of possible queries is huge and not prespecified) is not the only text-based task
that is studied in information retrieval. Other tasks include filtering, classification,
and question answering. Filtering or tracking involves detecting stories of interest
based on a person’s interests and providing an alert using email or some other
mechanism. Classification or categorization uses a defined set of labels or classes

3 The term database is often used to refer to a collection of either structured or unstruc-
tured data. To avoid confusion, we mostly use the term document collection (or just
collection) for text. However, the terms web database and search engine database are so
common that we occasionally use them in this book.



4 1 Search Engines and Information Retrieval

(such as the categories listed in the Yahoo! Directory4) and automatically assigns
those labels to documents. Question answering is similar to search but is aimed
at more specific questions, such as “What is the height of Mt. Everest?”. The goal
of question answering is to return a specific answer found in the text, rather than
a list of documents. Table 1.1 summarizes some of these aspects or dimensions of
the field of information retrieval.

Examples of Examples of Examples of
Content Applications Tasks

Text Web search Ad hoc search
Images Vertical search Filtering
Video Enterprise search Classification

Scanned documents Desktop search Question answering
Audio Peer-to-peer search
Music

Table 1.1. Some dimensions of information retrieval

1.2 The Big Issues

Information retrieval researchers have focused on a few key issues that remain just
as important in the era of commercial web search engines working with billions
of web pages as they were when tests were done in the 1960s on document col-
lections containing about 1.5 megabytes of text. One of these issues is relevance.
Relevance is a fundamental concept in information retrieval. Loosely speaking, a
relevant document contains the information that a person was looking for when
she submitted a query to the search engine.Although this sounds simple, there are
many factors that go into a person’s decision as to whether a particular document
is relevant. These factors must be taken into account when designing algorithms
for comparing text and ranking documents. Simply comparing the text of a query
with the text of a document and looking for an exact match, as might be done in
a database system or using the grep utility in Unix, produces very poor results in
terms of relevance. One obvious reason for this is that language can be used to ex-

4 http://dir.yahoo.com/



1.2 The Big Issues 5

press the same concepts in many different ways, often with very different words.
This is referred to as the vocabulary mismatch problem in information retrieval.

It is also important to distinguish between topical relevance and user relevance.
A text document is topically relevant to a query if it is on the same topic. For ex-
ample, a news story about a tornado in Kansas would be topically relevant to the
query “severe weather events”. The person who asked the question (often called
the user) may not consider the story relevant, however, if she has seen that story
before, or if the story is five years old, or if the story is in Chinese from a Chi-
nese news agency. User relevance takes these additional features of the story into
account.

To address the issue of relevance, researchers propose retrieval models and test
howwell they work. A retrieval model is a formal representation of the process of
matching a query and a document. It is the basis of the ranking algorithm that is
used in a search engine to produce the ranked list of documents. A good retrieval
model will find documents that are likely to be considered relevant by the person
who submitted the query. Some retrieval models focus on topical relevance, but
a search engine deployed in a real environment must use ranking algorithms that
incorporate user relevance.

An interesting feature of the retrieval models used in information retrieval is
that they typicallymodel the statistical properties of text rather than the linguistic
structure. This means, for example, that the ranking algorithms are typically far
more concerned with the counts of word occurrences than whether the word is a
noun or an adjective. More advanced models do incorporate linguistic features,
but they tend to be of secondary importance. The use of word frequency infor-
mation to represent text started with another information retrieval pioneer, H.P.
Luhn, in the 1950s. This view of text did not become popular in other fields of
computer science, such as natural language processing, until the 1990s.

Another core issue for information retrieval is evaluation. Since the quality of
a document ranking depends on how well it matches a person’s expectations, it
was necessary early on to develop evaluation measures and experimental proce-
dures for acquiring this data and using it to compare ranking algorithms. Cyril
Cleverdon led the way in developing evaluation methods in the early 1960s, and
two of the measures he used, precision and recall, are still popular. Precision is a
very intuitive measure, and is the proportion of retrieved documents that are rel-
evant. Recall is the proportion of relevant documents that are retrieved. When
the recall measure is used, there is an assumption that all the relevant documents
for a given query are known. Such an assumption is clearly problematic in a web



6 1 Search Engines and Information Retrieval

search environment, but with smaller test collections of documents, this measure
can be useful. A test collection5 for information retrieval experiments consists of
a collection of text documents, a sample of typical queries, and a list of relevant
documents for each query (the relevance judgments). The best-known test collec-
tions are those associated with the TREC6 evaluation forum.

Evaluation of retrieval models and search engines is a very active area, with
much of the current focus on using large volumes of log data from user interac-
tions, such as clickthrough data, which records the documents that were clicked
on during a search session. Clickthrough and other log data is strongly correlated
with relevance so it can be used to evaluate search, but search engine companies
still use relevance judgments in addition to log data to ensure the validity of their
results.

The third core issue for information retrieval is the emphasis on users and their
information needs. This should be clear given that the evaluation of search is user-
centered. That is, the users of a search engine are the ultimate judges of quality.
This has led to numerous studies on how people interact with search engines and,
in particular, to the development of techniques to help people express their in-
formation needs. An information need is the underlying cause of the query that
a person submits to a search engine. In contrast to a request to a database system,
such as for the balance of a bank account, text queries are often poor descriptions
ofwhat the user actuallywants. A one-word query such as “cats” could be a request
for information on where to buy cats or for a description of the Broadway musi-
cal. Despite their lack of specificity, however, one-word queries are very common
in web search. Techniques such as query suggestion, query expansion, and relevance
feedback use interaction and context to refine the initial query in order to produce
better ranked lists.

These issues will come up throughout this book, and will be discussed in con-
siderably more detail. We now have sufficient background to start talking about
the main product of research in information retrieval—namely, search engines.

1.3 Search Engines

A search engine is the practical application of information retrieval techniques
to large-scale text collections. A web search engine is the obvious example, but as

5 Also known as an evaluation corpus (plural corpora).
6 Text REtrieval Conference—http://trec.nist.gov/



1.3 Search Engines 7

has been mentioned, search engines can be found in many different applications,
such as desktop search or enterprise search. Search engines have been around for
many years. For example, MEDLINE, the online medical literature search sys-
tem, started in the 1970s. The term “search engine” was originally used to refer
to specialized hardware for text search. From the mid-1980s onward, however, it
gradually came to be used in preference to “information retrieval system” as the
name for the software system that compares queries to documents and produces
ranked result lists of documents. There is much more to a search engine than the
ranking algorithm, of course, and we will discuss the general architecture of these
systems in the next chapter.

Search engines come in a number of configurations that reflect the applica-
tions they are designed for.Web search engines, such asGoogle andYahoo!,7 must
be able to capture, or crawl, many terabytes of data, and then provide subsecond
response times tomillions of queries submitted every day from around the world.
Enterprise search engines—for example, Autonomy8—must be able to process
the large variety of information sources in a company and use company-specific
knowledge as part of search and related tasks, such as data mining. Data mining
refers to the automatic discovery of interesting structure in data and includes tech-
niques such as clustering. Desktop search engines, such as the Microsoft Vista™
search feature, must be able to rapidly incorporate new documents, web pages,
and email as the person creates or looks at them, as well as provide an intuitive
interface for searching this very heterogeneous mix of information. There is over-
lap between these categories with systems such as Google, for example, which is
available in configurations for enterprise and desktop search.

Open source search engines are another important class of systems that have
somewhat different design goals than the commercial search engines. There are a
number of these systems, and the Wikipedia page for information retrieval9 pro-
vides links to many of them. Three systems of particular interest are Lucene,10

Lemur,11 and the system provided with this book, Galago.12 Lucene is a popular
Java-based search engine that has been used for a wide range of commercial ap-
plications. The information retrieval techniques that it uses are relatively simple.

7 http://www.yahoo.com
8 http://www.autonomy.com
9 http://en.wikipedia.org/wiki/Information_retrieval

10 http://lucene.apache.org
11 http://www.lemurproject.org
12 http://www.search-engines-book.com



8 1 Search Engines and Information Retrieval

Lemur is an open source toolkit that includes the Indri C++-based search engine.
Lemur has primarily been used by information retrieval researchers to compare
advanced search techniques. Galago is a Java-based search engine that is based on
the Lemur and Indri projects.The assignments in this bookmake extensive use of
Galago. It is designed to be fast, adaptable, and easy to understand, and incorpo-
rates very effective information retrieval techniques.

The “big issues” in the design of search engines include the ones identified for
information retrieval: effective ranking algorithms, evaluation, and user interac-
tion.There are, however, a number of additional critical features of search engines
that result from their deployment in large-scale, operational environments. Fore-
most among these features is the performance of the search engine in terms ofmea-
sures such as response time, query throughput, and indexing speed. Response time
is the delay between submitting a query and receiving the result list, throughput
measures the number of queries that can be processed in a given time, and index-
ing speed is the rate at which text documents can be transformed into indexes
for searching. An index is a data structure that improves the speed of search. The
design of indexes for search engines is one of the major topics in this book.

Another important performancemeasure is how fast newdata can be incorpo-
rated into the indexes. Search applications typically dealwith dynamic, constantly
changing information. Coveragemeasures how much of the existing information
in, say, a corporate information environment has been indexed and stored in the
search engine, and recency or freshness measures the “age” of the stored informa-
tion.

Search engines canbeusedwith small collections, such as a fewhundred emails
and documents on a desktop, or extremely large collections, such as the entire
Web. There may be only a few users of a given application, or many thousands.
Scalability is clearly an important issue for search engine design. Designs that
work for a given application should continue to work as the amount of data and
the number of users grow. In section 1.1,we describedhow search engines are used
in many applications and for many tasks. To do this, they have to be customizable
or adaptable. This means that many different aspects of the search engine, such as
the ranking algorithm, the interface, or the indexing strategy, must be able to be
tuned and adapted to the requirements of the application.

Practical issues that impact search engine design also occur for specific appli-
cations.The best example of this is spam in web search. Spam is generally thought
of as unwanted email, but more generally it could be defined as misleading, inap-
propriate, or non-relevant information in a document that is designed for some



1.4 Search Engineers 9

commercial benefit. There are many kinds of spam, but one type that search en-
ginesmust deal with is spamwords put into a document to cause it to be retrieved
in response to popular queries.The practice of “spamdexing” can significantly de-
grade the quality of a search engine’s ranking, and web search engine designers
have to develop techniques to identify the spam and remove those documents.
Figure 1.1 summarizes the major issues involved in search engine design.

Relevance

-Effective ranking 

Evaluation

-Testing and measuring

Information needs

-User interaction

Performance

-Efficient search and indexing 

Incorporating new data

-Coverage and freshness

Scalability

-Growing with data and users

Adaptability

-Tuning for applications

Specific problems

-E.g., spam

Information Retrieval Search Engines

Fig. 1.1. Search engine design and the core information retrieval issues

Based on this discussion of the relationship between information retrieval and
search engines, we now consider what roles computer scientists and others play in
the design and use of search engines.

1.4 Search Engineers

Information retrieval research involves the development of mathematical models
of text and language, large-scale experiments with test collections or users, and
a lot of scholarly paper writing. For these reasons, it tends to be done by aca-
demics or people in research laboratories. These people are primarily trained in
computer science, although information science, mathematics, and, occasionally,
social science and computational linguistics are also represented. So who works



10 1 Search Engines and Information Retrieval

with search engines?To a large extent, it is the same sort of people butwith amore
practical emphasis. The computing industry has started to use the term search
engineer to describe this type of person. Search engineers are primarily people
trained in computer science, mostly with a systems or database background. Sur-
prisingly few of them have training in information retrieval, which is one of the
major motivations for this book.

What is the role of a search engineer? Certainly the people who work in the
major web search companies designing and implementing new search engines are
search engineers, but themajority of search engineers are the people whomodify,
extend, maintain, or tune existing search engines for a wide range of commercial
applications. People who design or “optimize” content for search engines are also
search engineers, as are people who implement techniques to deal with spam.The
search engines that search engineers work with cover the entire range mentioned
in the last section: they primarily use open source and enterprise search engines
for application development, but also get themost out of desktop and web search
engines.

The importance and pervasiveness of search inmodern computer applications
has meant that search engineering has become a crucial profession in the com-
puter industry. There are, however, very few courses being taught in computer
science departments that give students an appreciation of the variety of issues that
are involved, especially from the information retrieval perspective.This book is in-
tended to give potential search engineers the understanding and tools they need.

References and Further Reading

In each chapter, we provide some pointers to papers and books that give more
detail on the topics that have been covered. This additional reading should not
be necessary to understand material that has been presented, but instead will give
more background, more depth in some cases, and, for advanced topics, will de-
scribe techniques and research results that are not covered in this book.

The classic references on information retrieval, in our opinion, are the books
by Salton (1968; 1983) and vanRijsbergen (1979).VanRijsbergen’s book remains
popular, since it is available on the Web.13 All three books provide excellent de-
scriptions of the research done in the early years of information retrieval, up to
the late 1970s. Salton’s early book was particularly important in terms of defining

13 http://www.dcs.gla.ac.uk/Keith/Preface.html



1.4 Search Engineers 11

the field of information retrieval for computer science.More recent books include
Baeza-Yates and Ribeiro-Neto (1999) and Manning et al. (2008).

Research papers on all the topics covered in this book can be found in the
Proceedings of the Association for Computing Machinery (ACM) Special In-
terest Group on Information Retrieval (SIGIR) Conference. These proceedings
are available on the Web as part of the ACM Digital Library.14 Good papers
on information retrieval and search also appear in the European Conference
on Information Retrieval (ECIR), the Conference on Information and Knowl-
edge Management (CIKM), and the Web Search and Data Mining Conference
(WSDM). The WSDM conference is a spin-off of the World Wide Web Confer-
ence (WWW), which has included some important papers on web search. The
proceedings from the TREC workshops are available online and contain useful
descriptions of new research techniques frommany different academic and indus-
try groups. An overview of the TREC experiments can be found in Voorhees and
Harman (2005). An increasing number of search-related papers are beginning to
appear in database conferences, such as VLDB and SIGMOD.Occasional papers
also show up in language technology conferences, such as ACL and HLT (As-
sociation for Computational Linguistics and Human Language Technologies),
machine learning conferences, and others.

Exercises

1.1. Think up and write down a small number of queries for a web search engine.
Make sure that the queries vary in length (i.e., they are not all one word). Try
to specify exactly what information you are looking for in some of the queries.
Run these queries on two commercial web search engines and compare the top
10 results for each query by doing relevance judgments. Write a report that an-
swers at least the following questions: What is the precision of the results? What
is the overlap between the results for the two search engines? Is one search engine
clearly better than the other? If so, by how much? How do short queries perform
compared to long queries?

1.2. Site search is another common application of search engines. In this case,
search is restricted to the web pages at a given website. Compare site search to
web search, vertical search, and enterprise search.

14 http://www.acm.org/dl



12 1 Search Engines and Information Retrieval

1.3. Use the Web to find as many examples as you can of open source search en-
gines, information retrieval systems, or related technology. Give a brief descrip-
tion of each search engine and summarize the similarities and differences between
them.

1.4. List fiveweb services or sites that youuse that appear to use search,not includ-
ing web search engines. Describe the role of search for that service. Also describe
whether the search is based on adatabase or grep style ofmatching, or if the search
is using some type of ranking.



2
Architecture of a Search Engine

“While your first question may be the most per-
tinent, you may or may not realize it is also the
most irrelevant.”

The Architect,Matrix Reloaded

2.1 What Is an Architecture?

In this chapter, we describe the basic software architecture of a search engine. Al-
though there is no universal agreement on the definition, a software architecture
generally consists of software components, the interfaces provided by those com-
ponents, and the relationships between them. An architecture is used to describe
a system at a particular level of abstraction. An example of an architecture used to
provide a standard for integrating search and related language technology compo-
nents is UIMA (Unstructured InformationManagement Architecture).1 UIMA
defines interfaces for components in order to simplify the addition of new tech-
nologies into systems that handle text and other unstructured data.

Our search engine architecture is used to present high-level descriptions of
the important components of the system and the relationships between them. It
is not a code-level description, although some of the components do correspond
to software modules in the Galago search engine and other systems. We use this
architecture in this chapter and throughout the book to provide context to the
discussion of specific techniques.

An architecture is designed to ensure that a system will satisfy the application
requirements or goals. The two primary goals of a search engine are:

• Effectiveness (quality): We want to be able to retrieve the most relevant set of
documents possible for a query.

• Efficiency (speed): We want to process queries from users as quickly as possi-
ble.

1 http://www.research.ibm.com/UIMA



14 2 Architecture of a Search Engine

We may have more specific goals, too, but usually these fall into the categories
of effectiveness or efficiency (or both). For instance, the collection of documents
we want to search may be changing; making sure that the search engine immedi-
ately reacts to changes in documents is both an effectiveness issue and an efficiency
issue.

The architecture of a search engine is determined by these two requirements.
Becausewewant an efficient system, search engines employ specialized data struc-
tures that are optimized for fast retrieval. Because we want high-quality results,
search engines carefully process text and store text statistics that help improve the
relevance of results.

Many of the components we discuss in the following sections have been used
for decades, and this general design has been shown to be a useful compromise
between the competing goals of effective and efficient retrieval. In later chapters,
we will discuss these components in more detail.

2.2 Basic Building Blocks

Search engine components support twomajor functions, whichwe call the index-
ing process and the query process. The indexing process builds the structures that
enable searching, and the query process uses those structures and a person’s query
to produce a ranked list of documents. Figure 2.1 shows the high-level “building
blocks” of the indexing process. These major components are text acquisition, text
transformation, and index creation.

The task of the text acquisition component is to identify and make available
the documents that will be searched. Although in some cases this will involve sim-
ply using an existing collection, text acquisition will more often require building
a collection by crawling or scanning the Web, a corporate intranet, a desktop, or
other sources of information. In addition to passing documents to the next com-
ponent in the indexing process, the text acquisition component creates a docu-
ment data store, which contains the text and metadata for all the documents.
Metadata is information about a document that is not part of the text content,
such the document type (e.g., email or web page), document structure, and other
features, such as document length.

The text transformation component transforms documents into index terms
or features. Index terms, as the name implies, are the parts of a document that
are stored in the index and used in searching. The simplest index term is a word,
but not every word may be used for searching. A “feature” is more often used in



2.2 Basic Building Blocks 15

Email, web pages, 
news articles, memos, letters

Text Acquisition

Text Transformation

Index Creation

Index

Document data store

Fig. 2.1. The indexing process

the field of machine learning to refer to a part of a text document that is used to
represent its content, which also describes an index term. Examples of other types
of index terms or features are phrases, names of people, dates, and links in a web
page. Index terms are sometimes simply referred to as “terms.” The set of all the
terms that are indexed for a document collection is called the index vocabulary.

The index creation component takes the output of the text transformation
component and creates the indexes or data structures that enable fast searching.
Given the large number of documents inmany search applications, index creation
must be efficient, both in terms of time and space. Indexes must also be able to be
efficiently updated when new documents are acquired. Inverted indexes, or some-
times inverted files, are by far the most common form of index used by search
engines. An inverted index, very simply, contains a list for every index term of the
documents that contain that index term. It is inverted in the sense of being the
opposite of a document file that lists, for every document, the index terms they
contain.There are many variations of inverted indexes, and the particular form of
index used is one of the most important aspects of a search engine.

Figure 2.2 shows the building blocks of the query process. The major compo-
nents are user interaction, ranking, and evaluation.

The user interaction component provides the interface between the person
doing the searching and the search engine.One task for this component is accept-
ing the user’s query and transforming it into index terms. Another task is to take
the ranked list of documents from the search engine and organize it into the re-



16 2 Architecture of a Search Engine

User Interaction

Evaluation

Ranking

Index

Document data store

Log data

Fig. 2.2. The query process

sults shown to the user.This includes, for example, generating the snippets used to
summarize documents.The document data store is one of the sources of informa-
tion used in generating the results. Finally, this component also provides a range
of techniques for refining the query so that it better represents the information
need.

The ranking component is the core of the search engine. It takes the trans-
formed query from the user interaction component and generates a ranked list of
documents using scores based on a retrieval model. Ranking must be both effi-
cient, since many queries may need to be processed in a short time, and effective,
since the quality of the ranking determines whether the search engine accom-
plishes the goal of finding relevant information.The efficiency of ranking depends
on the indexes, and the effectiveness depends on the retrieval model.

The task of the evaluation component is tomeasure andmonitor effectiveness
and efficiency. An important part of that is to record and analyze user behavior
using log data. The results of evaluation are used to tune and improve the ranking
component. Most of the evaluation component is not part of the online search
engine, apart from logging user and system data. Evaluation is primarily an offline
activity, but it is a critical part of any search application.



2.3 Breaking It Down 17

2.3 Breaking It Down

We now look in more detail at the components of each of the basic building
blocks. Not all of these components will be part of every search engine, but to-
gether they coverwhatwe consider to be themost important functions for a broad
range of search applications.

2.3.1 Text Acquisition

Crawler

In many applications, the crawler component has the primary responsibility for
identifying and acquiring documents for the search engine.There are a number of
different types of crawlers, but themost common is the generalweb crawler.Aweb
crawler is designed to follow the links onwebpages todiscover anddownloadnew
pages. Although this sounds deceptively simple, there are significant challenges in
designing a web crawler that can efficiently handle the huge volume of new pages
on the Web, while at the same time ensuring that pages that may have changed
since the last time a crawler visited a site are kept “fresh” for the search engine. A
web crawler can be restricted to a single site, such as a university, as the basis for
site search. Focused, or topical, web crawlers use classification techniques to restrict
the pages that are visited to those that are likely to be about a specific topic. This
type of crawler may be used by a vertical or topical search application, such as a
search engine that provides access to medical information on web pages.

Text Acquisition

Crawler
Feeds
Conversion
Document data store

For enterprise search, the crawler is adapted to discover and update all docu-
ments and web pages related to a company’s operation. An enterprise document
crawler follows links to discover both external and internal (i.e., restricted to the
corporate intranet) pages, but also must scan both corporate and personal di-
rectories to identify email, word processing documents, presentations, database
records, and other company information. Document crawlers are also used for
desktop search, although in this case only the user’s personal directories need to
be scanned.

Feeds

Document feeds are a mechanism for accessing a real-time stream of documents.
For example, a news feed is a constant stream of news stories and updates. In con-
trast to a crawler, which must discover new documents, a search engine acquires



18 2 Architecture of a Search Engine

new documents from a feed simply bymonitoring it.RSS2 is a common standard
used for web feeds for content such as news, blogs, or video. An RSS “reader”
is used to subscribe to RSS feeds, which are formatted using XML.3 XML is a
language for describing data formats, similar to HTML.4 The reader monitors
those feeds and provides new content when it arrives. Radio and television feeds
are also used in some search applications, where the “documents” contain auto-
matically segmented audio and video streams, together with associated text from
closed captions or speech recognition.

Conversion

The documents found by a crawler or provided by a feed are rarely in plain text.
Instead, they come in a variety of formats, such as HTML, XML, Adobe PDF,
MicrosoftWord™,Microsoft PowerPoint®, and so on.Most search engines require
that these documents be converted into a consistent text plus metadata format.
In this conversion, the control sequences and non-content data associated with
a particular format are either removed or recorded as metadata. In the case of
HTML andXML,much of this process can be described as part of the text trans-
formation component. For other formats, the conversion process is a basic step
that prepares the document for further processing. PDF documents, for example,
must be converted to text. Various utilities are available that perform this conver-
sion, with varying degrees of accuracy. Similarly, utilities are available to convert
the various Microsoft Office® formats into text.

Another common conversion problem comes from theway text is encoded in a
document. ASCII5 is a common standard single-byte character encoding scheme
used for text. ASCII uses either 7 or 8 bits (extended ASCII) to represent either
128 or 256 possible characters. Some languages, however, such as Chinese, have
manymore characters than English and use a number of other encoding schemes.
Unicode is a standard encoding scheme that uses 16 bits (typically) to represent
most of the world’s languages. Any application that deals with documents in dif-
ferent languages has to ensure that they are converted into a consistent encoding
scheme before further processing.

2 RSS actually refers to a family of standards with similar names (and the same initials),
such as Really Simple Syndication or Rich Site Summary.

3 eXtensible Markup Language
4 HyperText Markup Language
5 American Standard Code for Information Interchange



2.3 Breaking It Down 19

Document data store

The document data store is a database used to manage large numbers of docu-
ments and the structured data that is associated with them. The document con-
tents are typically stored in compressed form for efficiency. The structured data
consists of document metadata and other information extracted from the docu-
ments, such as links and anchor text (the text associated with a link). A relational
database system can be used to store the documents and metadata. Some applica-
tions, however, use a simpler, more efficient storage system to provide very fast
retrieval times for very large document stores.

Although the original documents are available on the Web, in the enterprise
database, the document data store is necessary to provide fast access to the doc-
ument contents for a range of search engine components. Generating summaries
of retrieved documents, for example, would take far too long if the search engine
had to access the original documents and reprocess them.

2.3.2 Text Transformation

Parser

The parsing component is responsible for processing the sequence of text tokens
in the document to recognize structural elements such as titles, figures, links, and
headings. Tokenizing the text is an important first step in this process. In many
cases, tokens are the same as words. Both document and query text must be trans-
formed into tokens in the samemanner so that they can be easily compared.There
are a number of decisions that potentially affect retrieval that make tokenizing
non-trivial. For example, a simple definition for tokens could be strings of al-
phanumeric characters that are separated by spaces.This does not tell us, however,
how to deal with special characters such as capital letters, hyphens, and apostro-
phes. Should we treat “apple” the same as “Apple”? Is “on-line” two words or one
word? Should the apostrophe in “O’Connor” be treated the same as the one in
“owner’s”? In some languages, tokenizing gets evenmore interesting. Chinese, for
example, has no obvious word separator like a space in English.

Text Transformation

Parser
Stopping
Stemming
Link Analysis
Information Extraction
Classifier

Document structure is often specified by a markup language such as HTML
or XML. HTML is the default language used for specifying the structure of web
pages. XML has much more flexibility and is used as a data interchange format
for many applications. The document parser uses knowledge of the syntax of the
markup language to identify the structure.



20 2 Architecture of a Search Engine

Both HTML and XML use tags to define document elements. For example,
<h2> Search </h2> defines “Search” as a second-level heading inHTML.Tags and
other control sequences must be treated appropriately when tokenizing. Other
types of documents, such as email and presentations, have a specific syntax and
methods for specifying structure, but much of this may be be removed or simpli-
fied by the conversion component.

Stopping

The stopping component has the simple task of removing common words from
the stream of tokens that become index terms. The most common words are typ-
ically function words that help form sentence structure but contribute little on
their own to the description of the topics covered by the text. Examples are “the”,
“of ”, “to”, and “for”. Because they are so common, removing them can reduce the
size of the indexes considerably. Depending on the retrieval model that is used as
the basis of the ranking, removing thesewords usually has no impact on the search
engine’s effectiveness, andmay even improve it somewhat.Despite these potential
advantages, it can be difficult to decide how many words to include on the stop-
word list. Some stopword lists used in research contain hundreds of words. The
problem with using such lists is that it becomes impossible to search with queries
like “to be or not to be” or “down under”. To avoid this, search applications may
use very small stopword lists (perhaps just containing “the”)whenprocessing doc-
ument text, but then use longer lists for the default processing of query text.

Stemming

Stemming is another word-level transformation. The task of the stemming com-
ponent (or stemmer) is to group words that are derived from a common stem.
Grouping “fish”, “fishes”, and “fishing” is one example. By replacing each member
of a groupwith one designated word (for example, the shortest, which in this case
is “fish”), we increase the likelihood that words used in queries and documents
will match. Stemming, in fact, generally produces small improvements in ranking
effectiveness. Similar to stopping, stemming can be done aggressively, conserva-
tively, or not at all. Aggressive stemming can cause search problems. It may not be
appropriate, for example, to retrieve documents about different varieties of fish in
response to the query “fishing”. Some search applications use more conservative
stemming, such as simply identifying plural forms using the letter “s”, or they may



2.3 Breaking It Down 21

do no stemmingwhen processing document text and focus on adding appropriate
word variants to the query.

Some languages, such as Arabic, have more complicatedmorphology than En-
glish, and stemming is consequentlymore important.An effective stemming com-
ponent in Arabic has a huge impact on search effectiveness. In contrast, there is
little word variation in other languages, such as Chinese, and for these languages
stemming is not effective.

Link extraction and analysis

Links and the corresponding anchor text in web pages can readily be identified
and extracted during document parsing. Extraction means that this information
is recorded in the document data store, and can be indexed separately from the
general text content. Web search engines make extensive use of this information
through link analysis algorithms such as PageRank (Brin & Page, 1998). Link
analysis provides the search engine with a rating of the popularity, and to some
extent, the authority of a page (in other words, how important it is). Anchor text,
which is the clickable text of a web link, can be used to enhance the text content
of a page that the link points to. These two factors can significantly improve the
effectiveness of web search for some types of queries.

Information extraction

Information extraction is used to identify index terms that aremore complex than
single words. This may be as simple as words in bold or words in headings, but in
general may require significant additional computation. Extracting syntactic fea-
tures such as noun phrases, for example, requires some form of syntactic analysis
or part-of-speech tagging. Research in this area has focused on techniques for ex-
tracting features with specific semantic content, such as named entity recognizers,
which can reliably identify information such as person names, company names,
dates, and locations.

Classifier

The classifier component identifies class-related metadata for documents or parts
of documents.This covers a range of functions that are often described separately.
Classification techniques assign predefined class labels to documents.These labels
typically represent topical categories such as “sports”, “politics”, or “business”. Two



22 2 Architecture of a Search Engine

important examples of other types of classification are identifying documents as
spam, and identifying the non-content parts of documents, such as advertising.
Clustering techniques are used to group related documents without predefined
categories.These document groups can be used in a variety of ways during ranking
or user interaction.

2.3.3 Index Creation

Document statistics

Index Creation

Document Statistics
Weighting
Inversion
Distribution

The task of the document statistics component is simply to gather and record
statistical information about words, features, and documents. This information
is used by the ranking component to compute scores for documents. The types
of data generally required are the counts of index term occurrences (both words
and more complex features) in individual documents, the positions in the doc-
uments where the index terms occurred, the counts of occurrences over groups
of documents (such as all documents labeled “sports” or the entire collection of
documents), and the lengths of documents in terms of the number of tokens.The
actual data required is determined by the retrieval model and associated rank-
ing algorithm. The document statistics are stored in lookup tables, which are data
structures designed for fast retrieval.

Weighting

Index term weights reflect the relative importance of words in documents, and
are used in computing scores for ranking. The specific form of a weight is deter-
mined by the retrieval model. The weighting component calculates weights using
the document statistics and stores them in lookup tables.Weights could be calcu-
lated as part of the query process, and some types of weights require information
about the query, but by doing as much calculation as possible during the indexing
process, the efficiency of the query process will be improved.

Oneof themost common types used in older retrievalmodels is knownas tf.idf
weighting. There are many variations of these weights, but they are all based on a
combination of the frequency or count of index term occurrences in a document
(the term frequency, or tf ) and the frequency of index term occurrence over the
entire collectionof documents (inverse documentfrequency, or idf ).The idfweight
is called inverse document frequency because it gives high weights to terms that
occur in very few documents. A typical formula for idf is logN/n, whereN is the



2.3 Breaking It Down 23

total number of documents indexed by the search engine and n is the number of
documents that contain a particular term.

Inversion

The inversion component is the core of the indexing process. Its task is to change
the stream of document-term information coming from the text transformation
component into term-document information for the creation of inverted indexes.
The challenge is to do this efficiently, not only for large numbers of documents
when the inverted indexes are initially created, but also when the indexes are up-
dated with new documents from feeds or crawls. The format of the inverted in-
dexes is designed for fast query processing and depends to some extent on the
ranking algorithm used. The indexes are also compressed to further enhance effi-
ciency.

Index distribution

The index distribution component distributes indexes across multiple computers
and potentially across multiple sites on a network. Distribution is essential for
efficient performance with web search engines. By distributing the indexes for a
subset of the documents (document distribution), both indexing and query pro-
cessing can be done in parallel. Distributing the indexes for a subset of terms (term
distribution) can also support parallel processing of queries. Replication is a form
of distribution where copies of indexes or parts of indexes are stored in multiple
sites so that query processing can be made more efficient by reducing communi-
cation delays. Peer-to-peer search involves a less organized form of distribution
where each node in a network maintains its own indexes and collection of docu-
ments.

2.3.4 User Interaction

Query input

User Interaction

Query input
Query transformation
Results Output

The query input component provides an interface and a parser for a query lan-
guage. The simplest query languages, such as those used in most web search in-
terfaces, have only a small number of operators. An operator is a command in the
query language that is used to indicate text that should be treated in a special way.
In general, operators help to clarify themeaning of the query by constraining how



24 2 Architecture of a Search Engine

text in the document can match text in the query. An example of an operator in
a simple query language is the use of quotes to indicate that the enclosed words
should occur as a phrase in the document, rather than as individual wordswith no
relationship. A typical web query, however, consists of a small number of keywords
with no operators. A keyword is simply aword that is important for specifying the
topic of a query. Because the ranking algorithms for most web search engines are
designed for keyword queries, longer queries thatmay contain a lower proportion
of keywords typically do not work well. For example, the query “search engines”
may produce a better result with a web search engine than the query “what are
typical implementation techniques and data structures used in search engines”.
One of the challenges for search engine design is to give good results for a range
of queries, and better results for more specific queries.

More complex query languages are available, either for people who want to
have a lot of control over the search results or for applications using a search en-
gine. In the same way that the SQL query language (Elmasri & Navathe, 2006)
is not designed for the typical user of a database application (the end user), these
query languages are not designed for the end users of search applications.Boolean
query languages have a long history in information retrieval.The operators in this
language includeBooleanAND,OR, andNOT, and some formof proximityopera-
tor that specifies thatwordsmust occur togetherwithin a specificdistance (usually
in terms ofword count).Other query languages include these and other operators
in a probabilistic framework designed to allow specification of features related to
both document structure and content.

Query transformation

The query transformation component includes a range of techniques that are de-
signed to improve the initial query, both before and after producing a document
ranking. The simplest processing involves some of the same text transformation
techniques used on document text. Tokenizing, stopping, and stemming must be
done on the query text to produce index terms that are comparable to the docu-
ment terms.

Spell checking and query suggestion are query transformation techniques that
produce similar output. In both cases, the user is presented with alternatives to
the initial query that are likely to either correct spelling errors or be more spe-
cific descriptions of their information needs. These techniques often leverage the
extensive query logs collected for web applications. Query expansion techniques



2.3 Breaking It Down 25

also suggest or add additional terms to the query, but usually based on an analy-
sis of term occurrences in documents. This analysis may use different sources of
information, such as the whole document collection, the retrieved documents, or
documents on the user’s computer.Relevance feedback is a technique that expands
queries based on term occurrences in documents that are identified as relevant by
the user.

Results output

Theresults output component is responsible for constructing thedisplay of ranked
documents coming from the ranking component. This may include tasks such as
generating snippets to summarize the retrieved documents, highlighting impor-
tant words and passages in documents, clustering the output to identify related
groups of documents, and finding appropriate advertising to add to the results
display. In applications that involve documents in multiple languages, the results
may be translated into a common language.

2.3.5 Ranking

Ranking

Scoring
Optimization
Distribution

Scoring

The scoring component, also called query processing, calculates scores for docu-
ments using the ranking algorithm, which is based on a retrieval model. The de-
signers of some search engines explicitly state the retrieval model they use. For
other search engines, only the ranking algorithm is discussed (if any details at all
are revealed), but all ranking algorithms are based implicitly on a retrieval model.
The features and weights used in a ranking algorithm, which may have been de-
rived empirically (by testing and evaluation), must be related to topical and user
relevance, or the search engine would not work.

Many different retrieval models and methods of deriving ranking algorithms
have been proposed. The basic form of the document score calculated by many of
these models is ?

i

qi.di

where the summation is over all of the terms in the vocabulary of the collection,
qi is the query term weight of the ith term, and di is the document term weight.
The term weights depend on the particular retrieval model being used, but are
generally similar to tf.idf weights. InChapter 7, we discuss the ranking algorithms



26 2 Architecture of a Search Engine

based on the BM25 and query likelihood retrieval models (as well as others) in
more detail.

Thedocument scoresmust be calculated and compared very rapidly in order to
determine the ranked order of the documents that are given to the results output
component. This is the task of the performance optimization component.

Performance optimization

Performance optimization involves the design of ranking algorithms and the as-
sociated indexes to decrease response time and increase query throughput. Given
a particular form of document scoring, there are a number of ways to calculate
those scores and produce the ranked document output. For example, scores can
be computed by accessing the index for a query term, computing the contribution
for that term to a document’s score, adding this contribution to a score accumula-
tor, and then accessing the next index.This is referred to as term-at-a-time scoring.
Another alternative is to access all the indexes for the query terms simultaneously,
and compute scores by moving pointers through the indexes to find the terms
present in a document. In this document-at-a-time scoring, the final document
score is calculated immediately instead of being accumulated one term at a time.
In both cases, further optimizations are possible that significantly decrease the
time required to compute the top-ranked documents. Safe optimizations guaran-
tee that the scores calculated will be the same as the scores without optimization.
Unsafe optimizations, which do not have this property, can in some cases be faster,
so it is important to carefully evaluate the impact of the optimization.

Distribution

Given some form of index distribution, ranking can also be distributed. A query
broker decides how to allocate queries to processors in a network and is responsi-
ble for assembling the final ranked list for the query. The operation of the broker
depends on the form of index distribution. Caching is another form of distribu-
tionwhere indexes or even ranked document lists from previous queries are left in
local memory. If the query or index term is popular, there is a significant chance
that this information can be reused with substantial time savings.



2.3 Breaking It Down 27

2.3.6 Evaluation

Logging

Logs of the users’ queries and their interactions with the search engine are one
of the most valuable sources of information for tuning and improving search ef-
fectiveness and efficiency. Query logs can be used for spell checking, query sug-
gestions, query caching, and other tasks, such as helping to match advertising to
searches. Documents in a result list that are clicked on and browsed tend to be
relevant. This means that logs of user clicks on documents (clickthrough data)
and information such as the dwell time (time spent looking at a document) can
be used to evaluate and train ranking algorithms.

Evaluation

Logging
Ranking Analysis
Performance Analysis

Ranking analysis

Given either log data or explicit relevance judgments for a large number of (query,
document) pairs, the effectiveness of a ranking algorithm can be measured and
compared to alternatives. This is a critical part of improving a search engine and
selecting values for parameters that are appropriate for the application. A variety
of evaluation measures are commonly used, and these should also be selected to
measure outcomes that make sense for the application. Measures that emphasize
the quality of the top-ranked documents, rather than the whole list, for example,
are appropriate for many types of web queries.

Performance analysis

Theperformance analysis component involves monitoring and improving overall
system performance, in the same way that the ranking analysis component mon-
itors effectiveness. A variety of performance measures are used, such as response
time and throughput, but the measures used also depend on the application. For
example, a distributed search application should monitor network usage and ef-
ficiency in addition to other measures. For ranking analysis, test collections are
often used to provide a controlled experimental environment. The equivalent for
performance analysis is simulations, where actual networks, processors, storage
devices, and data are replaced with mathematical models that can be adjusted us-
ing parameters.



28 2 Architecture of a Search Engine

2.4 How Does It ReallyWork?

Now you know the names and the basic functions of the components of a search
engine, but we haven’t said much yet about how these components actually per-
form these functions. That’s what the rest of the book is about. Each chapter de-
scribes, in depth, howone ormore componentswork. If you still don’t understand
a component after finishing the appropriate chapter, you can study the Galago
code, which is one implementation of the ideas presented, or the references de-
scribed at the end of each chapter.

References and Further Reading

Detailed references on the techniques and models mentioned in the compo-
nent descriptions will be given in the appropriate chapters. There are a few gen-
eral references for search architectures. A database textbook, such as Elmasri and
Navathe (2006), provides descriptions of database system architecture and the
associated query languages that are interesting to compare with the search en-
gine architecture discussed here. There are some similarities at the high level, but
database systems focus on structured data and exactmatch rather than on text and
ranking, so most of the components are very different.

The classic research paper on web search engine architecture, which gives an
overview of an early version of Google, is Brin and Page (1998). Another system
overview for an earlier general-purpose search engine (Inquery) is found inCallan
et al. (1992). A comprehensive description of the Lucene architecture and com-
ponents can be found in Hatcher and Gospodnetic (2004).

Exercises

2.1. Find some examples of the search engine components described in this chap-
ter in the Galago code.

2.2. A more-like-this query occurs when the user can click on a particular docu-
ment in the result list and tell the search engine to find documents that are similar
to this one. Describe which low-level components are used to answer this type of
query and the sequence in which they are used.



2.4 How Does It ReallyWork? 29

2.3. Document filtering is an application that stores a large number of queries or
user profiles and compares these profiles to every incoming document on a feed.
Documents that are sufficiently similar to the profile are forwarded to that person
via email or some othermechanism.Describe the architecture of a filtering engine
and how it may differ from a search engine.





3
Crawls and Feeds

“You’ve stuck your webs intomy business for the
last time.”

Doc Ock, Spider Man 2

3.1 Deciding What to Search

This book is about the details of building a search engine, from the mathematics
behind ranking to the algorithms of query processing. Although we focus heav-
ily on the technology that makes search engines work, and great technology can
make a good search engine even better, it is the information in the document col-
lection that makes search engines useful. In other words, if the right documents
are not stored in the search engine, no search technique will be able to find rele-
vant information.

The title of this section implies the question, “What should we search?” The
simple answer is everything you possibly can. Every document answers at least one
question (i.e., “Now where was that document again?”), although the best doc-
uments answer many more. Every time a search engine adds another document,
the number of questions it can answer increases. On the other hand, addingmany
poor-quality documents increases the burden on the ranking process to find only
the best documents to show to the user. Web search engines, however, show how
successful search engines can be, even when they contain billions of low-quality
documents with little useful content.

Even useful documents can become less useful over time.This is especially true
of news and financial informationwhere, for example,many people want to know
about today’s stock market report, but only a few care about what happened yes-
terday. The frustration of finding out-of-date web pages and links in a search re-
sult list is, unfortunately, a common experience. Search engines are most effective
when they contain the most recent information in addition to archives of older
material.



32 3 Crawls and Feeds

This chapter introduces techniques for finding documents to search, whether
on the Web, on a file server, on a computer’s hard disk, or in an email program.
We will discuss strategies for storing documents and keeping those documents
up-to-date. Along the way, we will discuss how to pull data out of files, navigating
through issues of character encodings, obsolete file formats, duplicate documents,
and textual noise. By the end of this chapter you will have a solid grasp on how to
get document data into a search engine, ready to be indexed.

3.2 Crawling the Web

Tobuild a search engine that searchesweb pages, you first need a copy of the pages
that you want to search. Unlike some of the other sources of text we will consider
later, web pages are particularly easy to copy, since they are meant to be retrieved
over the Internet by browsers. This instantly solves one of the major problems of
getting information to search, which is how to get the data from the place it is
stored to the search engine.

Finding and downloading web pages automatically is called crawling, and a
program that downloads pages is called a web crawler.1 There are some unique
challenges to crawling web pages. The biggest problem is the sheer scale of the
Web. There are at least tens of billions of pages on the Internet. The “at least” in
the last sentence is there because nobody is sure how many pages there are. Even
if the number of pages in existence today could be measured exactly, that number
would be immediately wrong, because pages are constantly being created. Every
time a user adds a new blog post or uploads a photo, another web page is created.
Most organizations donot have enough storage space to store even a large fraction
of theWeb, butweb search providerswith plenty of resourcesmust still constantly
download new content to keep their collections current.

Another problem is that web pages are usually not under the control of the
people building the search engine database. Even if you know that you want to
copy all the pages from www.company.com, there is no easy way to find out how
many pages there are on the site.The owners of that sitemay notwant you to copy
some of the data, and will probably be angry if you try to copy it too quickly or
too frequently. Some of the data youwant to copymay be available only by typing
a request into a form, which is a difficult process to automate.

1 Crawling is also occasionally referred to as spidering, and a crawler is sometimes called
a spider.



3.2 Crawling the Web 33

3.2.1 Retrieving Web Pages

Each web page on the Internet has its own unique uniform resource locator, or
URL. AnyURLused to describe a web page has three parts: the scheme, the host-
name, and the resource name (Figure 3.1). Web pages are stored on web servers,
which use a protocol called Hypertext Transfer Protocol, or HTTP, to exchange
information with client software. Therefore, most URLs used on the Web start
with the scheme http, indicating that the URL represents a resource that can
be retrieved using HTTP. The hostname follows, which is the name of the com-
puter that is running the web server that holds this web page. In the figure, the
computer’s name is www.cs.umass.edu, which is a computer in the University of
Massachusetts Computer Science department. This URL refers to a page on that
computer called /csinfo/people.html.

http://www.cs.umass.edu/csinfo/people.html

http www.cs.umass.edu /csinfo/people.html
scheme hostname resource

Fig. 3.1. A uniform resource locator (URL), split into three parts

Webbrowsers andweb crawlers are twodifferent kinds ofweb clients, but both
fetch web pages in the same way. First, the client program connects to a domain
name system (DNS) server.TheDNS server translates the hostname into an inter-
net protocol (IP) address.This IP address is a number that is typically 32 bits long,
but some networks now use 128-bit IP addresses. The program then attempts to
connect to a server computer with that IP address. Since that server might have
many different programs running on it, with each one listening to the network for
new connections, each program listens on a different port. A port is just a 16-bit
number that identifies a particular service. By convention, requests for web pages
are sent to port 80 unless specified otherwise in the URL.

Once the connection is established, the client program sends an HTTP re-
quest to the web server to request a page. Themost commonHTTP request type
is a GET request, for example:

GET /csinfo/people.html HTTP/1.0

This simple request asks the server to send the page called /csinfo/people.html
back to the client, using version 1.0 of the HTTP protocol specification. After



34 3 Crawls and Feeds

sending a short header, the server sends the contents of that file back to the client.
If the clientwantsmorepages, it can send additional requests; otherwise, the client
closes the connection.

A client can also fetch web pages using POST requests. A POST request is
like a GET request, except that it can send additional request information to the
server. By convention,GET requests are used for retrieving data that already exists
on the server, whereas POST requests are used to tell the server something. A
POST request might be used when you click a button to purchase something or
to edit aweb page.This convention is useful if you are running aweb crawler, since
sending only GET requests helps make sure your crawler does not inadvertently
order a product.

www.cs.umass.edu

www.bbc.co.uk www.cnn.com

www.whitehouse.gov

/index.html

/courses

/news

/index.html

/today

/2005/story.html

/index.html

/2006/09/story.html

/2003/04/story.html/index.html

/news.html

/about.html

crawler.searchengine.com

Fig. 3.2.Crawling the Web. The web crawler connects to web servers to find pages. Pages
may link to other pages on the same server or on different servers.



3.2 Crawling the Web 35

3.2.2 The Web Crawler

Figure 3.2 shows a diagram of the Web from a simple web crawler’s perspective.
The web crawler has two jobs: downloading pages and finding URLs.

The crawler starts with a set of seeds, which are a set of URLs given to it as
parameters. These seeds are added to a URL request queue. The crawler starts
fetching pages from the request queue. Once a page is downloaded, it is parsed
to find link tags that might contain other useful URLs to fetch. If the crawler
finds a new URL that it has not seen before, it is added to the crawler’s request
queue, or frontier. The frontier may be a standard queue, or it may be ordered so
that important pages move to the front of the list. This process continues until
the crawler either runs out of disk space to store pages or runs out of useful links
to add to the request queue.

If a crawler used only a single thread, it would not be very efficient. Notice
that the web crawler spends a lot of its time waiting for responses: it waits for
the DNS server response, then it waits for the connection to the web server to
be acknowledged, and then it waits for the web page data to be sent from the
server. During this waiting time, the CPU of the web crawler machine is idle and
the network connection is unused. To reduce this inefficiency, web crawlers use
threads and fetch hundreds of pages at once.

Fetching hundreds of pages at once is good for the person running the web
crawler, but not necessarily good for the person running the web server on the
other end. Just imagine how the request queue works in practice. When a web
page like www.company.com is fetched, it is parsed and all of the links on that
page are added to the request queue. The crawler will then attempt to fetch all of
those pages at once. If theweb server forwww.company.com is not very powerful, it
might spend all of its time handling requests from the crawler instead of handling
requests from real users. This kind of behavior from web crawlers tends to make
web server administrators very angry.

To avoid this problem, web crawlers use politeness policies. Reasonable web
crawlers do not fetch more than one page at a time from a particular web server.
In addition, web crawlers wait at least a few seconds, and sometimes minutes, be-
tween requests to the same web server. This allows web servers to spend the bulk
of their time processing real user requests. To support this, the request queue is
logically split into a single queue per web server. At any one time, most of these
per-server queues are off-limits for crawling, because the crawler has fetched a
page from that server recently. The crawler is free to read page requests only from
queues that haven’t been accessed within the specified politeness window.



36 3 Crawls and Feeds

Whenusing a politenesswindow, the request queuemust be very large in order
to achieve good performance. Suppose a web crawler can fetch 100 pages each
second, and that its politeness policy dictates that it cannot fetch more than one
page each 30 seconds from a particular web server.Theweb crawler needs to have
URLs from at least 3,000 different web servers in its request queue in order to
achieve high throughput. Since many URLs will come from the same servers, the
request queue needs to have tens of thousands of URLs in it before a crawler can
reach its peak throughput.

User-agent: *
Disallow: /private/
Disallow: /confidential/
Disallow: /other/
Allow: /other/public/

User-agent: FavoredCrawler
Disallow:

Sitemap: http://mysite.com/sitemap.xml.gz

Fig. 3.3. An example robots.txt file

Even crawling a site slowly will anger some web server administrators who ob-
ject to any copying of their data. Web server administrators who feel this way can
store a file called /robots.txt on their web servers. Figure 3.3 contains an ex-
ample robots.txt file. The file is split into blocks of commands that start with a
User-agent: specification. The User-agent: line identifies a crawler, or group
of crawlers, affected by the following rules. Following this line are Allow and
Disallow rules that dictate which resources the crawler is allowed to access. In
the figure, the first block indicates that all crawlers need to ignore resources that
begin with /private/, /confidential/, or /other/, except for those that begin
with /other/public/.The second block indicates that a crawler named Favored-
Crawler gets its own set of rules: it is allowed to copy everything.

The final block of the example is an optional Sitemap: directive, which will be
discussed later in this section.

Figure 3.4 shows an implementation of a crawling thread, using the crawler
building blocks we have seen so far. Assume that the frontier has been initialized



3.2 Crawling the Web 37

procedure C??????T?????(frontier)
while not frontier.done() do

website? frontier.nextSite()
url? website.nextURL()
if website.permitsCrawl(url) then

text? retrieveURL(url)
storeDocument(url, text)
for each url in parse(text) do

frontier.addURL(url)
end for

end if
frontier.releaseSite(website)

end while
end procedure

Fig. 3.4. A simple crawling thread implementation

with a few URLs that act as seeds for the crawl. The crawling thread first retrieves
a website from the frontier. The crawler then identifies the next URL in the web-
site’s queue. In permitsCrawl, the crawler checks to see if theURL is okay to crawl
according to the website’s robots.txt file. If it can be crawled, the crawler uses re-
trieveURL to fetch the document contents. This is the most expensive part of the
loop, and the crawler thread may block here for many seconds. Once the text has
been retrieved, storeDocument stores the document text in a document database
(discussed later in this chapter). The document text is then parsed so that other
URLs can be found. These URLs are added to the frontier, which adds them to
the appropriate website queues. When all this is finished, the website object is
returned to the frontier, which takes care to enforce its politeness policy by not
giving the website to another crawler thread until an appropriate amount of time
has passed. In a real crawler, the timerwould start immediately after the document
was retrieved, since parsing and storing the document could take a long time.

3.2.3 Freshness

Web pages are constantly being added, deleted, and modified. To keep an accu-
rate view of the Web, a web crawler must continually revisit pages it has already
crawled to see if they have changed in order to maintain the freshness of the docu-
ment collection. The opposite of a fresh copy is a stale copy, which means a copy
that no longer reflects the real content of the web page.



38 3 Crawls and Feeds

Client request: HEAD /csinfo/people.html HTTP/1.1
Host: www.cs.umass.edu

Server response:

HTTP/1.1 200 OK
Date: Thu, 03 Apr 2008 05:17:54 GMT
Server: Apache/2.0.52 (CentOS)
Last-Modified: Fri, 04 Jan 2008 15:28:39 GMT
ETag: "239c33-2576-2a2837c0"
Accept-Ranges: bytes
Content-Length: 9590
Connection: close
Content-Type: text/html; charset=ISO-8859-1

Fig. 3.5. An HTTP HEAD request and server response

TheHTTPprotocol has a special request type calledHEADthatmakes it easy
to check for page changes. The HEAD request returns only header information
about the page, but not the page itself. Figure 3.5 contains an example HEAD
request and response. The Last-Modified value indicates the last time the page
content was changed. Notice that the date is also sent along with the response, as
well as in response to a GET request. This allows the web crawler to compare the
date it received from a previous GET request with the Last-Modified value from
a HEAD request.

A HEAD request reduces the cost of checking on a page, but does not elimi-
nate it. It simply is not possible to check every page everyminute.Not only would
that attract more negative reactions from web server administrators, but it would
cause enormous load on the web crawler and the incoming network connection.

Thankfully, most web pages are not updated every few minutes. Some of
them, like news websites, do change frequently. Others, like a person’s home page,
changemuch less often. Evenwithin a page type there canbehuge variations in the
modification rate. For example, some blogs are updatedmany times a day, whereas
others gomonths between updates. It does little good to continuously check sites
that are rarely updated. Therefore, one of the crawler’s jobs is to measure the rate
at which each page changes. Over time, this data can be used to estimate how
frequently each page changes.

Given that aweb crawler can’t update every page immediately as it changes, the
crawler needs to have some metric for measuring crawl freshness. In this chapter,
we’ve used freshness as a general term, but freshness is also the name of a metric.



3.2 Crawling the Web 39

freshness

age

crawl crawl crawlupdates update

Fig. 3.6. Age and freshness of a single page over time

Under thefreshnessmetric, a page isfresh if the crawl has themost recent copy of a
web page, but stale otherwise. Freshness is then the fraction of the crawled pages
that are currently fresh.

Keeping freshness high seems like exactly what you’d want to do, but optimiz-
ing for freshness can have unintended consequences. Suppose that http://www.ex-
ample.com is a popular website that changes its front page slightly every minute.
Unless your crawler continually polls http://www.example.com, you will almost al-
ways have a stale copy of that page. Notice that if you want to optimize for fresh-
ness, the appropriate strategy is to stop crawling this site completely! If it will
never be fresh, it can’t help your freshness value. Instead, you should allocate your
crawler’s resources to pages that change less frequently.

Of course, users will revolt if you decide to optimize your crawler for freshness.
They will look at http://www.example.com and wonder why your indexed copy is
months out of date.

Age is a better metric to use. You can see the difference between age and fresh-
ness in Figure 3.6. In the top part of the figure, you can see that pages become
fresh immediately when they are crawled, but once the page changes, the crawled
page becomes stale. Under the age metric, the page has age 0 until it is changed,
and then its age grows until the page is crawled again.

Suppose we have a page with change frequency ?, meaning that we expect it
to change? times in a one-day period.We can calculate the expected age of a page
t days after it was last crawled:

Age(?, t) =
? t
0

P (page changed at time x)(t? x)dx



40 3 Crawls and Feeds

Fig. 3.7. Expected age of a page with mean change frequency ? = 1/7 (one week)

The (t? x) expression is an age: we assume the page is crawled at time t, but
that it changed at time x. We multiply that by the probability that the page actu-
ally changed at timex. Studies have shown that, on average, web page updates fol-
low the Poisson distribution, meaning that the time until the next update is gov-
erned by an exponential distribution (Cho&Garcia-Molina, 2003).This gives us
a formula to plug into the P (page changed at time x) expression:

Age(?, t) =
? t
0

?e??x(t? x)dx

Figure 3.7 shows the result of plotting this expression for a fixed ? = 1/7,
indicating roughly one change a week. Notice how the expected age starts at zero,
and rises slowly at first. This is because the page is unlikely to have changed in the
first day. As the days go by, the probability that the page has changed increases. By
the end of the week, the expected age of the page is about 2.6 days. This means
that if your crawler crawls each page once aweek, and each page in your collection
has a mean update time of once a week, the pages in your index will be 2.6 days
old on average just before the crawler runs again.

Notice that the second derivative of the Age function is always positive. That
is, the graph is not only increasing, but its rate of increase is always increasing.This
positive second derivative means that the older a page gets, the more it costs you
to not crawl it. Optimizing this metric will never result in the conclusion that
optimizing for freshness does, where sometimes it is economical to not crawl a
page at all.



3.2 Crawling the Web 41

3.2.4 Focused Crawling

Some users would like a search engine that focuses on a specific topic of informa-
tion. For instance, at a website about movies, users might want access to a search
engine that leads tomore information aboutmovies. If built correctly, this type of
vertical search can provide higher accuracy than general search because of the lack
of extraneous information in the document collection. The computational cost
of running a vertical search will also be much less than a full web search, simply
because the collection will be much smaller.

The most accurate way to get web pages for this kind of engine would be to
crawl a full copy of the Web and then throw out all unrelated pages. This strategy
requires a huge amount of disk space and bandwidth, and most of the web pages
will be discarded at the end.

A less expensive approach is focused, or topical, crawling. A focused crawler
attempts to download only those pages that are about a particular topic. Focused
crawlers rely on the fact that pages about a topic tend to have links to other pages
on the same topic. If this were perfectly true, it would be possible to start a crawl at
one on-topic page, then crawl all pages on that topic just by following links from
a single root page. In practice, a number of popular pages for a specific topic are
typically used as seeds.

Focused crawlers require some automatic means for determining whether a
page is about a particular topic. Chapter 9 will introduce text classifiers, which
are tools that can make this kind of distinction. Once a page is downloaded, the
crawler uses the classifier to decide whether the page is on topic. If it is, the page is
kept, and links from thepage are used tofindother related sites.Theanchor text in
the outgoing links is an important clue of topicality. Also, some pages have more
on-topic links than others. As links from a particular web page are visited, the
crawler can keep track of the topicality of the downloaded pages and use this to
determine whether to download other similar pages. Anchor text data and page
link topicality data can be combined together in order to determine which pages
should be crawled next.

3.2.5 Deep Web

Not all parts of the Web are easy for a crawler to navigate. Sites that are difficult
for a crawler to find are collectively referred to as the deep Web (also called the
hidden Web). Some studies have estimated that the deep Web is over a hundred



42 3 Crawls and Feeds

times larger than the traditionally indexed Web, although it is very difficult to
measure this accurately.

Most sites that are a part of the deep Web fall into three broad categories:

• Private sites are intentionally private.Theymay have no incoming links, ormay
require you to log inwith a valid account before using the rest of the site.These
sites generally want to block access from crawlers, although some news pub-
lishers may still want their content indexed by major search engines.

• Form results are sites that can be reached only after entering some data into a
form. For example, websites selling airline tickets typically ask for trip infor-
mation on the site’s entry page. You are shown flight information only after
submitting this trip information. Even though you might want to use a search
engine to find flight timetables, most crawlers will not be able to get through
this form to get to the timetable information.

• Scripted pages are pages that use JavaScript™, Flash®, or another client-side lan-
guage in the web page. If a link is not in the raw HTML source of the web
page, but is instead generated by JavaScript code running on the browser, the
crawlerwill need to execute the JavaScript on the page in order to find the link.
Although this is technically possible, executing JavaScript can slow down the
crawler significantly and adds complexity to the system.

Sometimes people make a distinction between static pages and dynamic pages.
Static pages are files stored on a web server and displayed in a web browser un-
modified, whereas dynamic pages may be the result of code executing on the web
server or the client. Typically it is assumed that static pages are easy to crawl, while
dynamic pages are hard. This is not quite true, however. Many websites have dy-
namically generated web pages that are easy to crawl; wikis are a good example
of this. Other websites have static pages that are impossible to crawl because they
can be accessed only through web forms.

Web administrators of sites with form results and scripted pages often want
their sites to be indexed, unlike the owners of private sites.Of these two categories,
scripted pages are easiest to deal with.The site owner can usuallymodify the pages
slightly so that links are generated by code on the server instead of by code in
the browser. The crawler can also run page JavaScript, or perhaps Flash as well,
although these can take a lot of time.

The most difficult problems come with form results. Usually these sites are
repositories of changing data, and the form submits a query to a database system.
In the case where the database containsmillions of records, the site would need to



3.2 Crawling the Web 43

expose millions of links to a search engine’s crawler. Adding a million links to the
front page of such a site is clearly infeasible. Another option is to let the crawler
guess what to enter into forms, but it is difficult to choose good form input. Even
with good guesses, this approach is unlikely to expose all of the hidden data.

3.2.6 Sitemaps

As you can see from the last two sections, the biggest problems in crawling arise
because site owners cannot adequately tell crawlers about their sites. In section
3.2.3,we sawhowcrawlers have tomake guesses aboutwhenpageswill be updated
because polling is costly. In section 3.2.5, we saw that site owners sometimes have
data that they would like to expose to a search engine, but they can’t because there
is no reasonable place to store the links. Sitemaps solve both of these problems.

<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

<url>
<loc>http://www.company.com/</loc>
<lastmod>2008-01-15</lastmod>
<changefreq>monthly</changefreq>
<priority>0.7</priority>

</url>
<url>

<loc>http://www.company.com/items?item=truck</loc>
<changefreq>weekly</changefreq>

</url>
<url>

<loc>http://www.company.com/items?item=bicycle</loc>
<changefreq>daily</changefreq>

</url>
</urlset>

Fig. 3.8. An example sitemap file

A robots.txt file can contain a reference to a sitemap, like the one shown in
Figure 3.8. A sitemap contains a list of URLs and data about those URLs, such as
modification time and modification frequency.



44 3 Crawls and Feeds

There are threeURL entries shown in the example sitemap. Each one contains
a URL in a loc tag. The changefreq tag indicates how often this resource is likely
to change. The first entry includes a lastmod tag, which indicates the last time
it was changed. The first entry also includes a priority tag with a value of 0.7,
which is higher than the default of 0.5. This tells crawlers that this page is more
important than other pages on this site.

Why would a web server administrator go to the trouble to create a sitemap?
One reason is that it tells search engines about pages it might not otherwise find.
Look at the second and third URLs in the sitemap. Suppose these are two prod-
uct pages. There may not be any links on the website to these pages; instead, the
user may have to use a search form to get to them. A simple web crawler will not
attempt to enter anything into a form (although some advanced crawlers do), and
so these pages would be invisible to search engines. A sitemap allows crawlers to
find this hidden content.

The sitemap also exposes modification times. In the discussion of page fresh-
ness, we mentioned that a crawler usually has to guess when pages are likely to
change. The changefreq tag gives the crawler a hint about when to check a page
again for changes, and the lastmod tag tells the crawler when a page has changed.
This helps reduce the number of requests that the crawler sends to a website with-
out sacrificing page freshness.

3.2.7 Distributed Crawling

For crawling individual websites, a single computer is sufficient. However, crawl-
ing the entire Web requires many computers devoted to crawling. Why would a
single crawling computer not be enough? We will consider three reasons.

One reason to use multiple computers is to put the crawler closer to the sites it
crawls. Long-distance network connections tend to have lower throughput (fewer
bytes copied per second) and higher latency (bytes take longer to cross the net-
work). Decreased throughput and increased latency work together to make each
page request take longer. As throughput drops and latency rises, the crawler has
to open more connections to copy pages at the same rate.

For example, suppose a crawler has a network connection that can transfer
1MB each second. With an average web page size of 20K, it can copy 50 pages
each second. If the sites that are being crawled are close, the data transfer rate
from them may be 1MB a second. However, it can take 80ms for the site to start
sending data, because there is some transmission delay in opening the connection



3.2 Crawling the Web 45

and sending the request. Let’s assume each request takes 100ms (80ms of latency
and20msof data transfer).Multiplying50by100ms,we see that there is 5 seconds
of waiting involved in transferring 50 pages.Thismeans that five connections will
be needed to transfer 50 pages in one second. If the sites are farther away, with an
average throughput of 100K per second and 500ms of latency, then each request
would now take 600ms. Since 50× 600ms = 30 seconds, the crawler would need
to keep 30 connections open to transfer pages at the same rate.

Another reason for multiple crawling computers is to reduce the number of
sites the crawler has to remember. A crawler has to remember all of the URLs it
has already crawled, and all of the URLs that it has queued to crawl. These URLs
must be easy to access, because every page that is crawled contains new links that
need to be added to the crawl queue. Since the crawler’s queue should not contain
duplicates or sites that have already been crawled, each newURLmust be checked
against everything in the queue and everything that has been crawled. The data
structure for this lookup needs to be in RAM; otherwise, the computer’s crawl
speed will be severely limited. Spreading crawling duties among many computers
reduces this bookkeeping load.

Yet another reason is that crawling can use a lot of computing resources, includ-
ingCPUresources for parsing andnetwork bandwidth for crawling pages.Crawl-
ing a large portion of the Web is too much work for a single computer to handle.

A distributed crawler is much like a crawler on a single computer, except in-
stead of a single queue of URLs, there are many queues. The distributed crawler
uses a hash function to assign URLs to crawling computers. When a crawler sees
a new URL, it computes a hash function on that URL to decide which crawl-
ing computer is responsible for it. These URLs are gathered in batches, then sent
periodically to reduce the network overhead of sending a single URL at a time.

The hash function should be computed on just the host part of each URL.
This assigns all the URLs for a particular host to a single crawler. Although this
may promote imbalance since some hosts havemore pages than others, politeness
rules require a time delay between URL fetches to the same host. It is easier to
maintain that kind of delay by using the same crawling computers for allURLs for
the same host. In addition, we would expect that sites from domain.com will have
lots of links to other pages on domain.com. By assigning domain.com to a single
crawl host, weminimize the number ofURLs that need to be exchanged between
crawling computers.



46 3 Crawls and Feeds

3.3 Crawling Documents and Email

Even though the Web is a tremendous information resource, a huge amount of
digital information is not stored on websites. In this section, we will consider in-
formation that youmight find on a normal desktop computer, such as email, word
processing documents, presentations, or spreadsheets. This information can be
searched using a desktop search tool. In companies and organizations, enterprise
search will make use of documents on file servers, or even on employee desktop
computers, in addition to local web pages.

Many of the problems of web crawling change when we look at desktop data.
In web crawling, just finding the data can be a struggle. On a desktop computer,
the interesting data is stored in a file system with familiar semantics. Finding all
the files on a hard disk is not particularly difficult, since file systems have directo-
ries that are easy to discover. In some ways, a file system is like a web server, but
with an automatically generated sitemap.

There are unique challenges in crawling desktop data, however. The first con-
cerns update speed. In desktop search applications, users demand search results
based on the current content of their files. This means, for example, being able to
search for an email the instant it is received, and being able to search for a docu-
ment as soon as it has been saved. Notice that this is a much different expectation
than with web search, where users can tolerate crawling delays of hours or days.
Crawling the file system every second is impractical, but modern file systems can
send change notifications directly to the crawler process so that it can copy new
files immediately. Remote file systems from file servers usually do not provide this
kind of change notification, and so they must be crawled just like a web server.

Disk space is another concern.With a web crawler, we assume that we need to
keep a copy of every document that is found.This is less true on a desktop system,
where the documents are already stored locally, and where users will be unhappy
if a large proportion of the hard disk is taken by the indexer. A desktop crawler
instead may need to read documents into memory and send them directly to the
indexer. We will discuss indexing more in Chapter 5.

Since websites are meant to be viewed with web browsers, most web content
is stored in HTML. On the other hand, each desktop program—the word pro-
cessor, presentation tool, email program, etc.—has its own file format. So, just
finding these files is not enough; eventually they will need to be converted into a
format that the indexer can understand. In section 3.5 we will revisit this conver-
sion issue.



3.4 Document Feeds 47

Finally, and perhaps most importantly, crawling desktop data requires a focus
on data privacy. Desktop systems can have multiple users with different accounts,
and user A should not be able to find emails from user B’s account through the
search feature.This is especially important whenwe consider crawling shared net-
work file systems, as in a corporate network.Thefile access permissions of each file
must be recorded along with the crawled data, and must be kept up-to-date.

3.4 Document Feeds

In generalWeb or desktop crawling, we assume that any document can be created
or modified at any time. However, many documents are published, meaning that
they are created at a fixed time and rarely updated again.News articles, blog posts,
press releases, and email are some of the documents that fit this publishingmodel.
Most information that is time-sensitive is published.

Since each published document has an associated time, published documents
from a single source can be ordered in a sequence called a document feed. A docu-
ment feed is particularly interesting for crawlers, since the crawler can easily find
all the new documents by examining only the end of the feed.

We can distinguish two kinds of document feeds, push and pull. A push feed
alerts the subscriber to new documents. This is like a telephone, which alerts you
to an incoming phone call; you don’t need to continually check the phone to see
if someone is calling. A pull feed requires the subscriber to check periodically for
new documents; this is like checking your mailbox for new mail to arrive. News
feeds from commercial news agencies are often push feeds, but pull feeds are over-
whelmingly popular for free services.We will focus primarily on pull feeds in this
section.

The most common format for pull feeds is called RSS. RSS has at least three
definitions: Really Simple Syndication, RDF Site Summary, or Rich Site Sum-
mary. Not surprisingly, RSS also has a number of slightly incompatible imple-
mentations, and a similar competing format exists called the Atom Syndication
Format. The proliferation of standards is the result of an idea that gained popu-
larity too quickly for developers to agree on a single standard.

Figure 3.9 shows anRSS2.0 feed fromanexample site called http://www.search-
engine-news.org.This feed contains two articles: one is about an upcoming SIGIR
conference, and the other is about a textbook. Notice that each entry contains a
time indicating when it was published. In addition, near the top of the RSS feed
there is an tag named ttl, which means time to live, measured in minutes. This



48 3 Crawls and Feeds

<?xml version="1.0"?>
<rss version="2.0">

<channel>
<title>Search Engine News</title>
<link>http://www.search-engine-news.org/</link>
<description>News about search engines.</description>
<language>en-us</language>
<pubDate>Tue, 19 Jun 2008 05:17:00 GMT</pubDate>
<ttl>60</ttl>

<item>
<title>Upcoming SIGIR Conference</title>
<link>http://www.sigir.org/conference</link>
<description>The annual SIGIR conference is coming!

Mark your calendars and check for cheap
flights.</description>

<pubDate>Tue, 05 Jun 2008 09:50:11 GMT</pubDate>
<guid>http://search-engine-news.org#500</guid>

</item>

<item>
<title>New Search Engine Textbook</title>
<link>http://www.cs.umass.edu/search-book</link>
<description>A new textbook about search engines

will be published soon.</description>
<pubDate>Tue, 05 Jun 2008 09:33:01 GMT</pubDate>
<guid>http://search-engine-news.org#499</guid>

</item>
</channel>

</rss>

Fig. 3.9. An example RSS 2.0 feed



3.5 The Conversion Problem 49

feed states that its contents should be cached only for 60 minutes, and informa-
tion more than an hour old should be considered stale. This gives a crawler an
indication of how often this feed file should be crawled.

RSS feeds are accessed just like a traditional web page, using HTTP GET re-
quests to web servers that host them. Therefore, some of the crawling techniques
we discussed before apply here as well, such as using HTTP HEAD requests to
detect when RSS feeds change.

From a crawling perspective, document feeds have a number of advantages
over traditional pages. Feeds give a natural structure to data; evenmore thanwith
a sitemap, a web feed implies some relationship between the data items. Feeds
are easy to parse and contain detailed time information, like a sitemap, but also
include a description field about each page (and this description field sometimes
contains the entire text of the page referenced in the URL). Most importantly,
like a sitemap, feeds provide a single location to look for new data, instead of hav-
ing to crawl an entire site to find a few new documents.

3.5 The Conversion Problem

Search engines are built to search through text. Unfortunately, text is stored on
computers in hundreds of incompatible file formats. Standard text file formats
include raw text, RTF, HTML, XML, Microsoft Word, ODF (Open Document
Format) and PDF (PortableDocument Format).There are tens of other less com-
mon word processors with their own file formats. But text documents aren’t the
only kind of document that needs to be searched; other kinds of files also contain
important text, such as PowerPoint slides and Excel®spreadsheets. In addition to
all of these formats, people oftenwant to search old documents, whichmeans that
search engines may need to support obsolete file formats. It is not uncommon for
a commercial search engine to support more than a hundred file types.

The most common way to handle a new file format is to use a conversion tool
that converts the document content into a tagged text format such as HTML
or XML. These formats are easy to parse, and they retain some of the important
formatting information (font size, for example). You can see this on any major
web search engine. Search for a PDF document, but then click on the “Cached”
link at the bottom of a search result. You will be taken to the search engine’s view
of the page, which is usually an HTML rendition of the original document. For
some document types, such as PowerPoint, this cached version can be nearly un-
readable. Fortunately, readability isn’t the primary concern of the search engine.



50 3 Crawls and Feeds

The point is to copy this data into the search engine so that it can be indexed and
retrieved. However, translating the data into HTML has an advantage: the user
does not need to have an application that can read the document’s file format in
order to view it. This is critical for obsolete file formats.

Documents could be converted to plain text instead of HTML or XML.
However, doing this would strip the file of important information about head-
ings and font sizes that could be useful to the indexer.Aswewill see later, headings
and bold text tend to contain words that describe the document content well, so
we want to give these words preferential treatment during scoring. Accurate con-
version of formatting information allows the indexer to extract these important
features.

3.5.1 Character Encodings

EvenHTMLfiles are not necessarily compatible with each other because of char-
acter encoding issues. The text that you see on this page is a series of little pictures
we call letters or glyphs. Of course, a computer file is a stream of bits, not a collec-
tion of pictures. A character encoding is a mapping between bits and glyphs. For
English, the basic character encoding that has been around since 1963 is ASCII.
ASCII encodes 128 letters, numbers, special characters, and control characters
in 7 bits, extended with an extra bit for storage in bytes. This scheme is fine for
the English alphabet of 26 letters, but there are many other languages, and some
of those have many more glyphs. The Chinese language, for example, has more
than 40,000 characters, with over 3,000 in common use. For the CJK (Chinese-
Japanese-Korean) family of East Asian languages, this led to the development of a
number of different 2-byte standards. Other languages, such as Hindi or Arabic,
also have a range of different encodings.Note that not all encodings even agree on
English. The EBCDIC encoding used on mainframes, for example, is completely
different than the ASCII encoding used by personal computers.

The computer industry has moved slowly in handling complicated character
sets such as Chinese and Arabic. Until recently, the typical approach was to use
different language-specific encodings, sometimes called code pages. The first 128
values of each encoding are reserved for typical English characters, punctuation,
and numbers. Numbers above 128 are mapped to glyphs in the target language,
from Hebrew to Arabic. However, if you use a different encoding for each lan-
guage, you can’t write in Hebrew and Japanese in the same document. Addition-
ally, the text itself is no longer self-describing. It’s not enough to just store data in
a text file; you must also record what encoding was used.



3.5 The Conversion Problem 51

To solve this mess of encoding issues, Unicode was developed. Unicode is a
single mapping from numbers to glyphs that attempts to include all glyphs in
common use in all known languages. This solves the problem of using multiple
languages in a single file. Unfortunately, it does not fully solve the problems of bi-
nary encodings, because Unicode is a mapping between numbers and glyphs, not
bits and glyphs. It turns out that there are many ways to translate Unicode num-
bers to glyphs! Some of themost popular includeUTF-8,UTF-16,UTF-32, and
UCS-2 (which is deprecated).

The proliferation of encodings comes from a need for compatibility and to
save space. Encoding English text in UTF-8 is identical to the ASCII encod-
ing. Each ASCII letter requires just one byte. However, some traditional Chinese
characters can require as many as 4 bytes.The trade-off for compactness forWest-
ern languages is that each character requires a variable number of bytes, which
makes it difficult to quickly compute the number of characters in a string or to
jump to a random location in a string. By contrast, UTF-32 (also known asUCS-
4) uses exactly 4 bytes for every character. Jumping to the twentieth character in
a UTF-32 string is easy: just jump to the eightieth byte and start reading. Un-
fortunately, UTF-32 strings are incompatible with all old ASCII software, and
UTF-32 files require four times as much space as UTF-8. Because of this, many
applications use UTF-32 as their internal text encoding (where random access is
important), but use UTF-8 to store text on disk.

Decimal Hexadecimal Encoding
0–127 0–7F 0xxxxxxx
128–2047 80–7FF 110xxxxx 10xxxxxx
2048–55295 800–D7FF 1110xxxx 10xxxxxx 10xxxxxx
55296–57343 D800–DFFF Undefined
57344–65535 E000–FFFF 1110xxxx 10xxxxxx 10xxxxxx
65536–1114111 10000–10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

Table 3.1. UTF-8 encoding

Table 3.1 shows an encoding table for UTF-8. The left columns represent
ranges of decimal values, and the rightmost column shows how these values are
encoded in binary. The x characters represent binary digits. For example, the
Greek letter pi (?) is Unicode symbol number 960. In binary, that number is
00000011 11000000 (3C0 in hexadecimal). The second row of the table tells us



52 3 Crawls and Feeds

that this letter will require 2 bytes to encode in UTF-8. The high 5 bits of the
character go in the first byte, and the next 6 bits go in the second byte. The final
encoding is 11001111 10000000 (CF80 in hexadecimal). The bold binary digits
are the same as the digits from the table, while the x letters from the table have
been filled in by binary digits from the Unicode number.

3.6 Storing the Documents

After documents have been converted to some common format, they need to be
stored in preparation for indexing. The simplest document storage is no docu-
ment storage, and for some applications this is preferable. In desktop search, for
example, the documents are already stored in the file system and do not need to be
copied elsewhere. As the crawling process runs, it can send converted documents
immediately to an indexing process. By not storing the intermediate converted
documents, desktop search systems can save disk space and improve indexing la-
tency.

Most other kinds of search engines need to store documents somewhere. Fast
access to the document text is required in order to build document snippets2 for
each search result.These snippets of text give the user an idea of what is inside the
retrieved document without actually needing to click on a link.

Even if snippets are not necessary, there are other reasons to keep a copy of
each document. Crawling for documents can be expensive in terms of both CPU
and network load. It makes sense to keep copies of the documents around instead
of trying to fetch them again the next time you want to build an index. Keep-
ing old documents allows you to use HEAD requests in your crawler to save on
bandwidth, or to crawl only a subset of the pages in your index.

Finally, document storage systems can be a starting point for information ex-
traction (described in Chapter 4). The most pervasive kind of information ex-
traction happens in web search engines, which extract anchor text from links to
store with target web documents. Other kinds of extraction are possible, such as
identifying names of people or places in documents. Notice that if information
extraction is used in the search application, the document storage system should
support modification of the document data.

Wenowdiscuss someof the basic requirements for a document storage system,
including random access, compression, and updating, and consider the relative

2 We discuss snippet generation in Chapter 6.



3.6 Storing the Documents 53

benefits of using a database systemor a customized storage system such asGoogle’s
BigTable.

3.6.1 Using a Database System

If youhaveused a relational database before, youmight be thinking that a database
would be a good place to store document data. For many applications, in fact, a
database is an excellent place to store documents. A database takes care of the
difficult details of storing small pieces of data, such as web pages, and makes it
easy to update them later. Most databases also run as a network server, so that the
documents are easily available on the network. This could support, for example,
a single computer serving documents for snippets while many other computers
handle queries. Databases also tend to comewith useful import and analysis tools
that can make it easier to manage the document collection.

Many companies that run web search engines are reluctant to talk about their
internal technologies. However, it appears that few, if any, of the major search
engines use conventional relational databases to store documents. One problem
is the sheer volume of document data, which can overwhelm traditional database
systems. Database vendors also tend to expect that database servers will use the
most expensive disk systems, which is impractical given the collection size. We
discuss an alternative to a relational database at the end of this section that ad-
dresses some of these concerns.

3.6.2 Random Access

To retrieve documents quickly in order to compute a snippet for a search result,
the document store needs to support randomaccess.Compared to a full relational
database, however, only a relatively simple lookup criterion is needed. We want a
data store such that we can request the content of a document based on its URL.

The easiest way to handle this kind of lookup is with hashing. Using a hash
function on the URL gives us a number we can use to find the data. For small
installations, the hash function can tell us which file contains the document. For
larger installations, the hash function tells uswhich server contains the document.
Once the document location has been narrowed down to a single file, a B-Tree or
sorted data structure can be used to find the offset of the document data within
the file.



54 3 Crawls and Feeds

3.6.3 Compression and Large Files

Regardless of whether the application requires random access to documents, the
document storage system should make use of large files and compression.

Even a document that seems long to a person is small by modern computer
standards. For example, this chapter is approximately 10,000 words, and those
words require about 70K of disk space to store.That is far bigger than the average
web page, but amodern hard disk can transfer 70K of data in about amillisecond.
However, the hard disk might require 10 milliseconds to seek to that file in order
to start reading. This is why storing each document in its own file is not a very
good idea; reading these small files requires a substantial overhead to open them.
A better solution is to store many documents in a single file, and for that file to be
large enough that transferring thefile contents takesmuchmore time than seeking
to the beginning. A good size choice might be in the hundreds of megabytes. By
storing documents close together, the indexer can spend most of its time reading
data instead of seeking for it.

TheGalago search engine includes parsers for three compound document for-
mats: ARC, TREC Text, and TREC Web. In each format, many text documents
are stored in the same file, with short regions of document metadata separating
the documents. Figure 3.10 shows an example of the TREC Web format. Notice
that each document block begins with a <DOC> tag and ends with a </DOC> tag.
At the beginning of the document, the <DOCHDR> tag marks a section containing
the information about the page request, such as its URL, the date it was crawled,
and the HTTP headers returned by the web server. Each document record also
contains a <DOCNO> field that includes a unique identifier for the document.

Even though large files make sense for data transfer from disk, reducing the
total storage requirements for document collections has obvious advantages. For-
tunately, text written by people is highly redundant. For instance, the letter q is al-
most always followed by the letter u. Shannon (1951) showed that native English
speakers are able to guess the next letter of a passage of English text with 69% ac-
curacy. HTML andXML tags are evenmore redundant.Compression techniques
exploit this redundancy to make files smaller without losing any of the content.
We will cover compression as it is used for document indexing in Chapter 5,
in part because compression for indexing is rather specialized. While research
continues into text compression, popular algorithms like DEFLATE (Deutsch,
1996) and LZW (Welch, 1984) can compress HTML and XML text by 80%.
This space savings reduces the cost of storing a lot of documents, and also reduces



3.6 Storing the Documents 55

<DOC>
<DOCNO>WTX001-B01-10</DOCNO>
<DOCHDR>
http://www.example.com/test.html 204.244.59.33 19970101013145 text/html 440
HTTP/1.0 200 OK
Date: Wed, 01 Jan 1997 01:21:13 GMT
Server: Apache/1.0.3
Content-type: text/html
Content-length: 270
Last-modified: Mon, 25 Nov 1996 05:31:24 GMT
</DOCHDR>
<HTML>
<TITLE>Tropical Fish Store</TITLE>
Coming soon!
</HTML>
</DOC>
<DOC>
<DOCNO>WTX001-B01-109</DOCNO>
<DOCHDR>
http://www.example.com/fish.html 204.244.59.33 19970101013149 text/html 440
HTTP/1.0 200 OK
Date: Wed, 01 Jan 1997 01:21:19 GMT
Server: Apache/1.0.3
Content-type: text/html
Content-length: 270
Last-modified: Mon, 25 Nov 1996 05:31:24 GMT
</DOCHDR>
<HTML>
<TITLE>Fish Information</TITLE>
This page will soon contain interesting
information about tropical fish.
</HTML>
</DOC>

Fig. 3.10. An example of text in the TREC Web compound document format



56 3 Crawls and Feeds

the amount of time it takes to read a document from the disk since there are fewer
bytes to read.

Compression works best with large blocks of data, which makes it a good fit
for big files with many documents in them. However, it is not necessarily a good
idea to compress the entire file as a single block. Most compression methods do
not allow random access, so each block can only be decompressed sequentially. If
youwant random access to the data, it is better to consider compressing in smaller
blocks, perhaps one block per document, or one block for a few documents. Small
blocks reduce compression ratios (the amount of space saved) but improve re-
quest latency.

3.6.4 Update

As new versions of documents come in from the crawler, it makes sense to update
the document store.The alternative is to create an entirely new document store by
merging the new, changed documents from the crawler with document data from
the old document store for documents that did not change. If the document data
does not change very much, this merging process will be much more expensive
than updating the data in place.

<a href="http://example.com" >Example website</a>

Fig. 3.11. An example link with anchor text

Another important reason to support update is to handle anchor text. Fig-
ure 3.11 shows an example of anchor text in an HTML link tag. The HTML
code in the figure will render in the web browser as a link, with the text Example
website that, when clicked, will direct the user to http://example.com. Anchor text
is an important feature because it provides a concise summary of what the target
page is about. If the link comes from a different website, we may also believe that
the summary is unbiased, which also helps us rank documents (see Chapters 4
and 7).

Collecting anchor text properly is difficult because the anchor text needs to
be associated with the target page. A simple way to approach this is to use a data
store that supports update.When a document is found that contains anchor text,
we find the record for the target page and update the anchor text portion of the
record.When it is time to index the document, the anchor text is all together and
ready for indexing.



3.6 Storing the Documents 57

3.6.5 BigTable

Although a database can perform the duties of a document data store, the very
largest document collectionsdemandcustomdocument storage systems.BigTable
is themostwell knownof these systems (Chang et al., 2006). BigTable is aworking
system in use internally at Google, although at least two open source projects are
taking a similar approach. In the next few paragraphs, wewill look at the BigTable
architecture to see how the problem of document storage influenced its design.

BigTable is a distributed database system originally built for the task of storing
web pages. A BigTable instance really is a big table; it can be over a petabyte in
size, but each database contains only one table. The table is split into small pieces,
called tablets, which are served by thousands of machines (Figure 3.12).

logical table

tablets

Fig. 3.12. BigTable stores data in a single logical table, which is split into many smaller
tablets

If you are familiar with relational databases, you will have encountered SQL
(Structured Query Language). SQL allows users to write complex and computa-
tionally expensive queries, and one of the tasks of the database system is to opti-
mize the processing of these queries tomake themas fast as possible. Because some
of these queries could take a very long time to complete, a large relational database
requires a complex locking system to ensure that the many users of the database
do not corrupt it by reading or writing data simultaneously. Isolating users from
each other is a difficult job, and many papers and books have been written about
how to do it well.



58 3 Crawls and Feeds

The BigTable approach is quite different. There is no query language, and
therefore no complex queries, and it includes only row-level transactions, which
would be considered rather simple by relational database standards.However, the
simplicity of the model allows BigTable to scale up to very large database sizes
while using inexpensive computers, even though they may be prone to failure.

Most of the engineering in BigTable involves failure recovery. The tablets,
which are the small sections of the table, are stored in a replicated file system
that is accessible by all BigTable tablet servers. Any changes to a BigTable tablet
are recorded to a transaction log, which is also stored in a shared file system. If
any tablet server crashes, another server can immediately read the tablet data and
transaction log from the file system and take over.

Most relational databases store their data in files that are constantly modified.
In contrast, BigTable stores its data in immutable (unchangeable) files. Once file
data is written to a BigTable file, it is never changed. This also helps in failure
recovery. In relational database systems, failure recovery requires a complex series
of operations to make sure that files were not corrupted because only some of
the outstanding writes completed before the computer crashed. In BigTable, a file
is either incomplete (in which case it can be thrown away and re-created from
other BigTable files and the transaction log), or it is complete and therefore is not
corrupt. To allow for table updates, the newest data is stored in RAM, whereas
older data is stored in a series of files. Periodically the files are merged together to
reduce the total number of disk files.

www.example.com

text
anchor:other.com

anchor:null.com

title

document text example click here example site

Fig. 3.13. A BigTable row

BigTables are logically organized by rows (Figure 3.13). In the figure, the row
stores the data for a single web page. The URL, www.example.com, is the row key,
which can be used to find this row.The rowhasmany columns, eachwith a unique
name. Each column can have many different timestamps, although that is not
shown in the figure. The combination of a row key, a column key, and a times-



3.6 Storing the Documents 59

tamp point to a single cell in the row. The cell holds a series of bytes, which might
be a number, a string, or some other kind of data.

In the figure, notice that there is a text column for the full text of the docu-
ment as well as a title column, which makes it easy to quickly find the document
title without parsing the full document text. There are two columns for anchor
text. One, called anchor:other.com, includes anchor text from a link from the site
other.com to example.com; the text of the link is “example”, as shown in the cell.
The anchor:null.comdescribes a link from null.com to example.comwith anchor text
“click here”. Both of these columns are in the anchor column group. Other columns
could be added to this column group to add information about more links.

BigTable can have a huge number of columns per row, and while all rows have
the same column groups, not all rows have the same columns. This is a major de-
parture from traditional database systems, but this flexibility is important, in part
because of the lack of tables. In a relational database system, the anchor columns
would be stored in one table and the document text in another. Because BigTable
has just one table, all the anchor information needs to be packed into a single
record. With all the anchor data stored together, only a single disk read is neces-
sary to read all of the document data. In a two-table relational database, at least
two reads would be necessary to retrieve this data.

Rows are partitioned into tablets based on their row keys. For instance, all
URLsbeginningwith a could be located inone tablet,while all those startingwith
b could be in another tablet. Using this kind of range-based partitioning makes
it easy for a client of BigTable to determine which server is serving each row. To
look up a particular row, the client consults a list of row key ranges to determine
which tablet would hold the desired row.The client then contacts the appropriate
tablet server to fetch the row. The row key ranges are cached in the client, so that
most of the network traffic is between clients and tablet servers.

BigTable’s architecture is designed for speed and scale through massive num-
bers of servers, and for economyby using inexpensive computers that are expected
to fail. In order to achieve these goals, BigTable sacrifices some key relational
database features, such as a complex query language andmultiple-table databases.
However, this architecture is well suited for the task of storing and finding web
pages, where the primary task is efficient lookups and updates on individual rows.



60 3 Crawls and Feeds

3.7 Detecting Duplicates

Duplicate and near-duplicate documents occur inmany situations.Making copies
and creating new versions of documents is a constant activity in offices, and keep-
ing track of these is an important part of information management. On the Web,
however, the situation ismore extreme. In addition to thenormal sources of dupli-
cation, plagiarism and spam are common, and the use of multiple URLs to point
to the same web page and mirror sites can cause a crawler to generate large num-
bers of duplicate pages. Studies have shown that about 30% of the web pages in a
large crawl are exact or near duplicates of pages in the other 70% (e.g., Fetterly et
al., 2003).

Documents with very similar content generally provide little or no new infor-
mation to the user, but consume significant resources during crawling, indexing,
and search. In response to this problem, algorithms for detecting duplicate doc-
uments have been developed so that they can be removed or treated as a group
during indexing and ranking.

Detecting exact duplicates is a relatively simple task that can be done using
checksumming techniques. A checksum is a value that is computed based on the
content of the document. The most straightforward checksum is a sum of the
bytes in the document file. For example, the checksum for a file containing the
text “Tropical fish” would be computed as follows (in hex):

T r o p i c a l f i s h Sum
54 72 6F 70 69 63 61 6C 20 66 69 73 68 508

Any document file containing the same text would have the same checksum. Of
course, any document file containing text that happened to have the same check-
sum would also be treated as a duplicate. A file containing the same characters
in a different order would have the same checksum, for example. More sophis-
ticated functions, such as a cyclic redundancy check (CRC), have been developed
that consider the positions of the bytes.

The detection of near-duplicate documents is more difficult. Even defining a
near-duplicate is challenging. Web pages, for example, could have the same text
content but differ in the advertisements, dates, or formatting. Other pages could
have small differences in their content from revisions or updates. In general, a
near-duplicate is defined using a threshold value for some similarity measure be-
tween pairs of documents. For example, a document D1 could be defined as a
near-duplicate of documentD2 if more than 90% of the words in the documents
were the same.



3.7 Detecting Duplicates 61

There are two scenarios for near-duplicate detection. One is the search sce-
nario, where the goal is to find near-duplicates of a given documentD. This, like
all search problems, conceptually involves the comparison of the query document
to all other documents. For a collection containingN documents, the number of
comparisons required will beO(N). The other scenario, discovery, involves find-
ing all pairs of near-duplicate documents in the collection. This process requires
O(N2) comparisons. Although information retrieval techniques that measure
similarity using word-based representations of documents have been shown to
be effective for identifying near-duplicates in the search scenario, the computa-
tional requirements of the discovery scenario have meant that new techniques
have been developed for deriving compact representations of documents. These
compact representations are known as fingerprints.

The basic process of generating fingerprints is as follows:

1. The document is parsed into words. Non-word content, such as punctuation,
HTML tags, and additional whitespace, is removed (see section 4.3).

2. The words are grouped into contiguous n-grams for some n.These are usually
overlapping sequences of words (see section 4.3.5), although some techniques
use non-overlapping sequences.

3. Some of the n-grams are selected to represent the document.
4. The selected n-grams are hashed to improve retrieval efficiency and further

reduce the size of the representation.
5. The hash values are stored, typically in an inverted index.

There are a number of fingerprinting algorithms that use this general approach,
and they differmainly in how subsets of the n-grams are selected. Selecting a fixed
number of n-grams at random does not lead to good performance in terms of
finding near-duplicates. Consider twonear-identical documents,D1 andD2.The
fingerprints generated from n-grams selected randomly from document D1 are
unlikely to have a high overlap with the fingerprints generated from a different
set of n-grams selected randomly from D2. A more effective technique uses pre-
specified combinations of characters, and selects n-grams that begin with those
characters. Another popular technique, called 0 mod p, is to select all n-grams
whose hash valuemodulo p is zero, where p is a parameter.

Figure 3.14 illustrates the fingerprinting process using overlapping 3-grams,
hypothetical hash values, and the 0 mod p selection method with a p value of 4.
Note that after the selection process, the document (or sentence in this case) is
represented by fingerprints for the n-grams “fish include fish”, “found in tropical”,



62 3 Crawls and Feeds

Tropical fish include fish found in tropical environments around the world, 

including both freshwater and salt water species. 

                                                       (a) Original text 

 

tropical fish include, fish include fish, include fish found, fish found in, found in 

tropical, in tropical environments, tropical environments around, environments 

around the, around the world, the world including, world including both, including 

both freshwater, both freshwater and, freshwater and salt, and salt water, salt 

water species 

                                                         (b) 3-grams 

 

938  664  463  822  492  798  78  969  143  236  913  908  694  553  870  779 

                                                      (c) Hash values 

 

                                                      664  492  236  908 

                                      (d) Selected hash values using 0 mod 4 

Fig. 3.14. Example of fingerprinting process

“theworld including”, and “including both freshwater”. In large-scale applications,
such as finding near-duplicates on theWeb, the n-grams are typically 5–10 words
long and the hash values are 64 bits.3

Near-duplicate documents are foundby comparing the fingerprints that repre-
sent them. Near-duplicate pairs are defined by the number of shared fingerprints
or the ratio of shared fingerprints to the total number of fingerprints used to rep-
resent the pair of documents. Fingerprints do not capture all of the information
in the document, however, and consequently this leads to errors in the detection
of near-duplicates. Appropriate selection techniques can reduce these errors, but
not eliminate them. As we mentioned, evaluations have shown that comparing
word-based representations using a similarity measure such as the cosine correla-
tion (see section 7.1.2) is generally significantlymore effective than fingerprinting
methods for finding near-duplicates. The problem with these methods is their ef-
ficiency.

3 The hash values are usually generated using Rabin fingerprinting (Broder et al., 1997),
named after the Israeli computer scientist Michael Rabin.



3.8 Removing Noise 63

Arecently developedfingerprinting technique called simhash (Charikar, 2002)
combines the advantages of the word-based similarity measures with the effi-
ciency of fingerprints based on hashing. It has the unusual property for a hashing
function that similar documents have similar hash values.More precisely, the sim-
ilarity of two pages as measured by the cosine correlationmeasure is proportional
to the number of bits that are the same in the fingerprints generated by simhash.

The procedure for calculating a simhash fingerprint is as follows:

1. Process the document into a set of features with associated weights. We will
assume the simple case where the features are words weighted by their fre-
quency. Other weighting schemes are discussed in Chapter 7.

2. Generate a hash value with b bits (the desired size of the fingerprint) for each
word. The hash value should be unique for each word.

3. In b-dimensional vector V , update the components of the vector by adding
the weight for a word to every component for which the corresponding bit in
the word’s hash value is 1, and subtracting the weight if the value is 0.

4. After all words have been processed, generate a b-bit fingerprint by setting the
ith bit to 1 if the ith component of V is positive, or 0 otherwise.

Figure 3.15 shows an example of this process for an 8-bit fingerprint. Note
that common words (stopwords) are removed as part of the text processing. In
practice,much larger values of b are used.Henzinger (2006) describes a large-scale
Web-based evaluation where the fingerprints had 384 bits. A web page is defined
as a near-duplicate of another page if the simhash fingerprints agree onmore than
372 bits. This study showed significant effectiveness advantages for the simhash
approach compared to fingerprints based on n-grams.

3.8 Removing Noise

Many web pages contain text, links, and pictures that are not directly related to
themain content of the page. For example, Figure 3.16 shows aweb page contain-
ing a news story. The main content of the page (the story) is outlined in black.
This content block takes up less than 20% of the display area of the page, and the
rest is made up of banners, advertisements, images, general navigation links, ser-
vices (such as search and alerts), and miscellaneous information, such as copy-
right. From the perspective of the search engine, this additional material in the
web page is mostly noise that could negatively affect the ranking of the page. A
major component of the representation of a page used in a search engine is based



64 3 Crawls and Feeds

Tropical fish include fish found in tropical environments around the world, 

including both freshwater and salt water species. 

                                                       (a) Original text 

 

tropical 2  fish 2  include 1  found 1  environments 1  around 1  world 1   

including 1  both 1  freshwater 1  salt 1  water 1  species 1 

                                                   (b) Words with weights 

 

tropical   01100001 fish 10101011 include 11100110

found 00011110 environments 00101101 around 10001011

world 00101010 including 11000000 both 10101110

freshwater 00111111 salt 10110101 water 00100101

species 11101110  

                                                      (c) 8 bit hash values 

 

                                             1  !5  9  !9  3  1  3  3 

                                      (d) Vector V formed by summing weights 
 

                                              1  0  1  0  1  1  1  1 

                                          (e) 8-bit fingerprint formed from V 

Fig. 3.15. Example of simhash fingerprinting process

on word counts, and the presence of a large number of words unrelated to the
main topic can be a problem. For this reason, techniques have been developed to
detect the content blocks in a web page and either ignore the other material or
reduce its importance in the indexing process.

Finn et al. (2001) describe a relatively simple technique based on the obser-
vation that there are less HTML tags in the text of the main content of typical
web pages than there is in the additional material. Figure 3.17 (also known as a
document slope curve) shows the cumulative distribution of tags in the example
web page from Figure 3.16, as a function of the total number of tokens (words or
other non-tag strings) in the page.Themain text content of the page corresponds
to the “plateau” in the middle of the distribution. This flat area is relatively small
because of the large amount of formatting and presentation information in the
HTML source for the page.



3.8 Removing Noise 65

Content 

block

Fig. 3.16. Main content block in a web page

One way to detect the largest flat area of the distribution is to represent a web
page as a sequence of bits, where bn = 1 indicates that the nth token is a tag, and
bn = 0 otherwise. Certain tags that are mostly used to format text, such as font
changes, headings, and table tags, are ignored (i.e., are represented by a 0 bit).The
detection of the main content can then be viewed as an optimization problem
where we find values of i and j to maximize both the number of tags below i and
above j and the number of non-tag tokens between i and j. This corresponds to
maximizing the corresponding objective function:

i?1?
n=0

bn +

j?
n=i

(1? bn) +
N?1?

n=j+1

bn



66 3 Crawls and Feeds

0

100

200

300

400

500

600

700

800

900

1000

0 500 1000 1500 2000 2500 3000 3500

Tag count

Token count

Text area

Fig. 3.17. Tag counts used to identify text blocks in a web page

whereN is the number of tokens in the page.This can be done simply by scanning
the possible values for i and j and computing the objective function. Note that
this procedure will only work when the proportion of text tokens in the non-
content section is lower than the proportion of tags, which is not the case for the
web page in Figure 3.17. Pinto et al. (2002) modified this approach to use a text
window to search for low-slope sections of the document slope curve.

The structure of the web page can also be used more directly to identify the
content blocks in the page. To display a web page using a browser, an HTML
parser interprets the structure of the page specified using the tags, and creates a
Document Object Model (DOM) representation. The tree-like structure repre-
sented by the DOM can be used to identify the major components of the web
page. Figure 3.18 shows part of the DOM structure4 for the example web page in
Figure 3.16.Thepart of the structure that contains the text of the story is indicated
by the comment cnnArticleContent. Gupta et al. (2003) describe an approach that

4 This was generated using the DOM Inspector tool in the Firefox browser.



3.8 Removing Noise 67

navigates the DOM tree recursively, using a variety of filtering techniques to re-
move andmodify nodes in the tree and leave only content.HTML elements such
as images and scripts are removed by simple filters. More complex filters remove
advertisements, lists of links, and tables that do not have “substantive” content.

 

Fig. 3.18. Part of the DOM structure for the example web page

The DOM structure provides useful information about the components of a
web page, but it is complex and is a mixture of logical and layout components. In
Figure 3.18, for example, the content of the article is buried in a table cell (TD tag)
in a row (TR tag) of an HTML table (TABLE tag). The table is being used in this
case to specify layout rather than semantically related data. Another approach to



68 3 Crawls and Feeds

identifying the content blocks in a page focuses on the layout and presentation of
the web page. In other words, visual features—such as the position of the block,
the size of the font used, the background and font colors, and the presence of
separators (such as lines and spaces)—are used to define blocks of information
that would be apparent to the user in the displayed web page. Yu et al. (2003)
describe an algorithm that constructs a hierarchy of visual blocks from theDOM
tree and visual features.

The first algorithm we discussed, based on the distribution of tags, is quite
effective forweb pageswith a single content block. Algorithms that use theDOM
structure and visual analysis can deal with pages that may have several content
blocks. In the case where there are several content blocks, the relative importance
of each block can be used by the indexing process to produce a more effective
representation. One approach to judging the importance of the blocks in a web
page is to train a classifier that will assign an importance category based on visual
and content features (R. Song et al., 2004).

References and Further Reading

Cho and Garcia-Molina (2002, 2003) wrote a series of influential papers on web
crawler design. Our discussion of page refresh policies is based heavily on Cho
andGarcia-Molina (2003), and section 3.2.7 draws fromCho andGarcia-Molina
(2002).

There aremany open sourceweb crawlers.TheHeritrix crawler,5 developed for
the Internet Archive project, is a capable and scalable example. The system is de-
veloped inmodules that are highly configurable at runtime,making it particularly
suitable for experimentation.

Focused crawling attracted much attention in the early days of web search.
Menczer and Belew (1998) and Chakrabarti et al. (1999) wrote two of the most
influential papers.Menczer and Belew (1998) envision a focused crawler made of
autonomous software agents, principally for a single user. The user enters a list of
both URLs and keywords. The agent then attempts to find web pages that would
be useful to the user, and the user can rate those pages to give feedback to the
system.Chakrabarti et al. (1999) focus on crawling for specialized topical indexes.
Their crawler uses a classifier to determine the topicality of crawled pages, as well
as a distiller, which judges the quality of a page as a source of links to other topical

5 http://crawler.archive.org



3.8 Removing Noise 69

pages.They evaluate their system against a traditional, unfocused crawler to show
that an unfocused crawler seeded with topical links is not sufficient to achieve a
topical crawl.The broad link structure of theWeb causes the unfocused crawler to
quickly drift to other topics, while the focused crawler successfully stays on topic.

The Unicode specification is an incredibly detailed work, covering tens of
thousands of characters (Unicode Consortium, 2006). Because of the nature of
some non-Western scripts, many glyphs are formed from grouping a number of
Unicode characters together, so the specification must detail not just what the
characters are, but how they can be joined together. Characters are still being
added to Unicode periodically.

Bergman (2001) is an extensive study of the deepWeb. Even though this study
is old byweb standards, it showshow sampling through search engines canbeused
to help estimate the amount of unindexed content on the Web. This study esti-
mated that 550 billion web pages existed in the deep Web, compared to 1 billion
in the accessible Web. He et al. (2007) describe a more recent survey that shows
that the deep Web has continued to expand rapidly in recent years. An example
of a technique for generating searchable representations of deep Web databases,
called query probing, is described by Ipeirotis and Gravano (2004).

Sitemaps, robots.txt files, RSS feeds, andAtom feeds each have their own spec-
ifications, which are available on the Web.6 These formats show that successful
web standards are often quite simple.

As we mentioned, database systems can be used to store documents from a
web crawl for some applications. Our discussion of database systems was, how-
ever, limited mostly to a comparison with BigTable. There are a number of text-
books, such as Garcia-Molina et al. (2008), that provide much more informa-
tion on how databases work, including details about important features such as
query languages, locking, and recovery. BigTable, whichwe referenced frequently,
was described in Chang et al. (2006). Other large Internet companies have built
their own database systems with similar goals: large-scale distribution and high
throughput, butwithout an expressive query languageordetailed transaction sup-
port. The Dynamo system from Amazon has low latency guarantees (DeCandia
et al., 2007), and Yahoo! uses their UDB system to store large datasets (Baeza-
Yates & Ramakrishnan, 2008).
6 http://www.sitemaps.org
http://www.robotstxt.org
http://www.rssboard.org/rss-specification
http://www.rfc-editor.org/rfc/rfc5023.txt



70 3 Crawls and Feeds

We mentioned DEFLATE (Deutsch, 1996) and LZW (Welch, 1984) as spe-
cific document compression algorithms in the text. DEFLATE is the basis for the
popular Zip, gzip, and zlib compression tools. LZW is the basis of the Unix com-
press command, and is also found in file formats such as GIF, PostScript, and
PDF. The text by Witten et al. (1999) provides detailed discussions about text
and image compression algorithms.

Hoad and Zobel (2003) provide both a review of fingerprinting techniques
and a comparison toword-based similaritymeasures for near-duplicate detection.
Their evaluation focused on finding versions of documents and plagiarized docu-
ments. Bernstein andZobel (2006) describe a technique for using full fingerprint-
ing (no selection) for the task of finding co-derivatives, which are documents de-
rived from the same source. Bernstein and Zobel (2005) examined the impact of
duplication on evaluations of retrieval effectiveness.They showed that about 15%
of the relevant documents for one of the TREC tracks were redundant, which
could significantly affect the impact of the results from a user’s perspective.

Henzinger (2006) describes a large-scale evaluation of near-duplicate detec-
tion on the Web. The two techniques compared were a version of Broder’s “shin-
gling” algorithm (Broder et al., 1997; Fetterly et al., 2003) and simhash (Charikar,
2002).Henzinger’s study,whichused1.6 billionpages, showed that neithermeth-
od worked well for detecting redundant documents on the same site because of
the frequent use of “boilerplate” text that makes different pages look similar.
For pages on different sites, the simhash algorithm achieved a precision of 50%
(meaning that of those pages that were declared “near-duplicate” based on the
similarity threshold, 50% were correct), whereas the Broder algorithm produced
a precision of 38%.

Anumber of papers have beenwritten about techniques for extracting content
from web pages. Yu et al. (2003) and Gupta et al. (2003) are good sources for
references to these papers.

Exercises

3.1. Suppose you have two collections of documents.The smaller collection is full
of useful, accurate, high-quality information.The larger collection contains a few
high-quality documents, but also contains lower-quality text that is old, out-of-
date, or poorly written. What are some reasons for building a search engine for
only the small collection? What are some reasons for building a search engine
that covers both collections?



3.8 Removing Noise 71

3.2. Suppose you have a network connection that can transfer 10MB per second.
If each web page is 10K and requires 500 milliseconds to transfer, how many
threads does your web crawler need to fully utilize the network connection? If
your crawler needs to wait 10 seconds between requests to the same web server,
what is the minimum number of distinct web servers the system needs to contact
each minute to keep the network connection fully utilized?

3.3. What is the advantage of usingHEADrequests instead ofGET requests dur-
ing crawling? When would a crawler use a GET request instead of a HEAD re-
quest?

3.4. Why do crawlers not use POST requests?

3.5. Name the three types of sites mentioned in the chapter that compose the
deep Web.

3.6. Howwould youdesign a system to automatically enter data intoweb forms in
order to crawl deep Web pages? What measures would you use to make sure your
crawler’s actions were not destructive (for instance, so that it doesn’t add random
blog comments).

3.7. Write a program that can create a valid sitemap based on the contents of a
directory on your computer’s hard disk. Assume that the files are accessible from
a website at the URL http://www.example.com. For instance, if there is a file in
your directory called homework.pdf, this would be available at http://www.exam-
ple.com/homework.pdf. Use the real modification date on the file as the last modi-
fied time in the sitemap, and to help estimate the change frequency.

3.8. Suppose that, in an effort to crawl web pages faster, you set up two crawl-
ing machines with different starting seed URLs. Is this an effective strategy for
distributed crawling? Why or why not?

3.9. Write a simple single-threadedweb crawler. Starting froma single inputURL
(perhaps a professor’s web page), the crawler should download a page and then
wait at least five seconds before downloading the next page. Your program should
find other pages to crawl by parsing link tags found in previously crawled docu-
ments.

3.10. UTF-16 is used in Java and Windows®. Compare it to UTF-8.

3.11. How does BigTable handle hardware failure?



72 3 Crawls and Feeds

3.12. Design a compression algorithm that compresses HTML tags. Your algo-
rithm should detect tags in an HTML file and replace them with a code of your
own design that is smaller than the tag itself. Write an encoder and decoder pro-
gram.

3.13. Generate checksums for a document by adding the bytes of the document
and by using theUnix command cksum. Edit the document and see if both check-
sums change.Can you change the document so that the simple checksumdoes not
change?

3.14. Write a program to generate simhash fingerprints for documents. You can
use any reasonable hash function for the words. Use the program to detect du-
plicates on your home computer. Report on the accuracy of the detection. How
does the detection accuracy vary with fingerprint size?

3.15. Plot the document slope curves for a sample of web pages. The sample
should include at least one page containing a news article. Test the accuracy of
the simple optimization algorithm for detecting the main content block. Write
your own program or use the code from http://www.aidanf.net/software/bte-body-
text-extraction. Describe the cases where the algorithm fails. Would an algorithm
that searched explicitly for low-slope areas of the document slope curve be suc-
cessful in these cases?

3.16. Give ahigh-level outline of an algorithmthatwoulduse theDOMstructure
to identify content information in a web page. In particular, describe heuristics
you would use to identify content and non-content elements of the structure.



4
Processing Text

“I was trying to comprehend the meaning of the
words.”

Spock, Star Trek:The Final Frontier

4.1 FromWords to Terms

After gathering the text we want to search, the next step is to decide whether it
should be modified or restructured in some way to simplify searching. The types
of changes that aremade at this stage are called text transformation or, more often,
text processing. The goal of text processing is to convert the many forms in which
words can occur into more consistent index terms. Index terms are the represen-
tation of the content of a document that are used for searching.

The simplest decision about text processingwould be to not do it at all. A good
example of this is the “find” feature in your favorite word processor. By the time
you use the find command, the text you wish to search has already been gathered:
it’s on the screen. After you type the word you want to find, the word processor
scans the document and tries to find the exact sequence of letters that you just
typed. This feature is extremely useful, and nearly every text editing program can
do this because users demand it.

The trouble is that exact text search is rather restrictive. The most annoying
restriction is case-sensitivity: suppose you want to find “computer hardware”, and
there is a sentence in the document that begins with “Computer hardware”. Your
searchquery does not exactlymatch the text in the sentence, because thefirst letter
of the sentence is capitalized. Fortunately, most word processors have an option
for ignoring case during searches. You can think of this as a very rudimentary form
of online text processing. Like most text processing techniques, ignoring case in-
creases the probability that you will find amatch for your query in the document.

Many search engines do not distinguish between uppercase and lowercase let-
ters. However, they gomuch further. As we will see in this chapter, search engines



74 4 Processing Text

can strip punctuation from words to make them easier to find. Words are split
apart in a process called tokenization. Some words may be ignored entirely in or-
der to make query processing more effective and efficient; this is called stopping.
The system may use stemming to allow similar words (like “run” and “running”)
to match each other. Some documents, such as web pages, may have formatting
changes (like bold or large text), or explicit structure (like titles, chapters, and cap-
tions) that can also be used by the system. Web pages also contain links to other
web pages, which can be used to improve document ranking. All of these tech-
niques are discussed in this chapter.

These text processing techniques are fairly simple, even though their effects
on search results can be profound. None of these techniques involves the com-
puter doing any kind of complex reasoning or understanding of the text. Search
engines work because much of the meaning of text is captured by counts of word
occurrences and co-occurrences,1 especially when that data is gathered from the
huge text collections available on theWeb.Understanding the statistical nature of
text is fundamental to understanding retrieval models and ranking algorithms, so
we begin this chapter with a discussion of text statistics. More sophisticated tech-
niques for natural language processing that involve syntactic and semantic analysis
of text have been studied for decades, including their application to information
retrieval, but to date have had little impact on ranking algorithms for search en-
gines. These techniques are, however, being used for the task of question answer-
ing, which is described in Chapter 11. In addition, techniques involving more
complex text processing are being used to identify additional index terms or fea-
tures for search. Information extraction techniques for identifying people’s names,
organization names, addresses, and many other special types of features are dis-
cussed here, and classification, which can be used to identify semantic categories,
is discussed in Chapter 9.

Finally, even though this book focuses on retrieving English documents, in-
formation retrieval techniques can be used with text in many different languages.
In this chapter, we show how different languages require different types of text
representation and processing.

1 Word co-occurrence measures the number of times groups of words (usually pairs) oc-
cur together in documents. A collocation is the name given to a pair, group, or sequence
of words that occur together more often than would be expected by chance. The term
association measures that are used to find collocations are discussed in Chapter 6.



4.2 Text Statistics 75

4.2 Text Statistics

Although language is incredibly rich and varied, it is also very predictable. There
are many ways to describe a particular topic or event, but if the words that occur
in many descriptions of an event are counted, then some words will occur much
more frequently than others. Some of these frequentwords, such as “and” or “the,”
will be common in the description of any event, but others will be characteristic
of that particular event. This was observed as early as 1958 by Luhn, when he
proposed that the significance of a word depended on its frequency in the docu-
ment. Statistical models of word occurrences are very important in information
retrieval, and are used in many of the core components of search engines, such
as the ranking algorithms, query transformation, and indexing techniques. These
models will be discussed in later chapters, but we start here with some of the basic
models of word occurrence.

One of the most obvious features of text from a statistical point of view is that
the distribution of word frequencies is very skewed. There are a few words that
have very high frequencies andmany words that have low frequencies. In fact, the
twomost frequent words in English (“the” and “of ”) account for about 10%of all
word occurrences. The most frequent six words account for 20% of occurrences,
and the most frequent 50 words are about 40% of all text! On the other hand,
given a large sample of text, typically about one half of all the unique words in
that sample occur only once. This distribution is described by Zipf ’s law,2 which
states that the frequency of the rth most common word is inversely proportional
to r or, alternatively, the rank of a word times its frequency (f ) is approximately
a constant (k):

r · f = k

Weoftenwant to talk about the probability of occurrence of a word, which is just
the frequency of the word divided by the total number of word occurrences in the
text. In this case, Zipf ’s law is:

r · Pr = c

wherePr is the probability of occurrence for the rth ranked word, and c is a con-
stant. For English, c ? 0.1. Figure 4.1 shows the graph of Zipf ’s law with this
constant. This clearly shows how the frequency of word occurrence falls rapidly
after the first few most common words.
2 Named after the American linguist George Kingsley Zipf.



76 4 Processing Text

0

0.01

0.02

0.03

0.04

0.05

0.06

0.07

0.08

0.09

0.1

0 10 20 30 40 50 60 70 80 90 100

Rank 
(by decreasing frequency)

Probability
(of occurrence)

Fig. 4.1. Rank versus probability of occurrence for words assuming Zipf ’s law (rank ×
probability = 0.1)

To see how well Zipf ’s law predicts word occurrences in actual text collec-
tions, wewill use theAssociated Press collection of news stories from1989 (called
AP89) as an example. This collection was used in TREC evaluations for several
years. Table 4.1 shows some statistics for the word occurrences in AP89. The vo-
cabulary size is the number of unique words in the collection. Even in this rela-
tively small collection, the vocabulary size is quite large (nearly 200,000 unique
words). A large proportion of these words (70,000) occur only once. Words that
occur once in a text corpus or book have long been regarded as important in text
analysis, and have been given the special name ofHapax Legomena.3

Table 4.2 shows the 50 most frequent words from the AP89 collection, to-
gether with their frequencies, ranks, probability of occurrence (converted to a
percentage of total occurrences), and the r.Pr value. From this table, we can see

3 The name was created by scholars studying the Bible. Since the 13th century, people
have studied the word occurrences in the Bible and, of particular interest, created con-
cordances, which are indexes of where words occur in the text. Concordances are the
ancestors of the inverted files that are used in modern search engines. The first concor-
dance was said to have required 500 monks to create.



4.2 Text Statistics 77

Total documents 84,678
Total word occurrences 39,749,179
Vocabulary size 198,763
Words occurring> 1000 times 4,169
Words occurring once 70,064

Table 4.1. Statistics for the AP89 collection

that Zipf ’s law is quite accurate, in that the value of r.Pr is approximately con-
stant, and close to 0.1. The biggest variations are for some of the most frequent
words. In fact, it is generally observed that Zipf ’s law is inaccurate for low and
high ranks (high-frequency and low-frequency words). Table 4.3 gives some ex-
amples for lower-frequency words from AP89.

Figure 4.2 shows a log-log plot4 of the r.Pr values for all words in the AP89
collection. Zipf ’s law is shown as a straight line on this graph since logPr =
log(c · r?1) = log c ? log r. This figure clearly shows how the predicted re-
lationship breaks down at high ranks (approximately rank 10,000 and above). A
number of modifications to Zipf ’s law have been proposed,5 some of which have
interesting connections to cognitive models of language.

It is possible to derive a simple formula for predicting the proportion of words
with a given frequency from Zipf ’s law. A word that occurs n times has rank
rn = k/n. In general, more than one word may have the same frequency. We
assume that the rank rn is associated with the last of the group of words with the
same frequency. In that case, the number of words with the same frequencynwill
be given by rn ? rn+1, which is the rank of the last word in the group minus
the rank of the last word of the previous group of words with a higher frequency
(remember that higher-frequency words have lower ranks). For example, Table
4.4 has an example of a ranking of words in decreasing order of their frequency.
The number of words with frequency 5,099 is the rank of the last member of that

4 The x and y axes of a log-log plot show the logarithm of the values of x and y, not the
values themselves.

5 The most well-known is the derivation by the mathematician Benoit Mandelbrot (the
same person who developed fractal geometry), which is (r + ?)? · Pr = ?, where ?,
?, and ? are parameters that can be tuned for a particular text. In the case of the AP89
collection, however, the fit for the frequency data is not noticeably better than the Zipf
distribution.



78 4 Processing Text

Word Freq. r Pr(%) r.Pr Word Freq r Pr(%) r.Pr
the 2,420,778 1 6.49 0.065 has 136,007 26 0.37 0.095
of 1,045,733 2 2.80 0.056 are 130,322 27 0.35 0.094
to 968,882 3 2.60 0.078 not 127,493 28 0.34 0.096
a 892,429 4 2.39 0.096 who 116,364 29 0.31 0.090
and 865,644 5 2.32 0.120 they 111,024 30 0.30 0.089
in 847,825 6 2.27 0.140 its 111,021 31 0.30 0.092
said 504,593 7 1.35 0.095 had 103,943 32 0.28 0.089
for 363,865 8 0.98 0.078 will 102,949 33 0.28 0.091
that 347,072 9 0.93 0.084 would 99,503 34 0.27 0.091
was 293,027 10 0.79 0.079 about 92,983 35 0.25 0.087
on 291,947 11 0.78 0.086 i 92,005 36 0.25 0.089
he 250,919 12 0.67 0.081 been 88,786 37 0.24 0.088
is 245,843 13 0.65 0.086 this 87,286 38 0.23 0.089
with 223,846 14 0.60 0.084 their 84,638 39 0.23 0.089
at 210,064 15 0.56 0.085 new 83,449 40 0.22 0.090
by 209,586 16 0.56 0.090 or 81,796 41 0.22 0.090
it 195,621 17 0.52 0.089 which 80,385 42 0.22 0.091
from 189,451 18 0.51 0.091 we 80,245 43 0.22 0.093
as 181,714 19 0.49 0.093 more 76,388 44 0.21 0.090
be 157,300 20 0.42 0.084 after 75,165 45 0.20 0.091
were 153,913 21 0.41 0.087 us 72,045 46 0.19 0.089
an 152,576 22 0.41 0.090 percent 71,956 47 0.19 0.091
have 149,749 23 0.40 0.092 up 71,082 48 0.19 0.092
his 142,285 24 0.38 0.092 one 70,266 49 0.19 0.092
but 140,880 25 0.38 0.094 people 68,988 50 0.19 0.093

Table 4.2. Most frequent 50 words from AP89

Word Freq. r Pr(%) r.Pr
assistant 5,095 1,021 .013 0.13
sewers 100 17,110 .000256 0.04
toothbrush 10 51,555 .000025 0.01
hazmat 1 166,945 .000002 0.04

Table 4.3. Low-frequency words from AP89



4.2 Text Statistics 79

 1e-008

 1e-007

 1e-006

 1e-005

 0.0001

 0.001

 0.01

 0.1

 1

 1  10  100  1000  10000  100000  1e+006

Pr

Rank

Zipf
AP89

Fig. 4.2. A log-log plot of Zipf ’s law compared to real data from AP89. The predicted
relationshipbetweenprobability of occurrence and rankbreaks downbadly at high ranks.

group (“chemical”) minus the rank of the last member of the previous group with
higher frequency (“summit”), which is 1006? 1002 = 4.

Rank Word Frequency
1000 concern 5,100
1001 spoke 5,100
1002 summit 5,100
1003 bring 5,099
1004 star 5,099
1005 immediate 5,099
1006 chemical 5,099
1007 african 5,098

Table 4.4. Example word frequency ranking



80 4 Processing Text

Given that the number of words with frequency n is rn ? rn+1 = k/n ?
k/(n + 1) = k/n(n + 1), then the proportion of words with this frequency
can be found by dividing this number by the total number of words, which will
be the rank of the last word with frequency 1. The rank of the last word in the
vocabulary is k/1 = k. The proportion of words with frequency n, therefore, is
given by 1/n(n+1).This formula predicts, for example, that 1/2 of the words in
the vocabularywill occur once.Table 4.5 compares the predictions of this formula
with real data from a different TREC collection.

Number of Predicted Actual Actual
Occurrences Proportion Proportion Number of

(n) (1/n(n+1)) Words
1 0.500 0.402 204,357
2 0.167 0.132 67,082
3 0.083 0.069 35,083
4 0.050 0.046 23,271
5 0.033 0.032 16,332
6 0.024 0.024 12,421
7 0.018 0.019 9,766
8 0.014 0.016 8,200
9 0.011 0.014 6,907
10 0.009 0.012 5,893

Table 4.5. Proportions of words occurring n times in 336,310 documents from the
TRECVolume 3 corpus.The total vocabulary size (number of unique words) is 508,209.

4.2.1 Vocabulary Growth

Another useful prediction related towordoccurrence is vocabulary growth. As the
size of the corpus grows, newwords occur. Based on the assumption of a Zipf dis-
tribution for words, we would expect that the number of newwords that occur in
a given amount of new textwould decrease as the size of the corpus increases.New
words will, however, always occur due to sources such as invented words (think
of all those drug names and start-up company names), spelling errors, product
numbers, people’s names, email addresses, and many others. The relationship be-
tween the size of the corpus and the size of the vocabulary was found empirically
by Heaps (1978) to be:



4.2 Text Statistics 81

v = k · n?

where v is the vocabulary size for a corpus of size n words, and k and ? are pa-
rameters that vary for each collection.This is sometimes referred to asHeaps’ law.
Typical values for k and ? are often stated to be 10 ? k ? 100 and ? ? 0.5.
Heaps’ law predicts that the number of newwords will increase very rapidly when
the corpus is small and will continue to increase indefinitely, but at a slower rate
for larger corpora. Figure 4.3 shows a plot of vocabulary growth for the AP89
collection compared to a graph of Heaps’ law with k = 62.95 and ? = 0.455.
Clearly, Heaps’ law is a good fit. The parameter values are similar for many of
the other TREC news collections. As an example of the accuracy of this predic-
tion, if the first 10,879,522 words of the AP89 collection are scanned, Heaps’
law predicts that the number of unique words will be 100,151, whereas the actual
value is 100,024. Predictions are much less accurate for small numbers of words
(< 1,000).

 0

 20000

 40000

 60000

 80000

 100000

 120000

 140000

 160000

 180000

 200000

 0  5e+006  1e+007  1.5e+007  2e+007  2.5e+007  3e+007  3.5e+007  4e+007

W
or

ds
 in

 V
oc

ab
ul

ar
y

Words in Collection

AP89
Heaps 62.95, 0.455

Fig. 4.3. Vocabulary growth for the TREC AP89 collection compared to Heaps’ law



82 4 Processing Text

Web-scale collections are considerably larger than the AP89 collection. The
AP89collection contains about40millionwords, but the (relatively small)TREC
Web collection GOV26 contains more than 20 billion words. With that many
words, it seems likely that the number of new words would eventually drop to
near zero andHeaps’ law would not be applicable. It turns out this is not the case.
Figure 4.4 shows a plot of vocabulary growth for GOV2 together with a graph of
Heaps’ law with k = 7.34 and ? = 0.648. This data indicates that the number of
unique words continues to grow steadily even after reaching 30 million. This has
significant implications for the design of search engines, which will be discussed
in Chapter 5. Heaps’ law provides a good fit for this data, although the parameter
values are very different than those for other TREC collections and outside the
boundaries established as typical with these and other smaller collections.

 0

 5e+006

 1e+007

 1.5e+007

 2e+007

 2.5e+007

 3e+007

 3.5e+007

 4e+007

 4.5e+007

 0  5e+009  1e+010  1.5e+010  2e+010  2.5e+010

W
or

ds
 in

 V
oc

ab
ul

ar
y

Words in Collection

GOV2
Heaps 7.34, 0.648

Fig. 4.4. Vocabulary growth for the TREC GOV2 collection compared to Heaps’ law

6 Web pages crawled fromwebsites in the .gov domain during early 2004. See section 8.2
for more details.



4.2 Text Statistics 83

4.2.2 Estimating Collection and Result Set Sizes

Wordoccurrence statistics can also beused to estimate the size of the results froma
web search.Allweb search engines have some versionof the query interface shown
in Figure 4.5, where immediately after the query (“tropical fish aquarium” in this
case) andbefore the ranked list of results, an estimate of the total number of results
is given. This is typically a very large number, and descriptions of these systems
always point out that it is just an estimate. Nevertheless, it is always included.

tropical fish aquarium       Search

Web results  Page 1 of 3,880,000 results
 

Fig. 4.5. Result size estimate for web search

To estimate the size of a result set, we first need to define “results.” For the
purposes of this estimation, a result is any document (or web page) that contains
all of the query words. Some search applications will rank documents that do not
contain all the query words, but given the huge size of the Web, this is usually
not necessary. If we assume that words occur independently of each other, then
the probability of a document containing all the words in the query is simply the
product of the probabilities of the individual words occurring in a document. For
example, if there are three query words a, b, and c, then:

P (a ? b ? c) = P (a) · P (b) · P (c)

whereP (a? b? c) is the joint probability, or the probability that all three words
occur in a document, andP (a),P (b), andP (c) are the probabilities of eachword
occurring in a document. A search enginewill always have access to the number of
documents that a word occurs in (fa, fb, and fc),7 and the number of documents
in the collection (N ), so these probabilities can easily be estimated as P (a) =
fa/N , P (b) = fb/N , and P (c) = fc/N . This gives us

fabc = N · fa/N · fb/N · fc/N = (fa · fb · fc)/N2

where fabc is the estimated size of the result set.
7 Note that these are document occurrence frequencies, not the total number of word oc-
currences (there may be many occurrences of a word in a document).



84 4 Processing Text

Document Estimated
Word(s) Frequency Frequency
tropical 120,990
fish 1,131,855
aquarium 26,480
breeding 81,885
tropical fish 18,472 5,433
tropical aquarium 1,921 127
tropical breeding 5,510 393
fish aquarium 9,722 1,189
fish breeding 36,427 3,677
aquarium breeding 1,848 86
tropical fish aquarium 1,529 6
tropical fish breeding 3,629 18

Table 4.6. Document frequencies and estimated frequencies for word combinations (as-
suming independence) in the GOV2 Web collection. Collection size (N ) is 25,205,179.

Table 4.6 gives document occurrence frequencies for the words “tropical”,
“fish”, “aquarium”, and “breeding”, and for combinations of those words in the
TRECGOV2Web collection. It also gives the estimated size of the frequencies of
the combinations based on the independence assumption. Clearly, this assump-
tion does not lead to good estimates for result size, especially for combinations of
three words. The problem is that the words in these combinations do not occur
independently of each other. If we see the word “fish” in a document, for example,
then the word “aquarium” is more likely to occur in this document than in one
that does not contain “fish”.

Better estimates are possible if word co-occurrence information is also avail-
able from the search engine. Obviously, this would give exact answers for two-
word queries. For longer queries, we can improve the estimate by not assuming
independence. In general, for three words

P (a ? b ? c) = P (a ? b) · P (c|(a ? b))

whereP (a? b) is the probability that the words a and b co-occur in a document,
andP (c|(a?b)) is the probability that theword coccurs in a document given that
the words a and b occur in the document.8 If we have co-occurrence information,
8 This is called a conditional probability.



4.2 Text Statistics 85

we can approximate this probability using either P (c|a) or P (c|b), whichever is
the largest. For the example query “tropical fish aquarium” inTable 4.6, thismeans
we estimate the result set size bymultiplying thenumber of documents containing
both “tropical” and “aquarium” by the probability that a document contains “fish”
given that it contains “aquarium”, or:

ftropical?fish?aquarium = ftropical?aquarium · ffish?aquarium/faquarium
= 1921 · 9722/26480 = 705

Similarly, for the query “tropical fish breeding”:

ftropical?fish?breeding = ftropical?breeding · ffish?breeeding/fbreeding
= 5510 · 36427/81885 = 2451

These estimates are much better than the ones produced assuming indepen-
dence, but they are still too low. Rather than storing evenmore information, such
as the number of occurrences of word triples, it turns out that reasonable esti-
mates of result size can be made using just word frequency and the size of the cur-
rent result set. Search engines estimate the result size because they do not rank all
the documents that contain the query words. Instead, they rank a much smaller
subset of the documents that are likely to be the most relevant. If we know the
proportion of the total documents that have been ranked (s) and the number of
documents found that contain all the query words (C), we can simply estimate
the result size asC/s, which assumes that the documents containing all thewords
are distributed uniformly.9 The proportion of documents processed is measured
by the proportion of the documents containing the least frequent word that have
been processed, since all results must contain that word.

For example, if the query “tropical fish aquarium” is used to rank GOV2 doc-
uments in theGalago search engine, after processing 3,000 out of the 26,480 doc-
uments that contain “aquarium”, the number of documents containing all three
words is 258. This gives a result size estimate of 258/(3,000÷ 26,480) = 2,277.
After processing just over 20% of the documents, the estimate is 1,778 (compared
to the actual figure of 1,529). For the query “tropical fish breeding”, the estimates
after processing 10%and20%of the documents that contain “breeding” are 4,076

9 We are also assuming document-at-a-time processing, where the inverted lists for all
query words are processed at the same time, giving complete document scores (see
Chapter 5).



86 4 Processing Text

and 3,762 (compared to 3,629). These estimates, as well as being quite accurate,
do not require knowledge of the total number of documents in the collection.

Estimating the total number of documents stored in a search engine is, in fact,
of significant interest to both academia (howbig is theWeb?) andbusiness (which
search engine has better coverage of the Web?). A number of papers have been
written about techniques to do this, and one of these is based on the concept
of word independence that we used before. If a and b are two words that occur
independently, then

fab/N = fa/N · fb/N

and
N = (fa · fb)/fab

To get a reasonable estimate ofN , the two words should be independent and,
as we have seen from the examples in Table 4.6, this is often not the case. We can
be more careful about the choice of query words, however. For example, if we use
the word “lincoln” (document frequency 771,326 in GOV2), we would expect
the words in the query “tropical lincoln” to be more independent than the word
pairs in Table 4.6 (since the former are less semantically related). The document
frequency of “tropical lincoln” in GOV2 is 3,018, which means we can estimate
the size of the collection as N = (120,990 · 771,326)/3,018 = 30,922,045. This
is quite close to the actual number of 25,205,179.

4.3 Document Parsing

4.3.1 Overview

Document parsing involves the recognition of the content and structure of text
documents. The primary content of most documents is the words that we were
counting and modeling using the Zipf distribution in the previous section. Rec-
ognizing each word occurrence in the sequence of characters in a document is
called tokenizing or lexical analysis. Apart from these words, there can be many
other types of content in a document, such as metadata, images, graphics, code,
and tables. As mentioned in Chapter 2, metadata is information about a doc-
ument that is not part of the text content. Metadata content includes docu-
ment attributes such as date and author, and, most importantly, the tags that are
used by markup languages to identify document components. The most popular



4.3 Document Parsing 87

markup languages are HTML (Hypertext Markup Language) and XML (Exten-
sible Markup Language).

The parser uses the tags and other metadata recognized in the document to
interpret the document’s structure based on the syntax of the markup language
(syntactic analysis) and to produce a representation of the document that includes
both the structure and content. For example, an HTML parser interprets the
structure of a web page as specified using HTML tags, and creates a Document
Object Model (DOM) representation of the page that is used by a web browser.
In a search engine, the output of a document parser is a representation of the con-
tent and structure that will be used for creating indexes. Since it is important for
a search index to represent every document in a collection, a document parser for
a search engine is often more tolerant of syntax errors than parsers used in other
applications.

In the first part of our discussion of document parsing, we focus on the recog-
nition of the tokens, words, and phrases that make up the content of the docu-
ments. In later sections, we discuss separately the important topics related to doc-
ument structure, namely markup, links, and extraction of structure from the text
content.

4.3.2 Tokenizing

Tokenizing is the process of forming words from the sequence of characters in
a document. In English text, this appears to be simple. In many early systems, a
“word” was defined as any sequence of alphanumeric characters of length 3 or
more, terminated by a space or other special character. All uppercase letters were
also converted to lowercase.10 This means, for example, that the text

Bigcorp’s 2007 bi-annual report showed profits rose 10%.

would produce the following sequence of tokens:

bigcorp 2007 annual report showed profits rose

Although this simple tokenizing process was adequate for experiments with small
test collections, it does not seem appropriate for most search applications or even
experiments with TREC collections, because toomuch information is discarded.
Some examples of issues involving tokenizing that can have significant impact on
the effectiveness of search are:
10 This is sometimes referred to as case folding, case normalization, or downcasing.



88 4 Processing Text

• Small words (one or two characters) can be important in some queries, usually
in combinations with other words. For example, xp,ma, pm, ben e king, el paso,
master p, gm, j lo, world war II.11

• Both hyphenated and non-hyphenated forms of many words are common. In
some cases the hyphen is not needed. For example, e-bay, wal-mart, active-x,
cd-rom, t-shirts. At other times, hyphens should be considered either as part of
the word or a word separator. For example, winston-salem,mazda rx-7, e-cards,
pre-diabetes, t-mobile, spanish-speaking.

• Special characters are an important part of the tags, URLs, code, and other
important parts of documents that must be correctly tokenized.

• Capitalized words can have different meaning from lowercase words. For ex-
ample, “Bush” and “Apple”.

• Apostrophes can be a part of a word, a part of a possessive, or just a mistake.
For example, rosie o’donnell, can’t, don’t, 80’s, 1890’s, men’s straw hats, master’s
degree, england’s ten largest cities, shriner’s.

• Numbers can be important, including decimals. For example, nokia 3250, top
10 courses, united 93, quicktime 6.5 pro, 92.3 the beat, 288358 (yes, this was a
real query; it’s a patent number).

• Periods can occur in numbers, abbreviations (e.g., “I.B.M.”, “Ph.D.”), URLs,
ends of sentences, and other situations.

From these examples, tokenizing seemsmore complicated than it first appears.
The fact that these examples come from queries also emphasizes that the text pro-
cessing for queries must be the same as that used for documents. If different to-
kenizing processes are used for queries and documents, many of the index terms
used for documents will simply not match the corresponding terms from queries.
Mistakes in tokenizing become obvious very quickly through retrieval failures.

To be able to incorporate the range of language processing required to make
matching effective, the tokenizing process should be both simple and flexible.
One approach to doing this is for the first pass of tokenizing to focus entirely
on identifying markup or tags in the document. This could be done using a tok-
enizer and parser designed for the specific markup language used (e.g., HTML),
but it should accommodate syntax errors in the structure, as mentioned previ-
ously. A second pass of tokenizing can then be done on the appropriate parts of
the document structure. Some parts that are not used for searching, such as those
containing HTML code, will be ignored in this pass.

11 These and other examples were taken from a small sample of web queries.



4.3 Document Parsing 89

Given that nearly everything in the text of a document can be important for
some query, the tokenizing rules have to convert most of the content to search-
able tokens. Instead of trying to do everything in the tokenizer, some of the more
difficult issues, such as identifying word variants or recognizing that a string is
a name or a date, can be handled by separate processes, including stemming, in-
formation extraction, and query transformation. Information extraction usually
requires the full form of the text as input, including capitalization and punctua-
tion, so this information must be retained until extraction has been done. Apart
from this restriction, capitalization is rarely important for searching, and text can
be reduced to lowercase for indexing. This does not mean that capitalized words
are not used in queries. They are, in fact, used quite often, but in queries where
the capitalization does not reduce ambiguity and so does not impact effective-
ness. Words such as “Apple” that are often used in examples (but not so often in
real queries) can be handled by query reformulation techniques (Chapter 6) or
simply by relying on the most popular pages (section 4.5).

If we take the view that complicated issues are handled by other processes, the
most general strategy for hyphens, apostrophes, and periods would be to treat
them as word terminators (like spaces). It is important that all the tokens pro-
duced are indexed, including single characters such as “s” and “o”. This will mean,
for example, that the query12 ”o’connor” is equivalent to ”o connor”, ”bob’s” is
equivalent to ”bob s”, and ”rx-7” is equivalent to ”rx 7”. Note that this will also
mean that a word such as “rx7” will be a different token than “rx-7” and therefore
will be indexed separately. The task of relating the queries rx 7, rx7, and rx-7 will
then be handled by the query transformation component of the search engine.

On the other hand, if we rely entirely on the query transformation component
tomake the appropriate connections or inferences betweenwords, there is the risk
that effectiveness could be lowered, particularly in applications where there is not
enough data for reliable query expansion. In these cases, more rules can be incor-
porated into the tokenizer to ensure that the tokens produced by the query text
will match the tokens produced from document text. For example, in the case
of TREC collections, a rule that tokenizes all words containing apostrophes by
the string without the apostrophe is very effective. With this rule, “O’Connor”
would be tokenized as “oconnor” and “Bob’s” would produce the token “bobs”.
Another effective rule for TREC collections is to tokenize all abbreviations con-
12 We assume the common syntax for web queries where ”<words>”meansmatch exactly

the phrase contained in the quotes.



90 4 Processing Text

taining periods as the string without periods. An abbreviation in this case is any
string of alphabetic single characters separated by periods. This rule would tok-
enize “I.B.M.” as “ibm”, but “Ph.D.” would still be tokenized as “ph d”.

In summary, the most general tokenizing process will involve first identify-
ing the document structure and then identifying words in text as any sequence
of alphanumeric characters, terminated by a space or special character, with ev-
erything converted to lowercase. This is not much more complicated than the
simple process we described at the start of the section, but it relies on informa-
tion extraction and query transformation to handle the difficult issues. In many
cases, additional rules are added to the tokenizer to handle some of the special
characters, to ensure that query and document tokens will match.

4.3.3 Stopping

Human language is filled with function words: words that have little meaning
apart fromotherwords.Themost popular—“the,” “a,” “an,” “that,” and “those”—are
determiners. These words are part of how we describe nouns in text, and express
concepts like location or quantity. Prepositions, such as “over,” “under,” “above,”
and “below,” represent relative position between two nouns.

Two properties of these function words cause us to want to treat them in a
special way in text processing. First, these function words are extremely common.
Table 4.2 shows that nearly all of themost frequent words in the AP89 collection
fall into this category. Keeping track of the quantity of these words in each docu-
ment requires a lot of disk space. Second, both because of their commonness and
their function, these words rarely indicate anything about document relevance on
their own. If we are considering individual words in the retrieval process and not
phrases, these function words will help us very little.

In information retrieval, these function words have a second name: stopwords.
We call them stopwords because text processing stops when one is seen, and they
are thrown out.Throwing out these words decreases index size, increases retrieval
efficiency, and generally improves retrieval effectiveness.

Constructing a stopword list must be done with caution. Removing too many
words will hurt retrieval effectiveness in particularly frustrating ways for the user.
For instance, the query ”to be or not to be” consists entirely of words that are usu-
ally considered stopwords. Although not removing stopwords may cause some
problems in ranking, removing stopwords can cause perfectly valid queries to re-
turn no results.



4.3 Document Parsing 91

A stopword list can be constructed by simply using the top n (e.g., 50) most
frequent words in a collection. This can, however, lead to words being included
that are important for some queries. More typically, either a standard stopword
list is used,13 or a list of frequentwords and standard stopwords ismanually edited
to remove any words that may be significant for a particular application. It is also
possible to create stopword lists that are customized for specific parts of the doc-
ument structure (also called fields). For example, the words “click”, “here”, and
“privacy” may be reasonable stopwords to use when processing anchor text.

If storage space requirements allow, it is best to at least index all words in the
documents. If stopping is required, the stopwords can always be removed from
queries. By keeping the stopwords in the index, there will be a number of possi-
ble ways to execute a query with stopwords in it. For instance, many systems will
remove stopwords from a query unless the word is preceded by a plus sign (+). If
keeping stopwords in an index is not possible because of space requirements, as
few as possible should be removed in order to maintain maximum flexibility.

4.3.4 Stemming

Part of the expressiveness of natural language comes from the huge number of
ways to convey a single idea. This can be a problem for search engines, which rely
on matching words to find relevant documents. Instead of restricting matches to
words that are identical, a number of techniques have been developed to allow a
search engine to match words that are semantically related. Stemming, also called
conflation, is a component of text processing that captures the relationships be-
tween different variations of a word. More precisely, stemming reduces the dif-
ferent forms of a word that occur because of inflection (e.g., plurals, tenses) or
derivation (e.g., making a verb into a noun by adding the suffix -ation) to a com-
mon stem.

Suppose you want to search for news articles about Mark Spitz’s Olympic
swimming career. You might type “mark spitz swimming” into a search engine.
However, many news articles are usually summaries of events that have already
happened, so they are likely to contain the word “swam” instead of “swimming.”
It is the job of the stemmer to reduce “swimming” and “swam” to the same stem
(probably “swim”) and thereby allow the search engine to determine that there is
a match between these two words.
13 Such as the one distributed with the Lemur toolkit and included with Galago.



92 4 Processing Text

In general, using a stemmer for search applications with English text produces
a small but noticeable improvement in the quality of results. In applications in-
volving highly inflected languages, such as Arabic or Russian, stemming is a cru-
cial part of effective search.

There are two basic types of stemmers: algorithmic and dictionary-based. An
algorithmic stemmer uses a small program to decide whether two words are re-
lated, usually based on knowledge of word suffixes for a particular language. By
contrast, a dictionary-based stemmer has no logic of its own, but instead relies on
pre-created dictionaries of related terms to store term relationships.

The simplest kind of English algorithmic stemmer is the suffix-s stemmer.This
kind of stemmer assumes that any word ending in the letter “s” is plural, so cakes
? cake, dogs? dog. Of course, this rule is not perfect. It cannot detect many
plural relationships, like “century” and “centuries”. In very rare cases, it detects a
relationshipwhere it does not exist, such aswith “I” and “is”.Thefirst kind of error
is called a false negative, and the second kind of error is called a false positive.14

More complicated algorithmic stemmers reduce the number of false negatives
by considering more kinds of suffixes, such as -ing or -ed. By handling more suffix
types, the stemmer can find more term relationships; in other words, the false
negative rate is reduced. However, the false positive rate (finding a relationship
where none exists) generally increases.

The most popular algorithmic stemmer is the Porter stemmer.15 This has been
used in many information retrieval experiments and systems since the 1970s, and
a number of implementations are available. The stemmer consists of a number
of steps, each containing a set of rules for removing suffixes. At each step, the rule
for the longest applicable suffix is executed. Someof the rules are obvious, whereas
others require some thought towork outwhat they are doing.As an example, here
are the first two parts of step 1 (of 5 steps):

Step 1a:
- Replace sses by ss (e.g., stresses? stress).
- Delete s if the preceding word part contains a vowel not immediately be-

fore the s (e.g., gaps? gap but gas? gas).
- Replace ied or ies by i if preceded by more than one letter, otherwise by ie

(e.g., ties? tie, cries? cri).
14 These terms are used in any binary decision process to describe the two types of errors.

This includes evaluation (Chapter 8) and classification (Chapter 9).
15 http://tartarus.org/martin/PorterStemmer/



4.3 Document Parsing 93

- If suffix is us or ss do nothing (e.g., stress? stress).
Step 1b:
- Replace eed, eedly by ee if it is in the part of the word after the first non-

vowel following a vowel (e.g., agreed? agree, feed? feed).
- Delete ed, edly, ing, ingly if the preceding word part contains a vowel, and

then if the word ends in at, bl, or iz add e (e.g., fished? fish, pirating?
pirate), or if theword endswith adouble letter that is not ll, ss, or zz, remove
the last letter (e.g., falling? fall, dripping? drip), or if the word is short, add
e (e.g., hoping? hope).

- Whew!

ThePorter stemmer has been shown to be effective in a number ofTRECeval-
uations and search applications. It is difficult, however, to capture all the subtleties
of a language in a relatively simple algorithm. The original version of the Porter
stemmer made a number of errors, both false positives and false negatives. Table
4.7 shows some of these errors. It is easy to imagine how confusing “execute” with
“executive” or “organization” with “organ” could cause significant problems in
the ranking. A more recent form of the stemmer (called Porter2)16 fixes some of
these problems and provides a mechanism to specify exceptions.

False positives False negatives
organization/organ european/europe
generalization/generic cylinder/cylindrical
numerical/numerous matrices/matrix
policy/police urgency/urgent
university/universe create/creation
addition/additive analysis/analyses
negligible/negligent useful/usefully
execute/executive noise/noisy
past/paste decompose/decomposition
ignore/ignorant sparse/sparsity
special/specialized resolve/resolution
head/heading triangle/triangular

Table 4.7. Examples of errors made by the original Porter stemmer. False positives are
pairs of words that have the same stem. False negatives are pairs that have different stems.

16 http://snowball.tartarus.org



94 4 Processing Text

A dictionary-based stemmer provides a different approach to the problem of
stemming errors. Instead of trying to detect word relationships from letter pat-
terns, we can store lists of related words in a large dictionary. Since these word
lists can be created by humans, we can expect that the false positive rate will be
very low for these words. Related words do not even need to look similar; a dic-
tionary stemmer can recognize that “is,” “be,” and “was” are all forms of the same
verb. Unfortunately, the dictionary cannot be infinitely long, so it cannot react
automatically to new words. This is an important problem since language is con-
stantly evolving. It is possible to build stemdictionaries automatically by statistical
analysis of a text corpus. Since this is particularly useful when stemming is used
for query expansion, we discuss this technique in section 6.2.1.

Another strategy is to combine an algorithmic stemmer with a dictionary-
based stemmer. Typically, irregular words such as the verb “to be” are the oldest
in the language, while new words follow more regular grammatical conventions.
This means that newly invented words are likely to work well with an algorith-
mic stemmer. A dictionary can be used to detect relationships between common
words, and the algorithmic stemmer can be used for unrecognized words.

A well-known example of this hybrid approach is the Krovetz stemmer (Kro-
vetz, 1993). This stemmer makes constant use of a dictionary to check whether
the word is valid. The dictionary in the Krovetz stemmer is based on a general
English dictionary but also uses exceptions that are generated manually. Before
being stemmed, the dictionary is checked to see whether a word is present; if it
is, it is either left alone (if it is in the general dictionary) or stemmed based on
the exception entry. If the word is not in the dictionary, it is checked for a list
of common inflectional and derivational suffixes. If one is found, it is removed
and the dictionary is again checked to see whether the word is present. If it is
not found, the ending of the word may be modified based on the ending that was
removed. For example, if the ending -ies is found, it is replaced by -ie and checked
in the dictionary. If it is found in the dictionary, the stem is accepted; otherwise
the ending is replaced by y. This will result in calories? calorie, for example. The
suffixes are checked in a sequence (for example, plurals before -ion endings), so
multiple suffixes may be removed.

The Krovetz stemmer has a lower false positive rate than the Porter stemmer,
but also tends to have a higher false negative rate, depending on the size of the ex-
ception dictionaries. Overall, the effectiveness of the two stemmers is comparable
when used in search evaluations. The Krovetz stemmer has the additional advan-
tage of producing stems that, in most cases, are full words, whereas the Porter



4.3 Document Parsing 95

Original text: 

Document will describe marketing strategies carried out by U.S. companies for their agricultural 

chemicals, report predictions for market share of such chemicals, or report market statistics for 

agrochemicals, pesticide, herbicide, fungicide, insecticide, fertilizer, predicted sales, market share, 

stimulate demand, price cut, volume of sales. 

 

Porter stemmer: 

 document describ market strategi carri compani agricultur chemic report predict market share chemic 

report market statist agrochem pesticid herbicid fungicid insecticid fertil predict sale market share 

stimul demand price cut volum sale 

 

Krovetz stemmer: 

 document describe marketing strategy carry company agriculture chemical report prediction market 

share chemical report market statistic agrochemic pesticide herbicide fungicide insecticide fertilizer 

predict sale stimulate demand price cut volume sale 

Fig. 4.6. Comparison of stemmer output for a TREC query. Stopwords have also been
removed.

stemmer often produces stems that are word fragments. This is a concern if the
stems are used in the search interface.

Figure 4.6 compares the output of the Porter and Krovetz stemmers on the
text of a TREC query. The output of the Krovetz stemmer is similar in terms of
which words are reduced to the same stems, although “marketing” is not reduced
to “market” because it was in the dictionary. The stems produced by the Krovetz
stemmer are mostly words. The exception is the stem “agrochemic”, which oc-
curred because “agrochemical” was not in the dictionary. Note that text process-
ing in this example has removed stopwords, including single characters. This re-
sulted in the removal of “U.S.” from the text, which could have significant conse-
quences for some queries. This can be handled by better tokenization or informa-
tion extraction, as we discuss in section 4.6.

As in the case of stopwords, the search engine will have more flexibility to an-
swer a broad range of queries if the document words are not stemmed but instead
are indexed in their original form. Stemming can then be done as a type of query
expansion, as explained in section 6.2.1. In some applications, both the full words
and their stems are indexed, in order to provide both flexibility and efficient query
processing times.

We mentioned earlier that stemming can be particularly important for some
languages, and have virtually no impact in others. Incorporating language-specific



96 4 Processing Text

stemming algorithms is one of the most important aspects of customizing, or in-
ternationalizing, a search engine for multiple languages. We discuss other aspects
of internationalization in section 4.7, but focus on the stemming issues here.

As an example, Table 4.8 shows some of the Arabic words derived from the
same root. A stemming algorithm that reducedArabic words to their roots would
clearly not work (there are less than 2,000 roots in Arabic), but a broad range of
prefixes and suffixes must be considered. Highly inflectional languages like Ara-
bic have many word variants, and stemming can make a large difference in the
accuracy of the ranking. An Arabic search engine with high-quality stemming
can be more than 50% more effective, on average, at finding relevant documents
than a systemwithout stemming. In contrast, improvements for an English search
engine vary from less than 5% on average for large collections to about 10% for
small, domain-specific collections.

kitab a book
kitabi my book
alkitab the book
kitabuki your book (f )
kitabuka your book (m)
kitabuhu his book
kataba to write
maktaba library, bookstore
maktab office

Table 4.8. Examples of words with the Arabic root ktb

Fortunately, stemmers for a number of languages have already been developed
and are available as open source software. For example, thePorter stemmer is avail-
able inFrench, Spanish, Portuguese, Italian,Romanian,German,Dutch, Swedish,
Norwegian,Danish, Russian, Finnish,Hungarian, andTurkish.17 In addition, the
statistical approach to building a stemmer that is described in section 6.2.1 can be
used when only a text corpus is available.

17 http://snowball.tartarus.org/



4.3 Document Parsing 97

4.3.5 Phrases and N-grams

Phrases are clearly important in information retrieval. Many of the two- and
three-word queries submitted to search engines are phrases, and finding docu-
ments that contain those phrases will be part of any effective ranking algorithm.
For example, given the query “black sea”, documents that contain that phrase are
much more likely to be relevant than documents containing text such as “the sea
turned black”. Phrases are more precise than single words as topic descriptions
(e.g., “tropical fish” versus “fish”) and usually less ambiguous (e.g., “rotten ap-
ple” versus “apple”). The impact of phrases on retrieval can be complex, however.
Given a query such as “fishing supplies”, should the retrieved documents contain
exactly that phrase, or should they get credit for containing thewords “fish“, “fish-
ing”, and “supplies” in the same paragraph, or even the same document? The de-
tails of how phrases affect ranking will depend on the specific retrieval model that
is incorporated into the search engine, so wewill defer this discussion until Chap-
ter 7. From the perspective of text processing, the issue is whether phrases should
be identified at the same time as tokenizing and stemming, so that they can be
indexed for faster query processing.

There are a number of possible definitions of a phrase, and most of them have
been studied in retrieval experiments over the years. Since a phrase has a grammat-
ical definition, it seems reasonable to identify phrases using the syntactic structure
of sentences.The definition that has been usedmost frequently in information re-
trieval research is that a phrase is equivalent to a simple noun phrase. This is often
restricted even further to include just sequences of nouns, or adjectives followed
by nouns. Phrases defined by these criteria can be identified using a part-of-speech
(POS) tagger. A POS tagger marks the words in a text with labels corresponding
to the part-of-speech of the word in that context. Taggers are based on statistical
or rule-based approaches and are trained using large corpora that have beenman-
ually labeled. Typical tags that are used to label the words include NN (singular
noun), NNS (plural noun), VB (verb), VBD (verb, past tense), VBN (verb, past
participle), IN (preposition), JJ (adjective), CC (conjunction, e.g., “and”, “or”),
PRP (pronoun), and MD (modal auxiliary, e.g., “can”, “will”).

Figure 4.7 shows the output of a POS tagger for the TREC query text used
in Figure 4.6. This example shows that the tagger can identify phrases that are
sequences of nouns, such as “marketing/NN strategies/NNS”, or adjectives fol-
lowed by nouns, such as “agricultural/JJ chemicals/NNS”. Taggers do, however,
make mistakes. The words “predicted/VBN sales/NNS” would not be identified
as a noun phrase, because “predicted” is tagged as a verb.



98 4 Processing Text

Original text: 

Document will describe marketing strategies carried out by U.S. companies for their agricultural 

chemicals, report predictions for market share of such chemicals, or report market statistics for 

agrochemicals, pesticide, herbicide, fungicide, insecticide, fertilizer, predicted sales, market share, 

stimulate demand, price cut, volume of sales. 

 

Brill tagger: 

Document/NN will/MD describe/VB marketing/NN strategies/NNS carried/VBD out/IN by/IN U.S./NNP 

companies/NNS for/IN their/PRP agricultural/JJ chemicals/NNS ,/, report/NN predictions/NNS for/IN 

market/NN share/NN of/IN such/JJ chemicals/NNS ,/, or/CC report/NN market/NN statistics/NNS for/IN 

agrochemicals/NNS ,/, pesticide/NN ,/, herbicide/NN ,/, fungicide/NN ,/, insecticide/NN ,/, fertilizer/NN 

,/, predicted/VBN sales/NNS ,/, market/NN share/NN ,/, stimulate/VB demand/NN ,/, price/NN cut/NN 

,/, volume/NN of/IN sales/NNS ./. 

Fig. 4.7. Output of a POS tagger for a TREC query

Table 4.9 shows the high-frequency simple noun phrases from a TREC cor-
pus consisting mainly of news stories and a corpus of comparable size consisting
of all the 1996 patents issued by the United States Patent and Trademark Of-
fice (PTO). The phrases were identified by POS tagging. The frequencies of the
example phrases indicate that phrases are used more frequently in the PTO col-
lection, because patents are written in a formal, legal style with considerable repe-
tition. There were 1,100,000 phrases in the TREC collection that occurred more
than five times, and 3,700,000 phrases in the PTOcollection.Many of theTREC
phrases are proper nouns, such as “los angeles” or “european union”, or are topics
that will be important for retrieval, such as “peace process” and “human rights”.
Two phrases are associated with the format of the documents (“article type”, “end
recording”). On the other hand, most of the high-frequency phrases in the PTO
collection are standard terms used to describe all patents, such as“present inven-
tion” and “preferred embodiment”, and relatively few are related to the content
of the patents, such as “carbon atoms” and “ethyl acetate”. One of the phrases,
“group consisting”, was the result of a frequent tagging error.

Although POS tagging produces reasonable phrases and is used in a number
of applications, in general it is too slow to be used as the basis for phrase index-
ing of large collections. There are simpler and faster alternatives that are just as
effective. One approach is to store word position information in the indexes and
use this information to identify phrases only when a query is processed. This pro-
vides considerable flexibility in that phrases can be identified by the user or by
using POS tagging on the query, and they are not restricted to adjacent groups of



4.3 Document Parsing 99

TREC data Patent data
Frequency Phrase Frequency Phrase
65824 united states 975362 present invention
61327 article type 191625 u.s. pat
33864 los angeles 147352 preferred embodiment
18062 hong kong 95097 carbon atoms
17788 north korea 87903 group consisting
17308 new york 81809 room temperature
15513 san diego 78458 seq id
15009 orange county 75850 brief description
12869 prime minister 66407 prior art
12799 first time 59828 perspective view
12067 soviet union 58724 first embodiment
10811 russian federation 56715 reaction mixture
9912 united nations 54619 detailed description
8127 southern california 54117 ethyl acetate
7640 south korea 52195 example 1
7620 end recording 52003 block diagram
7524 european union 46299 second embodiment
7436 south africa 41694 accompanying drawings
7362 san francisco 40554 output signal
7086 news conference 37911 first end
6792 city council 35827 second end
6348 middle east 34881 appended claims
6157 peace process 33947 distal end
5955 human rights 32338 cross-sectional view
5837 white house 30193 outer surface

Table 4.9. High-frequency noun phrases from a TREC collection and U.S. patents from
1996

words. The identification of syntactic phrases is replaced by testing word proxim-
ity constraints, such as whether two words occur within a specified text window.
Wedescribe position indexing inChapter 5 and retrievalmodels that exploitword
proximity in Chapter 7.

In applications with large collections and tight constraints on response time,
such as web search, testing word proximities at query time is also likely to be too
slow. In that case, we can go back to identifying phrases in the documents dur-



100 4 Processing Text

ing text processing, but use a much simpler definition of a phrase: any sequence
of n words. This is also known as an n-gram. Sequences of two words are called
bigrams, and sequences of three words are called trigrams. Single words are called
unigrams. N-grams have been used inmany text applications andwewill mention
themagain frequently in this book, particularly in associationwith languagemod-
els (section 7.3). In this discussion, we are focusing onword n-grams, but character
n-grams are also used in applications such as OCR, where the text is “noisy” and
word matching can be difficult (section 11.6). Character n-grams are also used
for indexing languages such as Chinese that have no word breaks (section 4.7).
N-grams, both character and word, are generated by choosing a particular value
for n and then moving that “window” forward one unit (character or word) at
a time. In other words, n-grams overlap. For example, the word “tropical” con-
tains the following character bigrams: tr, ro, op, pi, ic, ca, and al. Indexes based on
n-grams are obviously larger than word indexes.

The more frequently a word n-gram occurs, the more likely it is to correspond
to a meaningful phrase in the language. N-grams of all lengths form a Zipf distri-
bution, with a few common phrases occurring very frequently and a large number
occurring with frequency 1. In fact, the rank-frequency data for n-grams (which
includes single words) fits the Zipf distribution better than words alone. Some of
the most common n-grams will be made up of stopwords (e.g., “and the”, “there
is”) and could be ignored, although as with words, we should be cautious about
discarding information. Our previous example query “to be or not to be” could
certainly make use of n-grams. We could potentially index all n-grams in a doc-
ument text up to a specific length and make them available to the ranking algo-
rithm. This would seem to be an extravagant use of indexing time and disk space
because of the large number of possible n-grams. A document containing 1,000
words, for example, would contain 3,990 instances of word n-grams of length
2 ? n ? 5. Many web search engines, however, use n-gram indexing because
it provides a fast method of incorporating phrase features in the ranking.

Google recentlymade available a file of n-grams derived fromwebpages.18 The
statistics for this sample are shown in Table 4.10. An analysis of n-grams on the
Web (Yang et al., 2007) found that “all rights reserved” was the most frequent
trigram in English, whereas “limited liability corporation” was the most frequent
in Chinese. In both cases, this was due to the large number of corporate sites, but

18 http://googleresearch.blogspot.com/2006/08/all-our-n-gram-are-belong-to-
you.html



4.4 Document Structure and Markup 101

it also indicates that n-grams are not dominated by common patterns of speech
such as “and will be”.

Number of tokens: 1,024,908,267,229
Number of sentences: 95,119,665,584
Number of unigrams: 13,588,391
Number of bigrams: 314,843,401
Number of trigrams: 977,069,902
Number of fourgrams: 1,313,818,354
Number of fivegrams: 1,176,470,663

Table 4.10. Statistics for the Google n-gram sample

4.4 Document Structure and Markup

In database applications, the fields or attributes of database records are a critical
part of searching. Queries are specified in terms of the required values of these
fields. In some text applications, such as email or literature search, fields such as
author and datewill have similar importance and will be part of the query specifi-
cation. In the case of web search, queries usually do not refer to document struc-
ture or fields, but that does not mean that this structure is unimportant. Some
parts of the structure of web pages, indicated by HTML markup, are very signifi-
cant features used by the ranking algorithm.Thedocument parsermust recognize
this structure and make it available for indexing.

As an example, Figure 4.8 shows part of a web page for a Wikipedia19 entry.
The page has some obvious structure that could be used in a ranking algorithm.
Themain heading for the page, “tropical fish”, indicates that this phrase is particu-
larly important. The same phrase is also in bold and italics in the body of the text,
which is further evidence of its importance. Other words and phrases are used as
the anchor text for links and are likely to be good terms to represent the content
of the page.

The HTML source for this web page (Figure 4.9) shows that there is even
more structure that should be represented for search. Each field or element in
HTML is indicated by a start tag (such as <h1>) and an optional end tag (e.g.,

19 The Web encyclopedia, http://en.wikipedia.org/.



102 4 Processing Text

Tropical fish 

From Wikipedia, the free encyclopedia 

Tropical fish include fish found in tropical environments around the world, including 

both freshwater and salt water species. Fishkeepers often use the term tropical fish to 

refer only those requiring fresh water, with saltwater tropical fish referred to as marine

fish.

Tropical fish are popular aquarium fish , due to their often bright coloration. In 

freshwater fish, this coloration typically derives from iridescence, while salt water fish 

are generally pigmented.

Fig. 4.8. Part of a web page from Wikipedia

</h1>).20 Elements can also have attributes (with values), given by attribute_name
= ”value” pairs. The <head> element of an HTML document contains metadata
that is not displayed by a browser. The metadata element for keywords (<meta
name=”keywords”) gives a list of words and phrases that can be used as additional
content terms for the page. In this case, these are the titles of other Wikipedia
pages. The <title>metadata element gives the title for the page (which is different
from the main heading).

The <body> element of the document contains the content that is displayed.
The main heading is indicated by the <h1> tag. Other headings, of different sizes
and potentially different importance, would be indicated by <h2> through <h6>
tags. Terms that should be displayed in bold or italic are indicated by <b> and
<i> tags. Unlike typical database fields, these tags are primarily used for format-
ting and can occur many times in a document. They can also, as we have said, be
interpreted as a tag indicating a word or phrase of some importance.

Links, such as <a href=”/wiki/Fish” title=”Fish”>fish</a>, are very common.They
are the basis of link analysis algorithms such asPageRank (Brin&Page, 1998), but
also define the anchor text. Links and anchor text are of particular importance to
web search and will be described in the next section. The title attribute for a link
is used to provide extra information about that link, although in our example it
is the words in the last part of the URL for the associated Wikipedia page. Web
search engines also make use of the URL of a page as a source of additional meta-
data. The URL for this page is:

http://en.wikipedia.org/wiki/Tropical_fish

20 In XML the end tag is not optional.



4.4 Document Structure and Markup 103

The fact that the words “tropical” and “fish” occur in the URL will increase the
importance of those words for this page. The depth of a URL (i.e., the number
of directories deep the page is) can also be important. For example, the URL
www.ibm.com is more likely to be the home page for IBM than a page with the
URL:

www.pcworld.com/businesscenter/article/698/ibm_buys_apt!

<html> 

<head>

<meta name="keywords" content="Tropical fish, Airstone, Albinism, Algae eater, 

Aquarium, Aquarium fish feeder, Aquarium furniture, Aquascaping, Bath treatment 

(fishkeeping),Berlin Method, Biotope" />   

…

<title>Tropical fish - Wikipedia, the free encyclopedia</title> 

</head>

<body>

 …

<h1 class="firstHeading">Tropical fish</h1> 

…   

<p><b>Tropical fish</b> include <a href="/wiki/Fish" title="Fish">fish</a> found in <a 

href="/wiki/Tropics" title="Tropics">tropical</a> environments around the world, 

including both <a href="/wiki/Fresh_water" title="Fresh water">freshwater</a> and <a 

href="/wiki/Sea_water" title="Sea water">salt water</a> species. <a 

href="/wiki/Fishkeeping" title="Fishkeeping">Fishkeepers</a> often use the term 

<i>tropical fish</i> to refer only those requiring fresh water, with saltwater tropical fish 

referred to as <i><a href="/wiki/List_of_marine_aquarium_fish_species" title="List of 

marine aquarium fish species">marine fish</a></i>.</p> 

<p>Tropical fish are popular <a href="/wiki/Aquarium" title="Aquarium">aquarium</a> 

fish , due to their often bright coloration. In freshwater fish, this coloration typically 

derives from <a href="/wiki/Iridescence" title="Iridescence">iridescence</a>, while salt 

water fish are generally <a href="/wiki/Pigment" title="Pigment">pigmented</a>.</p> 

…

</body></html> 

Fig. 4.9. HTML source for example Wikipedia page

In HTML, the element types are predefined and are the same for all docu-
ments.XML, in contrast, allows each application todefinewhat the element types
are and what tags are used to represent them. XML documents can be described
by a schema, similar to a database schema. XML elements, consequently, are more
closely tied to the semantics of the data than HTML elements. Search applica-



104 4 Processing Text

tions often use XML to record semantic annotations in the documents that are
produced by information extraction techniques, as described in section 4.6. A
document parser for these applications would record the annotations, along with
the other document structure, and make them available for indexing.

The query language XQuery21 has been defined by the database community
for searching structureddata describedusingXML.XQuery supports queries that
specify both structural and content constraints, which raises the issue of whether
a database or information retrieval approach is better for building a search engine
for XML data. We discuss this topic in more detail in section 11.4, but the gen-
eral answer is that it will depend on the data, the application, and the user needs.
For XML data that contains a substantial proportion of text, the information re-
trieval approach is superior. In Chapter 7, we will describe retrieval models that
are designed for text documents that contain both structure and metadata.

4.5 Link Analysis

Links connecting pages are a key component of the Web. Links are a power-
ful navigational aid for people browsing the Web, but they also help search en-
gines understand the relationships between the pages. These detected relation-
ships help search engines rank web pages more effectively. It should be remem-
bered, however, that many document collections used in search applications such
as desktop or enterprise search either do not have links or have very little link
structure. For these collections, link analysis will have no impact on search per-
formance.

As we saw in the last section, a link in a web page is encoded in HTML with
a statement such as:

For more information on this topic, please go to <a
href=”http://www.somewhere.com”>the somewhere page</a>.

When this page appears in yourweb browser, thewords “the somewhere page”
will be displayed differently than regular text, usually underlined or in a different
color (or both).When you click on that link, your browser will then load the web
page http://www.somewhere.com. In this link, “the somewhere page” is called the
anchor text, and http://www.somewhere.com is the destination. Both components
are useful in the ranking process.

21 http://www.w3.org/XML/Query/



4.5 Link Analysis 105

4.5.1 Anchor Text

Anchor text has two properties that make it particularly useful for ranking web
pages. First, it tends to be very short, perhaps two or three words, and those
words often succinctly describe the topic of the linked page. For instance, links
to www.ebay.com are highly likely to contain the word “eBay” in the anchor text.
Many queries are very similar to anchor text in that they are also short topical de-
scriptions of web pages. This suggests a very simple algorithm for ranking pages:
search through all links in the collection, looking for anchor text that is an exact
match for the user’s query. Each time there is a match, add 1 to the score of the
destination page. Pages would then be ranked in decreasing order of this score.
This algorithmhas some glaring faults, not the least of which is how to handle the
query “click here”. More generally, the collection of all the anchor text in links
pointing to a page can be used as an additional text field for that page, and incor-
porated into the ranking algorithm.

Anchor text is usually written by people who are not the authors of the des-
tination page. This means that the anchor text can describe a destination page
from a different perspective, or emphasize the most important aspect of the page
from a community viewpoint.The fact that the link exists at all is a vote of impor-
tance for the destination page. Although anchor text is not mentioned as often
as link analysis algorithms (for example, PageRank) in discussions of web search
engines, TREC evaluations have shown that it is the most important part of the
representation of a page for some types of web search. In particular, it is essential
for searches where the user is trying to find a home page for a particular topic,
person, or organization.

4.5.2 PageRank

There are tens of billions of web pages, but most of them are not very interesting.
Manyof those pages are spamand containnouseful content at all.Other pages are
personal blogs, wedding announcements, or family picture albums. These pages
are interesting to a small audience, but probably not broadly. On the other hand,
there are a few pages that are popular and useful to many people, including news
sites and the websites of popular companies.

The huge size of the Web makes this a difficult problem for search engines.
Suppose a friend had told you to visit the site for eBay, and you didn’t know that
www.ebay.com was the URL to use. You could type “eBay” into a search engine,
but there are millions of web pages that contain the word “eBay”. How can the



106 4 Processing Text

search engine choose the most popular (and probably the correct) one? One very
effective approach is to use the links between web pages as a way to measure pop-
ularity. The most obvious measure is to count the number of inlinks (links point-
ing to a page) for each page and use this as a feature or piece of evidence in the
ranking algorithm. Although this has been shown to be quite effective, it is very
susceptible to spam. Measures based on link analysis algorithms are designed to
provide more reliable ratings of web pages. Of these measures, PageRank, which
is associated with the Google search engine, is most often mentioned.

PageRank is based on the idea of a random surfer (as in web surfer). Imagine
a person named Alice who is using her web browser. Alice is extremely bored, so
she wanders aimlessly betweenweb pages.Her browser has a special “surpriseme”
button at the top that will jump to a random web page when she clicks it. Each
time a web page loads, she chooses whether to click the “surprise me” button or
whether to click one of the links on the web page. If she clicks a link on the page,
she has no preference for any particular link; instead, she just picks one randomly.
Alice is sufficiently bored that she intends to keep browsing the Web like this for-
ever.22

To put this in a more structured form, Alice browses the Web using this algo-
rithm:

1. Choose a random number r between 0 and 1.
2. If r < ?:

• Click the “surprise me” button.
3. If r ? ?:

• Click a link at random on the current page.
4. Start again.

Typically we assume that ? is fairly small, so Alice is much more likely to click
a link than to pick the “surpriseme” button. Even thoughAlice’s path through the
web pages is random, Alice will still see popular pagesmore often than unpopular
ones. That’s because Alice often follows links, and links tend to point to popular
pages. So, we expect that Alice will end up at a university website, for example,
more often than a personal website, but less often than the CNN website.
22 ThePageRank calculation corresponds tofindingwhat is knownas the stationaryprob-

ability distribution of a randomwalk on the graph of theWeb. A randomwalk is a spe-
cial case of aMarkov chain inwhich thenext state (the next page visited) depends solely
on the current state (current page). The transitions that are allowed between states are
all equally probable and are given by the links.



4.5 Link Analysis 107

Suppose that CNN has posted a story that contains a link to a professor’s web
page. Alice now becomes much more likely to visit that professor’s page, because
Alice visits the CNN website frequently. A single link at CNN might influence
Alice’s activity more than hundreds of links at less popular sites, because Alice
visits CNN far more often than those less popular sites.

Because of Alice’s special “surprise me” button, we can be guaranteed that
eventually she will reach every page on the Internet.23 Since she plans to browse
the Web for a very long time, and since the number of web pages is finite, she will
visit every page a very large number of times. It is likely, however, that she will
visit a popular site thousands of times more often than an unpopular one. Note
that if she did not have the “surprise me” button, she would get stuck on pages
that did not have links, pages whose links no longer pointed to any page, or pages
that formed a loop. Links that point to the first two types of pages, or pages that
have not yet been crawled, are called dangling links.

Now suppose that while Alice is browsing, you happened to walk into her
room and glance at the web page on her screen. What is the probability that
she will be looking at the CNN web page when you walk in? That probability
is CNN’s PageRank. Every web page on the Internet has a PageRank, and it is
uniquely determined by the link structure of web pages. As this example shows,
PageRank has the ability to distinguish between popular pages (those with many
incoming links, or those that have links from popular pages) and unpopular ones.
ThePageRank value canhelp search engines sift through themillions of pages that
contain the word “eBay” to find the one that is most popular (www.ebay.com).

Alice would have to click on many billions of links in order for us to get a
reasonable estimate of PageRank, so we can’t expect to compute it by using actual
people. Fortunately, we can compute PageRank in a much more efficient way.

Suppose for the moment that the Web consists of just three pages,A,B, and
C . We will suppose that pageA links to pagesB andC , pageB links to pageC ,
and pageC links to pageA, as shown in Figure 4.10.

The PageRank of page C , which is the probability that Alice will be looking
at this page, will depend on the PageRank of pagesA andB. Since Alice chooses
randomly between links on a given page, if she starts in page A, there is a 50%
chance that she will go to pageC (because there are two outgoing links). Another
way of saying this is that the PageRank for a page is divided evenly between all the

23 The “surprise button” makes the random surfer model an ergodicMarkov chain, which
guarantees that the iterative calculation of PageRank will converge.



108 4 Processing Text

A B

C

Fig. 4.10.A sample “Internet” consisting of just three web pages.The arrows denote links
between the pages.

outgoing links. If we ignore the “surprise me” button, this means that the Page-
Rank of pageC , represented as PR(C), can be calculated as:

PR(C) =
PR(A)

2
+

PR(B)

1

More generally, we could calculate the PageRank for any page u as:

PR(u) =
?
v?Bu

PR(v)

Lv

where Bu is the set of pages that point to u, and Lv is the number of outgoing
links from page v (not counting duplicate links).

There is an obvious problem here: we don’t know the PageRank values for the
pages, because that is what we are trying to calculate. If we start by assuming that
the PageRank values for all pages are the same (1/3 in this case), then it is easy to
see that we could perform multiple iterations of the calculation. For example, in
the first iteration, PR(C) = 0.33/2 + 0.33 = 0.5, PR(A) = 0.33, and PR(B)
= 0.17. In the next iteration, PR(C) = 0.33/2 + 0.17 = 0.33, PR(A) = 0.5,
and PR(B) = 0.17. In the third iteration, PR(C) = 0.42, PR(A) = 0.33, and
PR(B)= 0.25. After a few more iterations, the PageRank values converge to the
final values of PR(C) = 0.4, PR(A) = 0.4, and PR(B) = 0.2.

Ifwe take the “surpriseme” button into account, part of thePageRank for page
C will be due to the probability of coming to that page by pushing the button.
Given that there is a 1/3 chance of going to any page when the button is pushed,



4.5 Link Analysis 109

the contribution to the PageRank for C for the button will be ?/3. This means
that the total PageRank forC is now:

PR(C) =
?

3
+ (1? ?) · (PR(A)

2
+

PR(B)

1
)

Similarly, the general formula for PageRank is:

PR(u) =
?

N
+ (1? ?) ·

?
v?Bu

PR(v)

Lv

whereN is the number of pages being considered. The typical value for ? is 0.15.
This can also be expressed as a matrix equation:

R = TR

where R is the vector of PageRank values and T is the matrix representing the
transition probabilities for the random surfer model. The element Tij represents
the probability of going from page i to page j, and:

Tij =
?

N
+ (1? ?) 1

Li

Those of you familiar with linear algebra may recognize that the solution R is an
eigenvector of the matrix T.

Figure 4.11 shows some pseudocode for computing PageRank.The algorithm
takes a graph G as input. Graphs are composed of vertices and edges, so G =
(V,E). In this case, the vertices are web pages and the edges are links, so the pseu-
docode uses the letters P and L instead. A link is represented as a pair (p, q),
where p and q are the source and destination pages. Dangling links, which are
links where the page q does not exist, are assumed to be removed. Pages with no
outbound links are rank sinks, in that they accumulate PageRank but do not dis-
tribute it. In this algorithm, we assume that these pages link to all other pages in
the collection.

The first step is to make a guess at the PageRank value for each page. Without
any better information, we assume that the PageRank is the same for each page.
Since PageRank values need to sum to 1 for all pages, we assign a PageRank of
1/|P | to each page in the input vector I . An alternative that may produce faster
convergence would be to use a value based on the number of inlinks.



110 4 Processing Text

1: procedure P???R???(G)
2: ? G is the web graph, consisting of vertices (pages) and edges (links).
3: (P,L)? G ? Split graph into pages and links
4: I ? a vector of length |P | ?The current PageRank estimate
5: R? a vector of length |P | ?The resulting better PageRank estimate
6: for all entries Ii ? I do
7: Ii ? 1/|P | ? Start with each page being equally likely
8: end for
9: whileR has not converged do

10: for all entriesRi ? R do
11: Ri ? ?/|P | ? Each page has a ?/|P | chance of random selection
12: end for
13: for all pages p ? P do
14: Q? the set of pages such that (p, q) ? L and q ? P
15: if |Q| > 0 then
16: for all pages q ? Q do
17: Rq ? Rq + (1? ?)Ip/|Q| ? Probability Ip of being at page p
18: end for
19: else
20: for all pages q ? P do
21: Rq ? Rq + (1? ?)Ip/|P |
22: end for
23: end if
24: I ? R ?Update our current PageRank estimate
25: end for
26: end while
27: returnR
28: end procedure

Fig. 4.11. Pseudocode for the iterative PageRank algorithm

In each iteration, we start by creating a result vector, R, and storing ?/|P | in
each entry. This is the probability of landing at any particular page because of a
random jump. The next step is to compute the probability of landing on a page
because of a clicked link. We do that by iterating over each web page in P . At
each page, we retrieve the estimated probability of being at that page, Ip. From
that page, the user has a ? chance of jumping randomly, or 1? ? of clicking on a
link. There are |Q| links to choose from, so the probability of jumping to a page
q ? Q is (1??)Ip/|Q|. We add this quantity to each entryRq . In the event that



4.5 Link Analysis 111

there are no usable outgoing links, we assume that the user jumps randomly, and
therefore the probability (1? ?)Ip is spread evenly among all |P | pages.

To summarize, PageRank is an important example of query-independentmeta-
data that can improve ranking forweb search.Web pages have the samePageRank
value regardless of what query is being processed. Search engines that use Page-
Rank will prefer pages with high PageRank values instead of assuming that all
web pages are equally likely to satisfy a query. PageRank is not, however, as im-
portant in web search as the conventional wisdom holds. It is just one of many
features used in ranking. It does, however, tend to have the most impact on pop-
ular queries, which is a useful property.

The HITS24 algorithm (Kleinberg, 1999) for link analysis was developed at
about the same time as PageRank and has also been very influential. This algo-
rithm estimates the value of the content of a page (the authority value) and the
value of the links to other pages (the hub value). Both values are computed us-
ing an iterative algorithm based solely on the link structure, similar to PageRank.
The HITS algorithm, unlike PageRank, calculates authority and hub values for
a subset of pages retrieved by a given query.25 This can be an advantage in terms
of the impact of the HITS metadata on ranking, but may be computationally in-
feasible for search engines with high query traffic. In Chapter 10, we discuss the
application of the HITS algorithm to finding web communities.

4.5.3 Link Quality

It is well known that techniques such as PageRank and anchor text extraction are
used in commercial search engines, so unscrupulous web page designers may try
to create useless links just to improve the search engine placement of one of their
web pages. This is called link spam. Even typical users, however, can unwittingly
fool simple search engine techniques. A good example of this is with blogs.

Manyblogposts are comments about other blogposts. Suppose authorA reads
a post called b in author B’s blog. Author A might write a new blog post, called
a, which contains a link to post b. In the process of posting, authorAmay post a
trackback to post b in author B’s blog. A trackback is a special kind of comment
that alerts authorB that a reply has been posted in authorA’s blog.

24 Hypertext Induced Topic Search
25 Query-independent versions ofHITS and topic-dependent versions of PageRankhave

also been defined.



112 4 Processing Text

Blog B

Blog A

Post a
Post b

Trackback links

Link

Fig. 4.12. Trackback links in blog postings

As Figure 4.12 shows, a cycle has developed between post a and post b. Post
a links to post b, and post b contains a trackback link to post a. Intuitively we
would say that post b is influential, because author A has decided to write about
it. However, from the PageRank perspective, a and b have links to each other,
and therefore neither is more influential than the other. The trouble here is that
a trackback is a fundamentally different kind of link than one that appears in a
post.

The comments section of a blog can also be a source of link spam. Page authors
may try to promote their own websites by posting links to them in the comments
section of popular blogs. Based on our discussion of PageRank, we know that a
link from a popular website can make another website seem much more impor-
tant. Therefore, this comments section is an attractive target for spammers.

In this case, one solution is for search engine companies to automatically de-
tect these comment sections and effectively ignore the links during indexing. An
even easierway to do this is to askwebsite owners to alter the unimportant links so
that search engines can detect them. This is the purpose behind the rel=nofollow
link attribute.

Most blog software is now designed to modify any link in a blog comment to
contain the rel=nofollow attribute. Therefore, a post like this:



4.6 Information Extraction 113

Come visit my <a href=”http://www.page.com”>web page</a>.

becomes something like this:

Come visit my <a rel=nofollow href=”http://www.page.com”>web page</a>.

The link still appears on the blog, but search engines are designed to ignore all
links marked rel=nofollow. This helps preserve the integrity of PageRank calcula-
tion and anchor text harvesting.

4.6 Information Extraction

Information extraction is a language technology that focuses on extracting struc-
ture from text. Information extraction is used in a number of applications, and
particularly for text data mining. For search applications, the primary use of in-
formation extraction is to identify features that canbe used by the search engine to
improve ranking. Some people have speculated that information extraction tech-
niques could eventually transform text search into a database problem by extract-
ing all of the important information from text and storing it in structured form,
but current applications of these techniques are a very long way from achieving
that goal.

Some of the text processing steps we have already discussed could be consid-
ered information extraction. Identifying noun phrases, titles, or even bolded text
are examples. In each of these cases, a part of the text has been recognized as hav-
ing some special property, and that property can be described using amarkup lan-
guage, such as XML. If a document is already described using HTML or XML,
the recognition of some of the structural features (such as titles) is straightfor-
ward, but others, such as phrases, require additional processing before the feature
can be annotated using the markup language. In some applications, such as when
the documents in the collection are input through OCR, the document has no
markup and even simple structures such as titles must be recognized and anno-
tated.

These types of features are very general, but most of the recent research in in-
formation extraction has been concerned with features that have specific seman-
tic content, such as named entities, relationships, and events. Although all of these
features contain important information, named entity recognition has been used
most often in search applications. A named entity is a word or sequence of words
that is used to refer to something of interest in a particular application. The most



114 4 Processing Text

common examples are people’s names, company or organizationnames, locations,
time and date expressions, quantities, and monetary values. It is easy to come up
with other “entities” that would be important for specific applications. For an e-
commerce application, for example, the recognition of product names andmodel
numbers in web pages and reviews would be essential. In a pharmaceutical appli-
cation, the recognition of drug names, dosages, and medical conditions may be
important. Given the more specific nature of these features, the process of rec-
ognizing them and tagging them in text is sometimes called semantic annotation.
Some of these recognized entities would be incorporated directly into the search
using, for example, facets (see Chapter 6), whereas others may be used as part of
browsing the search results. An example of the latter is the search engine feature
that recognizes addresses in pages and provides links to the appropriate map.

Fred Smith, who lives at 10 Water Street, Springfield, MA, is a long!time 

collector of tropical fish. 

<p ><PersonName><GivenName>Fred</GivenName> <Sn>Smith</Sn> 

</PersonName>, who lives at <address><Street >10 Water Street</Street>, 

<City>Springfield</City>, <State>MA</State></address>, is a long!time 

collector of <b>tropical fish.</b></p> 

Fig. 4.13. Text tagged by information extraction

Figure 4.13 shows a sentence and the corresponding XML markup after us-
ing information extraction. In this case, the extraction was done by a well-known
word processing program.26 In addition to the usual structure markup (<p> and
<b>), a number of tags have been added that indicate which words are part of
named entities. It shows, for example, that an address consisting of a street (“10
Water Street”), a city (“Springfield”), and a state (“MA”) was recognized in the
text.

Twomain approaches have been used to build named entity recognizers: rule-
based and statistical. A rule-based recognizer uses one or more lexicons (lists of
words and phrases) that categorize names. Some example categories would be
locations (e.g., towns, cities, states, countries, places of interest), people’s names
(given names, family names), and organizations (e.g., companies, government

26 Microsoft Word



4.6 Information Extraction 115

agencies, international groups). If these lists are sufficiently comprehensive, much
of the extraction can be done simply by lookup. In many cases, however, rules or
patterns are used to verify an entity name or to findnew entities that are not in the
lists. For example, a pattern such as “<number> <word> street” could be used to
identify street addresses. Patterns such as “<street address>, <city>” or “in <city>”
could be used to verify that the name found in the location lexicon as a city was
indeed a city. Similarly, a pattern such as “<street address>, <city>, <state>” could
also be used to identify new cities or towns that were not in the lexicon. New per-
son names could be recognized by rules such as “<title> <name>”, where <title>
would include words such as “President”, “Mr.”, and “CEO”. Names are generally
easier to extract in mixed-case text, because capitalization often indicates a name,
but many patterns will apply to all lower- or uppercase text as well. Rules incor-
porating patterns are developed manually, often by trial and error, although an
initial set of rules can also be used as seeds in an automated learning process that
can discover new rules.27

A statistical entity recognizer uses a probabilistic model of the words in and
around an entity. A number of different approaches have been used to build these
models, but because of its importance, wewill briefly describe theHiddenMarkov
Model (HMM) approach. HMMs are used for many applications in speech and
language. For example, POS taggers can be implemented using this approach.

4.6.1 Hidden Markov Models for Extraction

One of the most difficult parts of entity extraction is that words can have many
differentmeanings.Theword “Bush”, for example, candescribe a plant or a person.
Similarly, “Marathon” could be the name of a race or a location in Greece. People
tell the difference between these different meanings based on the context of the
word,meaning thewords that surround it. For instance, if “Marathon” is preceded
by “Boston”, the text is almost certainly describing a race. We can describe the
context of a word mathematically by modeling the generation28 of the sequence
of words in a text as a process with the Markov property, meaning that the next
word in the sequence depends on only a small number of the previous words.

27 GATE (http://gate.ac.uk) is an example of an open source toolkit that provides both
an information extraction component and an environment for customizing extraction
for a specific application.

28 We discuss generative models in more detail in Chapter 7.



116 4 Processing Text

More formally, aMarkovModel describes a process as a collectionof stateswith
transitions between them. Each of the transitions has an associated probability.
The next state in the process depends solely on the current state and the transition
probabilities. In a Hidden Markov Model, each state has a set of possible outputs
that can be generated. As with the transitions, each output also has a probability
associated with it.

Figure 4.14 shows a state diagram representing a very simple model for sen-
tence generation that could be used by a named entity recognizer. In this model,
the words in a sentence are assumed to be either part of an entity name (in this
case, either a person, organization, or location) or not part of one. Each of these
entity categories is represented by a state, and after everyword the systemmay stay
in that state (represented by the arrow loops) or transition to another state.There
are two special states representing the start and end of the sentence. Associated
with each state representing an entity category, there is a probability distribution
of the likely sequences of words for that category.

end

start

person
organ-

ization
location

not-an-

entity
<every entity

category>

Fig. 4.14. Sentence model for statistical entity extractor

One possible use of this model is to construct new sentences. Suppose that
we begin in the start state, and then the next state is randomly chosen according



4.6 Information Extraction 117

to the start state’s transition probability table. For example, we may transition to
the person state. Once we have entered the person state, we complete the tran-
sition by choosing an output according to the person state’s output probability
distribution. An example output may be the word “Thomas”. This process would
continue, with a new state being transitioned to and an output being generated
during each step of the process.Thefinal result is a set of states and their associated
outputs.

Although such models can be used to generate new sentences, they are more
commonly used to recognize entities in a sentence. To do this for a given sentence,
a sequence of entity categories is found that gives the highest probability for the
words in that sentence. Only the outputs generated by state transitions are visible
(i.e., can be observed); the underlying states are “hidden.” For the sentence in Fig-
ure 4.13, for example, the recognizer would find the sequence of states

<start><name><not-an-entity><location><not-an-entity><end>

to have the highest probability for that model. The words that were associated
with the entity categories in this sequence would then be tagged. The problem
of finding the most likely sequence of states in an HMM is solved by the Viterbi
algorithm,29 which is a dynamic programming algorithm.

The key aspect of this approach to entity recognition is that the probabili-
ties in the sentence model must be estimated from training data. To estimate the
transition and output probabilities, we generate training data that consists of text
manually annotated with the correct entity tags. From this training data, we can
directly estimate the probability of words associated with a given category (i.e.,
output probabilities), and the probability of transitions between categories. To
build a more accurate recognizer, features that are highly associated with named
entities, such as capitalized words andwords that are all digits, would be included
in the model. In addition, the transition probabilities could depend on the pre-
vious word as well as the previous category.30 For example, the occurrence of the
word “Mr.” increases the probability that the next category is Person.

Although such training data can be useful for constructing accurate HMMs,
collecting it requires a great deal of human effort. To generate approximately one
million words of annotated text, which is the approximate size of training data
required for accurate estimates, people would have to annotate the equivalent of

29 Named after the electrical engineer Andrew Viterbi.
30 Bikel et al. (1997) describe one of the first named entity recognizers based on the

HMM approach.



118 4 Processing Text

more than 1,500 news stories.Thismay require considerably more effort than de-
veloping rules for a simple set of features. Both the rule-based and statistical ap-
proaches have recognition effectiveness of about 90%31 for entities such as name,
organization, and location, although the statistical recognizers are generally the
best. Other entity categories, such as product names, are considerably more diffi-
cult. The choice of which entity recognition approach to use will depend on the
application, the availability of software, and the availability of annotators.

Interestingly, there is little evidence that named entities are useful features
for general search applications. Named entity recognition is a critical part of
question-answering systems (section 11.5), and can be important in domain-
specific or vertical search engines for accurately recognizing and indexing domain
terms. Named entity recognition can also be useful for query analysis in applica-
tions such as local search, and as a tool for understanding and browsing search
results.

4.7 Internationalization

The Web is used all over the world, and not just by English speakers. Although
65–70% of the Web is written in English, that percentage is continuing to de-
crease. More than half of the people who use the Web, and therefore search the
Web, do not use English as their primary language. Other search applications,
such as desktop search and corporate search, are being used in many different
languages every day. Even an application designed for an environment that has
mostly English-speaking users can have many non-English documents in the col-
lection. Try using “poissons tropicaux” (tropical fish) as a query for your favorite
web search engine and see how many French web pages are retrieved.32

Amonolingual search engine is, as the name suggests, a search engine designed
for a particular language.33 Many of the indexing techniques and retrieval models
we discuss in this book work well for any language. The differences between lan-
guages that have the most impact on search engine design are related to the text
processing steps that produce the index terms for searching.
31 By this we mean that about 9 out of 10 of the entities found are accurately identified,

and9out of 10 of the existing entities are found. SeeChapter 8 for details on evaluation
measures.

32 You would find many more French web pages, of course, if you used a French version
of the search engine, such as http://fr.yahoo.com.

33 We discuss cross-language search engines in section 6.4.



4.7 Internationalization 119

As we mentioned in the previous chapter, character encoding is a crucial issue
for search engines dealing with non-English languages, and Unicode has become
the predominant character encoding standard for the internationalization of soft-
ware.

Other text processing steps also need to be customized for different languages.
The importance of stemming for highly inflected languages has already beenmen-
tioned, but each language requires a customized stemmer. Tokenizing is also im-
portant for many languages, especially for the CJK family of languages. For these
languages, the key problem is word segmentation, where the breaks correspond-
ing to words or index terms must be identified in the continuous sequence of
characters (spaces are generally not used). One alternative to segmenting is to in-
dex overlapping character bigrams (pairs of characters, see section 4.3.5). Figure
4.15 shows word segmentation and bigrams for the text “impact of droughts in
China”. Although the ranking effectiveness of search based on bigrams is quite
good, word segmentation is preferred in many applications because many of the
bigrams do not correspond to actual words. A segmentation technique can be im-
plemented based on statistical approaches, such as aHiddenMarkovModel, with
sufficient training data. Segmentation can also be an issue in other languages.Ger-
man, for example, has many compound words (such as “fischzuchttechniken” for
“fish farming techniques”) that should be segmented for indexing.

(the impact of droughts in China)

1. Original text

drought   at     china    make           impact 

2. Word segmentation

3. Bigrams

Fig. 4.15. Chinese segmentation and bigrams

In general, given the tools that are available, it is not difficult to build a search
engine for the major languages. The same statement holds for any language that



120 4 Processing Text

has a significant amount of online text available on theWeb, since this can be used
as a resource to build and test the search engine components. There are, however,
a large number of other so-called “low-density” languages that may have many
speakers but few online resources. Building effective search engines for these lan-
guages is more of a challenge.

References and Further Reading

Theproperties and statistics of text anddocument collections has been studied for
some time under the heading of bibliometrics, which is part of the field of library
and information science. Information science journals such as the Journal of the
American Society of Information Science and Technology ( JASIST) or Information
Processing and Management (IPM) contain many papers in this general area. In-
formation retrieval has, from the beginning, emphasized a statistical view of text,
and researchers from IR and information science have always worked closely to-
gether. Belew (2000) contains a good discussion of the cognitive aspects of Zipf ’s
law and other properties of text in relationship to IR. With the shift to statistical
methods in the 1990s, natural language processing researchers also became inter-
ested in studying the statistical properties of text. Manning and Schütze (1999)
is a good summary of text statistics from this perspective. Ha et al. (2002) give an
interesting result showing that phrases (or n-grams) also generally follow Zipf ’s
law, and that combining the phrases and words results in better predictions for
frequencies at low ranks.

The paper byAnagnostopoulos et al. (2005) describes a technique for estimat-
ing query result size and also points tomuch of the relevant literature in this area.
Similarly, Broder et al. (2006) show how to estimate corpus size and compare
their estimation with previous techniques.

Not much is written about tokenizing or stopping. Both are considered suf-
ficiently “well known” that they are hardly mentioned in papers. As we have
pointed out, however, getting these basic steps right is crucial for the overall sys-
tem’s effectiveness. For many years, researchers used the stopword list published
in van Rijsbergen (1979). When it became clear that this was not sufficient for
the larger TREC collections, a stopword list developed at the University of Mas-
sachusetts and distributed with the Lemur toolkit has frequently been used. As
mentioned previously, this list contains over 400 words, which will be too long
for many applications.



4.7 Internationalization 121

Theoriginal paper describing the Porter stemmerwaswritten in 1979, butwas
reprinted in Porter (1997). The paper by Krovetz (1993) describes his stemming
algorithm but also takes a more detailed approach to studying the role of mor-
phology in a stemmer.34 The Krovetz stemmer is available on the Lemur website.
Stemmers for other languages are available from various websites (including the
Lemur website and the Porter stemmer website). A description of Arabic stem-
ming techniques can be found in Larkey et al. (2002).

Research on the use of phrases in searching has a long history. Croft et al.
(1991) describe retrieval experiments with phrases derived by both syntactic and
statistical processing of the query, and showed that effectiveness was similar to
phrases selectedmanually.Many groups that have participated in the TREC eval-
uations have used phrases as part of their search algorithms (Voorhees&Harman,
2005).

Church (1988) described an approach to building a statistical (or stochastic)
part-of-speech tagger that is the basis for many current taggers. This approach
uses manually tagged training data to train a probabilistic model of sequences of
parts of speech, as well as the probability of a part of speech for a specific word.
For a given sentence, the part-of-speech tagging that gives the highest probability
for the whole sentence is used. This method is essentially the same as that used
by a statistical entity extractor, with the states being parts of speech instead of en-
tity categories.TheBrill tagger (Brill, 1994) is a popular alternative approach that
uses rules that are learned automatically from tagged data. Manning and Schütze
(1999) provide a good overview of part-of-speech tagging methods.

Many variations of PageRank can be found in the literature. Many of these
variations are designed to bemore efficient to compute or are used in different ap-
plications. The topic-dependent version of PageRank is described in Haveliwala
(2002). Both PageRank and HITS have their roots in the citation analysis algo-
rithms developed in the field of bibliometrics.

The idea of enhancing the representation of a hypertext document (i.e., a web
page) using the content of the documents that point to it has been around for
some time. For example, Croft andTurtle (1989) describe a retrieval model based
on incorporating text from related hypertext documents, and Dunlop and van
Rijsbergen (1993) describe how documents with little text content (such as those
containing images) could be retrieved using the text in linked documents. Re-

34 Morphology is the study of the internal structure of words, and stemming is a form of
morphological processing.



122 4 Processing Text

stricting the text that is incorporated to the anchor text associated with inlinks
was first mentioned by McBryan (1994). Anchor text has been shown to be es-
sential for some categories of web search in TREC evaluations, such as in Ogilvie
and Callan (2003).

Techniques have been developed for applying link analysis in collections with-
out explicit link structure (Kurland & Lee, 2005). In this case, the links are based
on similarities between the content of the documents, calculated by a similarity
measure such as the cosine correlation (see Chapter 7).

Information extraction techniques were developed primarily in research pro-
grams such as TIPSTER and MUC (Cowie & Lehnert, 1996). Using named en-
tity extraction to provide additional features for search was also studied early in
the TREC evaluations (Callan et al., 1992, 1995). One of the best-known rule-
based information extraction systems is FASTUS (Hobbs et al., 1997). The BBN
system Identifinder (Bikel et al., 1999), which is based on an HMM, has been
used in many projects.

A detailed description of HMMs and the Viterbi algorithm can be found in
Manning and Schütze (1999). McCallum (2005) provides an overview of infor-
mation extraction, with references tomore recent advances in the field. Statistical
models that incorporate more complex features than HMMs, such as conditional
randomfields, have become increasingly popular for extraction (Sutton&McCal-
lum, 2007).

Detailed descriptions of all the major encoding schemes can be found in
Wikipedia. Fujii and Croft (1993) was one of the early papers that discussed the
problems of text processing for search with CJK languages. An entire journal,
ACMTransactions on Asian Language Information Processing,35 has now been de-
voted to this issue. Peng et al. (2004) describe a statisticalmodel forChineseword
segmentation and give references to other approaches.

Exercises

4.1. Plot rank-frequency curves (using a log-log graph) for words and bigrams in
the Wikipedia collection available through the book website (http://www.search-
engines-book.com). Plot a curve for the combination of the two.What are the best
values for the parameter c for each curve?

35 http://talip.acm.org/



4.7 Internationalization 123

4.2. Plot vocabulary growth for the Wikipedia collection and estimate the pa-
rameters for Heaps’ law. Should the order in which the documents are processed
make any difference?

4.3. Try to estimate the number of web pages indexed by two different search en-
gines using the technique described in this chapter. Compare the size estimates
from a range of queries and discuss the consistency (or lack of it) of these esti-
mates.

4.4. Modify the Galago tokenizer to handle apostrophes or periods in a different
way. Describe the new rules your tokenizer implements. Give examples of where
the new tokenizer does a better job (in your opinion) and examples where it does
not.

4.5. Examine the Lemur stopword list and list 10 words that you think would
cause problems for some queries. Give examples of these problems.

4.6. Process fiveWikipedia documents using the Porter stemmer and theKrovetz
stemmer. Compare the number of stems produced and find 10 examples of dif-
ferences in the stemming that could have an impact on ranking.

4.7. Use the GATE POS tagger to tag a Wikipedia document. Define a rule or
rules to identify phrases and show the top 10most frequent phrases. Now use the
POS tagger on the Wikipedia queries. Are there any problems with the phrases
identified?

4.8. Find the 10 Wikipedia documents with the most inlinks. Show the collec-
tion of anchor text for those pages.

4.9. Compute PageRank for the Wikipedia documents. List the 20 documents
with the highest PageRank values together with the values.

4.10. Figure 4.11 shows an algorithm for computing PageRank. Prove that the
entries of the vector I sum to 1 every time the algorithm enters the loop on line
9.

4.11. Implement a rule-based recognizer for cities (you can choose a subset of
cities to make this easier). Create a test collection that you can scan manually to
find cities mentioned in the text and evaluate your recognizer. Summarize the
performance of the recognizer and discuss examples of failures.



124 4 Processing Text

4.12. Create a small test collection in some non-English language using web
pages. Do the basic text processing steps of tokenizing, stemming, and stopping
using tools from the bookwebsite and from other websites. Show examples of the
index term representation of the documents.



5
Ranking with Indexes

“Must go faster.”

David Levinson, Independence Day

5.1 Overview

As this is a fairly technical book, if you have read this far, you probably understand
something about data structures and how they are used in programs. If you want
to store a list of items, linked lists and arrays are good choices. If you want to
quickly find an item based on an attribute, a hash table is a better choice. More
complicated tasks requiremore complicated structures, such as B-trees or priority
queues.

Why are all these data structures necessary? Strictly speaking, they aren’t.Most
things you want to do with a computer can be done with arrays alone. However,
arrays have drawbacks: unsorted arrays are slow to search, and sorted arrays are
slow at insertion. By contrast, hash tables and trees are fast for both search and
insertion. These structures are more complicated than arrays, but the speed dif-
ference is compelling.

Text search is very different from traditional computing tasks, so it calls for
its own kind of data structure, the inverted index. The name “inverted index” is
really an umbrella term for many different kinds of structures that share the same
general philosophy. As youwill see shortly, the specific kind of data structure used
depends on the ranking function.However, since the ranking functions that rank
documents well have a similar form, the most useful kinds of inverted indexes are
found in nearly every search engine.

This chapter is about how search engine queries are actually processed by a
computer, so this whole chapter could arguably be called query processing. The
last section of this chapter is called that, and the query processing algorithms pre-
sented there are based on the data structures presented earlier in the chapter.



126 5 Ranking with Indexes

Efficient query processing is a particularly important problem in web search,
as it has reached a scale that would have been hard to imagine just 10 years ago.
People all over the world type in over half a billion queries every day, searching
indexes containing billions of web pages. Inverted indexes are at the core of all
modern web search engines.

There are strong dependencies between the separate components of a search
engine. The query processing algorithm depends on the retrieval model, and dic-
tates the contents of the index. This works in reverse, too, since we are unlikely to
choose a retrieval model that has no efficient query processing algorithm. Since
we will not be discussing retrieval models in detail until Chapter 7, we start this
chapter by describing an abstract model of ranking that motivates our choice of
indexes. After that, there are four main parts to the chapter. In the first part, we
discuss the different types of inverted index and what information about docu-
ments is captured in each index. The second part gives an overview of compres-
sion techniques, which are a critical part of the efficient implementation of in-
verted indexes for text retrieval. The third part of the chapter describes how in-
dexes are constructed, including a discussion of the MapReduce framework that
can be used for very large document collections. The final part of the chapter fo-
cuses on how the indexes are used to generate document rankings in response to
queries.

5.2 Abstract Model of Ranking

Beforewebegin to look at how tobuild indexes for a search system,wewill start by
considering an abstract model of ranking. All of the techniques we will consider
in this chapter can be seen as implementations of this model.

Figure 5.1 shows the basic components of our model. On the left side of the
figure is a sample document. Documents are written in natural human languages,
which are difficult for computers to analyze directly. So, as we saw in Chapter 4,
the text is transformed into index terms or document features. For the purposes of
this chapter, a document feature is some attribute of the document we can express
numerically. In the figure, we show two kinds of features. On top, we have topical
features, which estimate the degree to which the document is about a particular
subject. On the bottom of the figure, we see two possible document quality fea-
tures. One feature is the number of web pages that link to this document, and an-
other is the number of days since this page was last updated. These features don’t
address whether the document is a good topical match for a query, but they do



5.2 Abstract Model of Ranking 127

Fred's Tropical Fish Shop is 
the best place to !nd 
tropical !sh at low, low 
prices.  Whether you're 
looking for a little !sh or a 
big !sh, we've got what you 
need.  We even have fake 
seaweed for your !shtank 
(and little sur"oards too).

Document

Topical Features

!sh
tropical
tropical !sh
seaweed
sur"oards

9.7
4.2

22.1
8.2
4.2

Quality Features

incoming links
days since last update

14
3

Ranking Function
Document Score

Query
tropical !sh

24.5

Fig. 5.1.The components of the abstract model of ranking: documents, features, queries,
the retrieval function, and document scores

address its quality: a page with no incoming links that hasn’t been edited in years
is probably a poor match for any query. Each of these feature values is generated
using a feature function, which is just a mathematical expression that generates
numbers from document text. In Chapter 4 we discussed some of the important
topical and quality features, and in Chapter 7 you will learn about the techniques
for creating good feature functions. In this chapter, we assume that reasonable
feature values have already been created.

On the right side of the figure, we see a cloud representing the ranking func-
tion.The ranking function takes data from document features combined with the
query and produces a score. For now, the contents of that cloud are unimportant,
except for the fact thatmost reasonable ranking functions ignoremany of the doc-
ument features, and focus only on the small subset that relate to the query. This
fact makes the inverted index an appealing data structure for search.

The final output of the ranking function is a score, which we assume is some
real number. If a document gets a high score, this means that the system thinks
that document is a good match for the query, whereas lower numbers mean that
the system thinks the document is a poor match for the query. To build a ranked
list of results, the documents are sorted by score so that the highest-scoring doc-
uments come first.

Suppose that you are a human search engine, trying to sort documents in an
appropriate order in response to a user query. Perhaps you would place the docu-
ments in piles, like “good,” “not so good,” and “bad.”The computer is doing essen-
tially the same thing with scoring. However, you might also break ties by looking
carefully at each document to decide which one is more relevant. Unfortunately,



128 5 Ranking with Indexes

finding deep meaning in documents is difficult for computers to do, so search en-
gines focus on identifying good features and scoring based on those features.

A more concrete ranking model

Later in the chapterwewill look at query evaluation techniques that assume some-
thing stronger about what happens in the ranking function. Specifically, we as-
sume that the ranking functionR takes the following form:

R(Q,D) =
?
i

gi(Q)fi(D)

Here, fi is some feature function that extracts a number from the document
text. gi is a similar feature function that extracts a value from the query.These two
functions form a pair of feature functions. Each pair of functions is multiplied
together, and the results from all pairs are added to create a final document score.

Fred's Tropical Fish Shop is 
the best place to !nd 
tropical !sh at low, low 
prices.  Whether you're 
looking for a little !sh or a 
big !sh, we've got what you 
need.  We even have fake 
seaweed for your !shtank 
(and little sur"oards too).

Document

Topical Features

!sh
tropical
tropical !sh
seaweed
sur"oards

9.7
4.2

22.1
8.2
4.2

Quality Features

incoming links
update count

14
3

Document Score

Query
tropical !sh

303.01

tropical !sh
tropical

!sh

chichlids
barbs

5.2
3.4
9.9
1.2
0.7

Topical Features

Quality Features

incoming links 1.2
update count 0.9

fi gi

Fig. 5.2. A more concrete model of ranking. Notice how both the query and the docu-
ment have feature functions in this model.

Figure 5.2 shows an example of this model. Just as in the abstract model of
ranking, various features are extracted from the document. This picture shows
only a few features, but in reality there will be many more. These correspond
to the fi(D) functions in the equation just shown. We could easily name these
ftropical(D) or ffish(D); these values will be larger for documents that contain
the words “tropical” or “fish” more often or more prominently.



5.3 Inverted Indexes 129

The document has some features that are not topical. For this example docu-
ment, we see that the search engine notices that this document has been updated
three times, and that it has 14 incoming links. Although these features don’t tell
us anything about whether this document would match the subject of a query,
they do give us some hints about the quality of the document. We know that it
wasn’t just posted to the Web and then abandoned, since it gets updated occa-
sionally.We also know that there are 14 other pages that have links pointing to it,
which might mean that it has some useful information on it.

Notice that there are also feature functions that act on the query. The feature
function gtropical(Q) evaluates to a large value because “tropical” is in the query.
However, gbarbs(Q) also has a small non-zero value because it is related to other
terms in the query. These values from the query feature functions are multiplied
by the document feature functions, then summed to create a document score.

The query also has some feature values that aren’t topical, such as the update
count feature. Of course, this doesn’t mean that the query has been updated. The
value of this feature indicates how important document updates are to relevance
for this query. For instance, if the querywas “today’s weather in london”, wewould
prefer documents that are updated frequently, since a document that isn’t updated
at least daily is unlikely to say anything interesting about today’s weather. This
query should have a high value for the update count feature. By contrast, a docu-
ment that never changed could be very relevant for the query “full text of moby
dick”. This query could have a low feature value for update count.

If a retrieval system had to perform a sum over millions of features for every
document, text search systems would not be practical. In practice, the query fea-
tures (gi(Q)) are mostly zero. This means that the sum for each document is only
over the non-zero gi(Q) values.

5.3 Inverted Indexes

All modern search engine indexes are based on inverted indexes. Other index
structures have been used in the past, most notably signature files,1 but inverted
indexes are considered the most efficient and flexible index structure.
1 A signature is a concise representation of a block of text (or document) as a sequence
of bits, similar to the fingerprints discussed in Chapter 3. A hash function is used for
each word in the text block to set bits in specific positions in the signature to one.



130 5 Ranking with Indexes

An inverted index is the computational equivalent of the index found in the
back of this textbook. You might want to look over the index in this book as an
example. The book index is arranged in alphabetical order by index term. Each
index term is followed by a list of pages about that word. If you want to know
more about stemming, for example, you would look through the index until you
found words starting with “s”. Then, you would scan the entries until you came to
theword “stemming.”The list of page numbers therewould lead you toChapter 4.

Similarly, an inverted index is organized by index term. The index is inverted
because usually we think of words being a part of documents, but if we invert this
idea, documents are associated with words. Index terms are often alphabetized
like a traditional book index, but they need not be, since they are often found di-
rectly using a hash table. Each index term has its own inverted list that holds the
relevant data for that term. In an index for a book, the relevant data is a list of
page numbers. In a search engine, the data might be a list of documents or a list
of word occurrences. Each list entry is called a posting, and the part of the posting
that refers to a specific document or location is often called a pointer. Each doc-
ument in the collection is given a unique number to make it efficient for storing
document pointers.

Indexes in books store more than just location information. For important
words, often one of the page numbers is marked in boldface, indicating that this
page contains a definition or extended discussion about the term. Inverted files
can also have extended information, where postings can contain a range of in-
formation other than just locations. By storing the right information along with
each posting, the feature functions we saw in the last section can be computed
efficiently.

Finally, by convention, the page numbers in a book index are printed in as-
cending order, so that the smallest page numbers come first. Traditionally, in-
verted lists are stored the same way. These document-ordered lists are ordered by
document number, which makes certain kinds of query processing more efficient
and also improves list compression.However, some inverted files we will consider
have other kinds of orderings.

Alternatives to invertedfiles generally haveoneormoredisadvantages.The sig-
nature file, for example, represents each document in the collection as a small set
of bits. To search a signature file, the query is converted to a signature and the bit
patterns are compared. In general, all signaturesmust be scanned for every search.
Even if the index is encoded compactly, this is a lot of processing. The inverted
file’s advantage is that only a small fraction of the index needs to be considered



5.3 Inverted Indexes 131

to process most queries. Also, matches in signature files are noisy, so a signature
match is not guaranteed to be a match in the document text. Most importantly,
it is difficult to generalize signature file techniques for ranked search (Zobel et al.,
1998).

Another approach is to use spatial data structures, such as k-d trees. In this ap-
proach, eachdocument is encoded as a point in somehigh-dimensional space, and
the query is as well. The spatial data structure can then be used to find the closest
documents to the query. Although many ranking approaches are fundamentally
spatial, most spatial data structures are not designed for the number of dimen-
sions associated with text applications.2 As a result, it tends to be much faster to
use an inverted list to rank documents than to use a typical spatial data structure.

In thenext few sections,wewill look at somedifferent kinds of invertedfiles. In
each case, the inverted file organization is dictated by the ranking function.More
complex ranking functions require more information in the index. These more
complicated indexes take additional space and computational power to process,
but canbe used to generatemore effective document rankings. Index organization
is by no means a solved problem, and research is ongoing into the best way to
create indexes that can more efficiently produce effective document rankings.

5.3.1 Documents

The simplest form of an inverted list stores just the documents that contain each
word, and no additional information. This kind of list is similar to the kind of
index you would find at the back of this textbook.

Figure 5.3 shows an indexof this typebuilt fromthe four sentences inTable 5.1
(so in this case, the “documents” are sentences). The index contains every word
found in all four sentences. Next to each word, there are a list of boxes, and each
one contains the number of a sentence. Each one of these boxes is a posting. For
example, look at the word “fish”. You can quickly see that this word appears in
all four sentences, because the numbers 1, 2, 3, and 4 appear by it. You can also
quickly determine that “fish” is the only word that appears in all the sentences.
Two words come close: “tropical” appears in every sentence but S4, and “water”
is not in S3.
2 Every term in a document corresponds to a dimension, so there are tens of thousands
of dimensions in effect. This is in comparison to a typical database application with
tens of dimensions at most.



132 5 Ranking with Indexes

S1 Tropical fish include fish found in tropical environments around
the world, including both freshwater and salt water species.

S2 Fishkeepers often use the term tropical fish to refer only those
requiring fresh water, with saltwater tropical fish referred to as
marine fish.

S3 Tropical fish are popular aquarium fish, due to their often bright
coloration.

S4 In freshwater fish, this coloration typically derives from irides-
cence, while salt water fish are generally pigmented.

Table 5.1. Four sentences from the Wikipedia entry for tropical fish

and 1
aquarium 3

are 3 4
around 1

as 2
both 1

bright 3
coloration 3 4

derives 4
due 3

environments 1
fish 1 2 3 4

fishkeepers 2
found 1
fresh 2

freshwater 1 4
from 4

generally 4
in 1 4

include 1
including 1

iridescence 4
marine 2

often 2 3

only 2
pigmented 4

popular 3
refer 2

referred 2
requiring 2

salt 1 4
saltwater 2

species 1
term 2

the 1 2
their 3
this 4

those 2
to 2 3

tropical 1 2 3
typically 4

use 2
water 1 2 4
while 4
with 2

world 1

Fig. 5.3. An inverted index for the documents (sentences) in Table 5.1



5.3 Inverted Indexes 133

Notice that this index does not record the number of times eachword appears;
it only records the documents in which each word appears. For instance, S2 con-
tains the word “fish” twice, whereasS1 contains “fish” only once.The inverted list
for “fish” shows no distinction between sentences 1 and 2; both are listed in the
same way. In the next few sections, we will look at indexes that include informa-
tion about word frequencies.

Inverted lists become more interesting when we consider their intersection.
Suppose we want to find the sentence that contains the words “coloration” and
“freshwater”. The inverted index tells us that “coloration” appears in S3 and S4,
while “freshwater” appears inS1 andS4.We can quickly tell that onlyS4 contains
both “coloration” and “freshwater”. Since each list is sorted by sentence number,
finding the intersection of these lists takesO(max(m,n)) time, wherem and n
are the lengths of the two lists.Thealgorithm is the same as inmerge sort.With list
skipping, which we will see later in the chapter, this cost drops toO(min(m,n)).

5.3.2 Counts

Remember that our abstract model of ranking considers each document to be
composed of features. With an inverted index, each word in the index corre-
sponds to a document feature. This feature data can be processed by a ranking
function into a document score. In an inverted index that contains only docu-
ment information, the features are binary, meaning they are 1 if the document
contains a term, 0 otherwise. This is important information, but it is too coarse
to find the best few documents when there are a lot of possible matches.

For instance, consider the query “tropical fish”. Three sentences match this
query: S1, S2, and S3. The data in the document-based index (Figure 5.3) gives
us no reason to prefer any of these sentences over any other.

Now look at the index in Figure 5.4. This index looks similar to the previous
one. We still have the same words and the same number of postings, and the first
number in each posting is the same as in the previous index. However, each post-
ing now has a second number. This second number is the number of times the
word appears in the document. This small amount of additional data allows us to
prefer S2 over S1 and S3 for the query “tropical fish”, since S2 contains “tropical”
twice and “fish” three times.

In this example, it may not be obvious that S2 is much better than S1 or S3,
but in general, word counts can be a powerful predictor of document relevance. In
particular,word counts canhelpdistinguishdocuments that are about a particular



134 5 Ranking with Indexes

and 1:1
aquarium 3:1

are 3:1 4:1
around 1:1

as 2:1
both 1:1

bright 3:1
coloration 3:1 4:1

derives 4:1
due 3:1

environments 1:1
fish 1:2 2:3 3:2 4:2

fishkeepers 2:1
found 1:1
fresh 2:1

freshwater 1:1 4:1
from 4:1

generally 4:1
in 1:1 4:1

include 1:1
including 1:1

iridescence 4:1
marine 2:1

often 2:1 3:1

only 2:1
pigmented 4:1

popular 3:1
refer 2:1

referred 2:1
requiring 2:1

salt 1:1 4:1
saltwater 2:1

species 1:1
term 2:1

the 1:1 2:1
their 3:1
this 4:1

those 2:1
to 2:2 3:1

tropical 1:2 2:2 3:1
typically 4:1

use 2:1
water 1:1 2:1 4:1
while 4:1
with 2:1

world 1:1

Fig. 5.4. An inverted index, with word counts, for the documents in Table 5.1

subject from those that discuss that subject in passing. Imagine two documents,
one about tropical fish and another about tropical islands. The document about
tropical islands would probably contain the word “fish”, but only a few times. On
the other hand, the document about tropical fish would contain the word “fish”
many times. Using word occurrence counts helps us rank the most relevant doc-
ument highest in this example.

5.3.3 Positions

When looking for matches for a query like “tropical fish”, the location of the
words in the document is an important predictor of relevance. Imagine a doc-
ument about food that included a section on tropical fruits followed by a section
on saltwater fish. So far, none of the indexes we have considered contain enough
information to tell us that this document is not relevant. Although a document



5.3 Inverted Indexes 135

and 1,15
aquarium 3,5

are 3,3 4,14

around 1,9
as 2,21

both 1,13
bright 3,11

coloration 3,12 4,5

derives 4,7

due 3,7
environments 1,8

fish 1,2 1,4 2,7 2,18 2,23
3,2 3,6 4,3
4,13

fishkeepers 2,1

found 1,5

fresh 2,13

freshwater 1,14 4,2

from 4,8
generally 4,15

in 1,6 4,1

include 1,3
including 1,12

iridescence 4,9

marine 2,22

often 2,2 3,10
only 2,10

pigmented 4,16
popular 3,4

refer 2,9

referred 2,19
requiring 2,12

salt 1,16 4,11

saltwater 2,16
species 1,18

term 2,5

the 1,10 2,4

their 3,9

this 4,4

those 2,11
to 2,8 2,20 3,8

tropical 1,1 1,7 2,6 2,17 3,1
typically 4,6

use 2,3
water 1,17 2,14 4,12

while 4,10

with 2,15

world 1,11

Fig. 5.5. An inverted index, with word positions, for the documents in Table 5.1

that contains the words “tropical” and “fish” is likely to be relevant, we really want
to know if the document contains the exact phrase “tropical fish”.

To determine this, we can add position information to our index, as in Fig-
ure 5.5. This index shares some structural characteristics with the previous in-
dexes, in that it has the same index terms and each list contains some postings.
These postings, however, are different. Each posting contains twonumbers: a doc-
ument number first, followed by a word position. In the previous indexes, there
was just one posting per document. Now there is one posting per word occur-
rence.

Look at the long list for theword “fish”. In the other indexes, this list contained
just four postings. Now the list contains nine postings. The first two postings tell
us that the word “fish” is the second word and fourth word in S1. The next three
postings tell us that “fish” is the seventh, eighteenth, and twenty-thirdword inS2.



136 5 Ranking with Indexes

tropical 1,1 1,7 2,6 2,17 3,1

fish 1,2 1,4 2,7 2,18 2,23 3,2 3,6 4,3 4,13

Fig. 5.6. Aligning posting lists for “tropical” and “fish” to find the phrase “tropical fish”

This information is most interesting when we look at intersections with other
posting lists. Using an intersection with the list for “tropical”, we find where the
phrase “tropical fish” occurs. In Figure 5.6, the two inverted lists are lined up next
to each other. We see that the word “tropical” is the first word in S1, and “fish” is
the second word in S1, which means that S1 must start with the phrase “tropical
fish”. The word “tropical” appears again as the seventh word in S1, but “fish” does
not appear as the eighth word, so this is not a phrase match. In all, there are four
occurrences of the phrase “tropical fish” in the four sentences.The phrasematches
are easy to see in the figure; they happen at the points where the postings are lined
up in columns.

This same technique can be extended to find longer phrases or more general
proximity expressions, such as “find tropicalwithin 5 words of fish.” Suppose that
the word “tropical” appears at position p. We can then look in the inverted list
for “fish” for any occurrences between position p ? 5 and p + 5. Any of those
occurrences would constitute a match.

5.3.4 Fields and Extents

Real documents are not just lists of words. They have sentences and paragraphs
that separate concepts into logical units. Some documents have titles and head-
ings that provide short summaries of the rest of the content. Special types of doc-
uments have their own sections; for example, every email contains sender infor-
mation and a subject line. All of these are instances of what we will call document
fields, which are sections of documents that carry some kind of semanticmeaning.

It makes sense to include information about fields in the index. For example,
suppose you have a professor named Dr. Brown. Dr. Brown sent you an email
about when course projects are due, but you can’t find it. You can type “brown”
into your email program’s search box, but the result you want will be mixed in
with other uses of the word “brown”, such as BrownUniversity or brown socks. A
search for “brown” in the From: line of the email will focus your search on exactly
what you want.



5.3 Inverted Indexes 137

Field information is useful even when it is not used explicitly in the query. Ti-
tles and headings tend to be good summaries of the rest of a document.Therefore,
if a user searches for “tropical fish”, it makes sense to prefer documents with the
title “Tropical Fish,” even if a document entitled “Mauritius” mentions the words
“tropical” and “fish” more often. This kind of preference for certain document
fields can be integrated into the ranking function.

In order to handle these kinds of searches, the search engine needs to be able to
determine whether a word is in a particular field. One option is to make separate
inverted lists for each kind of document field. Essentially, you could build one
index for document titles, one for document headings, and one for body text.
Searching for words in the title is as simple as searching the title index. However,
finding a word in any section of the document is trickier, since you need to fetch
inverted lists from many different indexes to make that determination.

Another option is to store information in each word posting about where the
word occurred. For instance, we could specify that the number 0 indicates a title
and 1 indicates body text. Each inverted list posting would then contain a 0 or a 1
at the end. This data could be used to quickly determine whether a posting was in
a title, and it would require only one bit per posting. However, if you have more
fields than just a title, the representation will grow.

Both of these suggestions have problems when faced with more complicated
kinds of document structure. For instance, supposewewant to index books. Some
books, like this one, havemore than one author. Somewhere in the XMLdescrip-
tion of this book, you might find:

<author>W. Bruce Croft</author>,
<author>Donald Metzler</author>, and
<author>Trevor Strohman</author>

Suppose you would like to find books by an author named Croft Donald. If
you type the phrase query ”croft donald” into a search engine, should this book
match? The words “croft” and “donald” appear in it, and in fact, they appear next
to each other. However, they are in two distinct author fields. This probably is
not a good match for the query ”croft donald”, but the previous two methods for
dealingwithfields (bits in the posting list, separate indexes) cannotmake this kind
of distinction.

This is where extent lists come in. An extent is a contiguous region of a doc-
ument. We can represent these extents using word positions. For example, if the
title of a book started on the fifth word and ended just before the ninth word,



138 5 Ranking with Indexes

we could encode that as (5,9). For the author text shown earlier, we could write
author: (1,4), (4,6), (7,9). The (1,4) means that the first three words (“W. Bruce
Croft”) constitute the first author, followed by the second author (“DonaldMetz-
ler”), which is two words. The word “and” is not in an author field, but the next
two words are, so the last posting is (7,9).

fish 1,2 1,4 2,7 2,18 2,23 3,2 3,6 4,3 4,13

title 1:(1,3) 2:(1,5) 4:(9,15)

Fig. 5.7.Aligning posting lists for “fish” and title to findmatches of the word “fish” in the
title field of a document.

Figure 5.7 shows how this works in practice. Here we have the same positions
posting list for “fish” that we used in the previous example. We also have an ex-
tent list for the title field. For clarity, there are gaps in the posting lists so that the
appropriate postings line up next to each other. At the very beginning of both
lists, we see that document 1 has a title that contains the first two words (1 and
2, ending just before the third word). We know that this title includes the word
“fish”, because the inverted list for “fish” tells us that “fish” is the second word in
document 1. If the user wants to find documents with the word “fish” in the title,
document 1 is amatch.Document 2 does notmatch, because its title ends just be-
fore the fifth word, but “fish” doesn’t appear until the seventh word. Document
3 apparently has no title at all, so no matches are possible. Document 4 has a title
that starts at the ninth word (perhaps the document begins with a date or an au-
thor declaration), and it does contain the word “fish”. In all, this example shows
two matching documents: 1 and 4.

This concept can be extended to all kinds of fields, such as headings, para-
graphs, or sentences. It can also be used to identify smaller pieces of text with
specific meaning, such as addresses or names, or even just to record which words
are verbs.

5.3.5 Scores

If the inverted lists are going to be used to generate feature function values, why
not just store the value of the feature function?This is certainly possible, and some
very efficient search engines do just this. This approach makes it possible to store
feature function values that would be too computationally intensive to compute



5.3 Inverted Indexes 139

during the query processing phase. It alsomoves complexity out of the query pro-
cessing engine and into the indexing code, where it may be more tolerable.

Let’s make this more concrete. In the last section, there was an example about
how a document with the title “Tropical Fish” should be preferred over a docu-
ment “Mauritius” for the query “tropical fish”, even if the Mauritius document
contains the words “tropical” and “fish” many times. Computing the scores that
reflect this preference requires some complexity at query evaluation time. The
postings for “tropical fish” have to be segregated into groups, so we know which
ones are in the title and which ones aren’t. Then, we have to define some score for
the title postings and the non-title postings andmix those numbers together, and
this needs to be done for every document.

An alternate approach is to store the final value right in the inverted list. We
could make a list for “fish” that has postings like [(1:3.6), (3:2.2)], meaning that
the total feature value for “fish” in document 1 is 3.6, and in document 3 it is 2.2.
Presumably the number 3.6 came from taking into account howmany times “fish”
appeared in the title, in the headings, in large fonts, in bold, and in links to the
document.Maybe the document doesn’t contain theword “fish” at all, but instead
many names of fish, such as “carp” or “trout”. The value 3.6 is then some indicator
of how much this document is about fish.

Storing scores like this both increases and decreases the system’s flexibility. It
increases flexibility because computationally expensive scoring becomes possible,
sincemuch of the hardwork of scoring documents ismoved into the index.How-
ever, flexibility is lost, since we can no longer change the scoringmechanism once
the index is built. More importantly, information about word proximity is gone
in this model, meaning that we can’t include phrase information in scoring unless
we build inverted lists for phrases, too. These precomputed phrase lists require
considerable additional space.

5.3.6 Ordering

So far, we have assumed that the postings of each inverted list would be ordered
by document number. Although this is the most popular option, this is not the
only way to order an inverted list. An inverted list can also be ordered by score,
so that the highest-scoring documents come first.Thismakes sense only when the
lists already store the score, or when only one kind of score is likely to be com-
puted from the inverted list. By storing scores instead of documents, the query
processing engine can focus only on the top part of each inverted list, where the



140 5 Ranking with Indexes

highest-scoring documents are recorded. This is especially useful for queries con-
sisting of a single word. In a traditional document-ordered inverted list, the query
processing engine would need to scan the whole list to find the top k scoring doc-
uments, whereas it would only need to read the first k postings in a score-sorted
list.

5.4 Compression

There aremany differentways to store digital information.Usuallywemake a sim-
ple distinction between persistent and transient storage. We use persistent stor-
age to store things in files and directories that we want to keep until we choose to
delete them.Disks, CDs, DVDs, flashmemory, andmagnetic tape are commonly
used for this purpose. Dynamic RAM (Random Access Memory), on the other
hand, is used to store transient information, which is information we need only
while the computer is running. We expect that when we turn off the computer,
all of that information will vanish.

We can make finer distinctions between types of storage based on speed and
capacity.Magnetic tape is slow, disks are faster, but dynamic RAM is much faster.
Modern computers are so fast that even dynamic RAM isn’t fast enough to keep
up, so microprocessors contain at least two levels of cache memory. The very
fastest kind of memory makes up the processor registers. In a perfect world, we
could use registers or cache memory for all transient storage, but it is too expen-
sive to be practical.

The reality, then, is that modern computers contain a memory hierarchy. At
the top of the hierarchy we have memory that is tiny, but fast. The base consists
of memory that is huge, but slow. The performance of a search engine strongly
depends on how it makes use of the properties of each type of memory.

Compression techniques are the most powerful tool for managing the mem-
ory hierarchy. The inverted lists for a large collection are themselves very large. In
fact, when it includes information about word position and document extents,
the index can be comparable in size3 to the document collection. Compression
allows the same inverted list data to be stored in less space. The obvious ben-
efit is that this could reduce disk or memory requirements, which would save

3 As an example, indexes for TREC collections built using the Indri open source search
engine range from 25–50% of the size of the collection. The lower figure is for a col-
lection of web pages.



5.4 Compression 141

money. More importantly, compression allows data to move up the memory hi-
erarchy. If index data is compressed by a factor of four, we can store four times
more useful data in the processor cache, and we can feed data to the processor
four times faster. On disk, compression also squeezes data closer together, which
reduces seek times. Inmulticore andmultiprocessor systems, wheremany proces-
sors share one memory system, compressing data allows the processors to share
memory bandwidth more efficiently.

Unfortunately, nothing is free. The space savings of compression comes at a
cost: the processor must decompress the data in order to use it. Therefore, it isn’t
enough to pick the compression technique that can store the most data in the
smallest amount of space. In order to increase overall performance, we need to
choose a compression technique that reduces space and is easy to decompress.

To see this mathematically, suppose some processor can process p inverted list
postings per second. This processor is attached to a memory system that can sup-
ply the processorwithm postings each second.Thenumber of postings processed
each second is then min(m, p). If p > m, then the processor will spend some of
its time waiting for postings to arrive from memory. If m > p, the memory sys-
tem will sometimes be idle.

Suppose we introduce compression into the system. Our compression system
has a compression ratio of r, meaning that we can now store r postings in the
same amount of space as one uncompressed posting. This lets the processor read
mr postings each second. However, the processor first needs to decompress each
posting before processing it. This slows processing by a decompression factor,
d, and lets the processor process dp postings each second. Now we can process
min(mr, dp) postings each second.

When we use no compression at all, r = 1 and d = 1. Any reasonable com-
pression technique gives us r > 1, but d < 1. We can see that compression is a
useful performance technique only when the p > m, that is, when the processor
can process inverted list data faster than the memory system can supply it. A very
simple compression scheme will raise r a little bit and reduce d a little bit. A com-
plicated compression scheme will raise r a lot, while reducing d a lot. Ideally we
would like to pick a compression scheme such that min(mr, dp) is maximized,
which should happen whenmr = dp.

In this section, we consider only lossless compression techniques. Lossless tech-
niques store data in less space, but without losing information.There are also lossy
data compression techniques, which are often used for video, images, and audio.
These techniques achieve very high compression ratios (r in our previous discus-



142 5 Ranking with Indexes

sion), but do this by throwing away the least important data. Inverted list prun-
ing techniques, which we discuss later, could be considered a lossy compression
technique, but typically when we talk about compression we mean only lossless
methods.

In particular, our goal with these compression techniques is to reduce the size
of the inverted lists we discussed previously. The compression techniques in this
section are particularly well suited for document numbers, word counts, and doc-
ument position information.

5.4.1 Entropy and Ambiguity

By this point in the book, you have already seen many examples of probability
distributions. Compression techniques are based on probabilities, too. The fun-
damental idea behind compression is to represent common data elements with
short codes while representing uncommon data elements with longer codes. The
inverted lists that we have discussed are essentially lists of numbers, and with-
out compression, each number takes up the same amount of space. Since some of
those numbers are more frequent than others, if we encode the frequent numbers
with short codes and the infrequent numbers with longer codes, we can end up
with space savings.

For example, consider the numbers 0, 1, 2, and 3. We can encode these num-
bers using two binary bits. A sequence of numbers, like:

0, 1, 0, 3, 0, 2, 0

can be encoded in a sequence of binary digits:

00 01 00 10 00 11 00

Note that the spaces in the binary sequence are there to make it clear where each
number starts and stops, and are not actually part of the encoding.

In our example sequence, the number 0 occurs four times, whereas each of the
other numbers occurs just once. We may decide to save space by encoding 0 using
just a single 0 bit. Our first attempt at an encoding might be:

0 01 0 10 0 11 0

This looks very successful because this encoding uses just 10 bits instead of the 14
bits used previously. This encoding is, however, ambiguous, meaning that it is not



5.4 Compression 143

clear how to decode it. Remember that the spaces in the code are only there for
our convenience and are not actually stored. If we add some different spaces, we
arrive at a perfectly valid interpretation of this encoding:

0 01 01 0 0 11 0

which, when decoded, becomes:

0, 1, 1, 0, 0, 3, 0

Unfortunately, this isn’t the data we encoded.The trouble is that whenwe see 010
in the encoded data, we can’t be sure whether (0, 2) or (1, 0) was encoded.

The uncompressed encoding was not ambiguous. We knew exactly where to
put the spaces because we knew that each number took exactly 2 bits. In our com-
pressed code, encoded numbers consume either 1 or 2 bits, so it is not clear where
to put the spaces. To solve this problem, we need to restrict ourselves to unam-
biguous codes, which are confusingly called both prefix codes and prefix-free codes.
An unambiguous code is one where there is only one valid way to place spaces in
encoded data.

Let’s fix our code so that it is unambiguous:

Number Code
0 0
1 101
2 110
3 111

This results in the following encoding:

0 101 0 111 0 110 0

This encoding requires 13 bits instead of the 14 bits required by the uncom-
pressed version, so we are still saving some space. However, unlike the last code
we considered, this one is unambiguous. Notice that if a code starts with 0, it con-
sumes 1 bit; if a code starts with 1, it is 3 bits long. This gives us a deterministic
algorithm for placing spaces in the encoded stream.

In the “Exercises” section, you will prove that there is no such thing as an un-
ambiguous code that can compress every possible input; some inputs will get big-
ger. This is why it is so important to know something about what kind of data we



144 5 Ranking with Indexes

want to encode. In our example, we notice that the number 0 appears frequently,
and we can use that fact to reduce the amount of space that the encoded version
requires. Entropy measures the predictability of the input. In our case, the input
seems somewhat predictable, because the number 0 is more likely to appear than
other numbers. We leverage this entropy to produce a usable code for our pur-
poses.

5.4.2 Delta Encoding

All of the coding techniques we will consider in this chapter assume that small
numbers are more likely to occur than large ones. This is an excellent assump-
tion for word count data; many words appear just once in a document, and some
appear two or three times. Only a small number of words appear more than 10
times. Therefore, it makes sense to encode small numbers with small codes and
large numbers with large codes.

However, document numbers do not share this property. We expect that a
typical inverted list will contain some small document numbers and some very
large document numbers. It is true that some documents contain more words,
and therefore will appear more times in the inverted lists, but otherwise there is
not a lot of entropy in the distribution of document numbers in inverted lists.

The situation is different if we consider the differences between document
numbers instead of the document numbers themselves. Remember that inverted
list postings are typically ordered by document number. An inverted list without
counts, for example, is just a list of document numbers, like these:

1, 5, 9, 18, 23, 24, 30, 44, 45, 48

Since these documentnumbers are ordered,weknow that eachdocumentnumber
in the sequence is more than the one before it and less than the one after it. This
fact allows us to encode the list of numbers by the differences between adjacent
document numbers:

1, 4, 4, 9, 5, 1, 6, 14, 1, 3

This encoded list starts with 1, indicating that 1 is the first document number.The
next entry is 4, indicating that the second document number is 4 more than the
first: 1 + 4 = 5. The third number, 4, indicates that the third document number
is 4 more than the second: 5 + 4 = 9.

This process is called delta encoding, and the differences are often called d-gaps.
Notice that delta encoding does not define the bit patterns that are used to store



5.4 Compression 145

the data, and so it does not save any space on its own. However, delta encoding is
particularly successful at changing an ordered list of numbers into a list of small
numbers. Since we are about to discuss methods for compressing lists of small
numbers, this is a useful property.

Before we move on, consider the inverted lists for the words “entropy” and
“who.” The word “who” is very common, so we expect that most documents will
contain it. When we use delta encoding on the inverted list for “who,” we would
expect to see many small d-gaps, such as:

1, 1, 2, 1, 5, 1, 4, 1, 1, 3, ...

By contrast, the word “entropy” rarely appears in text, so only a few documents
will contain it. Therefore, we would expect to see larger d-gaps, such as:

109, 3766, 453, 1867, 992, ...

However, since “entropy” is a rare word, this list of large numbers will not be very
long. In general, we will find that inverted lists for frequent terms compress very
well, whereas infrequent terms compress less well.

5.4.3 Bit-Aligned Codes

The code we invented in section 5.4.1 is a bit-aligned code, meaning that the
breaks between the coded regions (the spaces) can happen after any bit posi-
tion. In this section we will describe some popular bit-aligned codes. In the next
section, we will discuss methods where code words are restricted to end on byte
boundaries. In all of the techniques we’ll discuss, we are looking at ways to store
small numbers in inverted lists (such as word counts, word positions, and delta-
encoded document numbers) in as little space as possible.

One of the simplest codes is the unary code. You are probably familiar with bi-
nary, which encodes numbers with two symbols, typically 0 and 1. A unary num-
ber system is a base-1 encoding, which means it uses a single symbol to encode
numbers. Here are some examples:

Number Code
0 0
1 10
2 110
3 1110
4 11110
5 111110



146 5 Ranking with Indexes

In general, to encode a number k in unary, we output k 1s, followed by a 0.We
need the 0 at the end to make the code unambiguous.

This code is very efficient for small numbers such as 0 and 1, but quickly be-
comes very expensive. For instance, the number 1023 can be represented in 10
binary bits, but requires 1024 bits to represent in unary code.

Now we know about two kinds of numeric encodings. Unary is convenient
because it is compact for small numbers and is inherently unambiguous. Binary
is a better choice for large numbers, but it is not inherently unambiguous. A rea-
sonable compression scheme needs to encode frequent numbers with fewer bits
than infrequent numbers, which means binary encoding is not useful on its own
for compression.

Elias-? codes

The Elias-? (Elias gamma) code combines the strengths of unary and binary
codes. To encode a number k using this code, we compute two quantities:

• kd = ?log2 k?
• kr = k ? 2?log2 k?

Suppose youwrotek in binary form.Thefirst value,kd, is thenumber of binary
digits you would need to write. Assuming k > 0, the leftmost binary digit of k is
1. If you erase that digit, the remaining binary digits are kr .

If we encode kd in unary and kr in binary (in kd binary digits), we get the
Elias-? code. Some examples are shown in Table 5.2.

Number (k) kd kr Code
1 0 0 0
2 1 0 10 0
3 1 1 10 1
6 2 2 110 10

15 3 7 1110 111
16 4 0 11110 0000

255 7 127 11111110 1111111
1023 9 511 1111111110 111111111
Table 5.2. Elias-? code examples



5.4 Compression 147

Thetrickwith this code is that the unary part of the code tells us howmanybits
to expect in the binary part.We end upwith a code that uses nomore bits than the
unary code for any number, and for numbers larger than 2, it uses fewer bits. The
savings for large numbers is substantial. We can, for example, now encode 1023
in 19 bits, instead of 1024 using just unary code.

For any number k, the Elias-? code requires ?log2k?+ 1 bits for kd in unary
code and ?log2k? bits for kr in binary. Therefore, 2?log2k?+1 bits are required
in all.

Elias-? codes

Although the Elias-? code is a major improvement on the unary code, it is not
ideal for inputs that might contain large numbers. We know that a number k can
be expressed in log2 k binary digits, but the Elias-? code requires twice as many
bits in order to make the encoding unambiguous.

The Elias-? code attempts to solve this problem by changing the way that kd
is encoded. Instead of encoding kd in unary, we can encode kd + 1 in Elias-?. In
particular, we split kd into:

• kdd = ?log2(kd + 1)?
• kdr = (kd + 1)? 2?log2(kd+1)?

Notice that we use kd + 1 here, since kd may be zero, but log2 0 is undefined.
We then encodekdd in unary,kdr in binary, andkr in binary.Thevalue ofkdd is

the length ofkdr, andkdr is the length ofkr, whichmakes this code unambiguous.
Table 5.3 gives some examples of Elias-? encodings.

Number (k) kd kr kdd kdr Code
1 0 0 0 0 0
2 1 0 1 0 10 0 0
3 1 1 1 0 10 0 1
6 2 2 1 1 10 1 10

15 3 7 2 0 110 00 111
16 4 0 2 1 110 01 0000

255 7 127 3 0 1110 000 1111111
1023 9 511 3 2 1110 010 111111111

Table 5.3. Elias-? code examples



148 5 Ranking with Indexes

Elias-? sacrifices some efficiency for small numbers in order to gain efficiency
at encoding larger numbers. Notice that the code for the number 2 has increased
to 4 bits instead of the 3 bits required by the Elias-? code. However, for numbers
larger than 16, the Elias-? code requires nomore space than the Elias-? code, and
for numbers larger than 32, the Elias-? requires less space.

Specifically, the Elias-? code requires ?log2(?log2 k?+1)?+1 bits for kdd in
unary, followed by ?log2(?log2 k?+ 1)? bits for kdr in binary, and ?log2 k? bits
for kr in binary. The total cost is approximately 2 log2 log2 k + log2 k.

5.4.4 Byte-Aligned Codes

Even though a few tricks can help us decode bit-aligned codes quickly, codes of
variable bit length are cumbersome on processors that process bytes. The proces-
sor is built to handle bytes efficiently, not bits, so it stands to reason that byte-
aligned codes would be faster in practice.

There are many examples of byte-aligned compression schemes, but we con-
sider only one popular method here. This is the code commonly known as v-byte,
which is an abbreviation for “variable byte length.” The v-byte method is very
similar to UTF-8 encoding, which is a popular way to represent text (see section
3.5.1).

Like the other codeswe have studied so far, the v-bytemethod uses short codes
for small numbers and longer codes for longer numbers. However, each code is a
series of bytes, not bits. So, the shortest v-byte code for a single integer is one byte.
In some circumstances, this could be very space-inefficient; encoding the number
1 takes eight times as much space in v-byte as in Elias-?. Typically, the difference
in space usage is not quite so dramatic.

The v-byte code is really quite simple. The low seven bits of each byte con-
tain numeric data in binary. The high bit is a terminator bit. The last byte of each
code has its high bit set to 1; otherwise, it is set to 0. Any number that can be
represented in seven binary digits requires one byte to encode. More information
about space usage is shown in Table 5.4.

Some example encodings are shown in Table 5.5. Numbers less than 128 are
stored in a single byte in traditional binary form, except that the high bit is set.
For larger numbers, the least significant seven bits are stored in the first byte. The
next seven bits are stored in the next byte until all of the non-zero bits have been
stored.

Storing compressed data with a byte-aligned code has many advantages over a
bit-aligned code. Byte-aligned codes compress and decompress faster, since pro-



5.4 Compression 149

k Number of bytes
k < 27 1
27 ? k < 214 2
214 ? k < 221 3
221 ? k < 228 4

Table 5.4. Space requirements for numbers encoded in v-byte

k Binary Code Hexadecimal
1 1 0000001 81
6 1 0000110 86

127 1 1111111 FF
128 0 0000001 1 0000000 01 80
130 0 0000001 1 0000010 01 82

20000 0 0000001 0 0011100 1 0100000 01 1C A0
Table 5.5. Sample encodings for v-byte

cessors (andprogramming languages) are designed to process bytes instead of bits.
For these reasons, the Galago search engine associated with this book uses v-byte
exclusively for compression.

5.4.5 Compression in Practice

The compression techniques we have covered are used to encode inverted lists in
real retrieval systems. In this section, we’ll look at how Galago uses compression
to encode inverted lists in the PositionListWriter class.

Figure 5.5 illustrates how position information can be stored in inverted lists.
Consider just the inverted list for tropical:

(1, 1)(1, 7)(2, 6)(2, 17)(3, 1)

In each pair, the first number represents the document and the second number
represents the word position. For instance, the third entry in this list states that
the word tropical is the sixth word in document 2. Because it helps the example,
we’ll add (2, 197) to the list:

(1, 1)(1, 7)(2, 6)(2, 17)(2, 197)(3, 1)



150 5 Ranking with Indexes

Wecangroup thepositions for eachdocument together so that eachdocument
has its own entry, (document, count, [positions]), where count is the number of
occurrences in the document. Our example data now looks like this:

(1, 2, [1, 7])(2, 3, [6, 17, 197])(3, 1, [1])

Theword count is important because itmakes this list decipherable evenwith-
out the parentheses and brackets.The count tells us howmany positions liewithin
the brackets, and we can interpret these numbers unambiguously, even if they
were printed as follows:

1, 2, 1, 7, 2, 3, 6, 17, 197, 3, 1, 1

However, we will leave the brackets in place for now for clarity.
These are small numbers, but with delta encoding we can make them smaller.

Notice that the document numbers are sorted in ascending order, so we can safely
use delta encoding to encode them:

(1, 2, [1, 7])(1, 3, [6, 17, 197])(1, 1, [1])

The second entry now starts with a 1 instead of a 2, but this 1 means “this
document number is one more than the last document number.” Since position
information is also sorted in ascending order, we can delta-encode the positions
as well:

(1, 2, [1, 6])(1, 3, [6, 11, 180])(1, 1, [1])

Wecan’t delta-encode theword counts, because they’re not in ascending order.
If we did delta-encode them, some of the deltas might be negative, and the com-
pression techniques we have discussed do not handle negative numbers without
some extra work.

Now we can remove the brackets and consider this inverted list as just a list of
numbers:

1, 2, 1, 6, 1, 3, 6, 11, 180, 1, 1, 1

Since most of these numbers are small, we can compress them with v-byte to
save space:

81 82 81 86 81 83 86 8B 01 B4 81 81 81



5.4 Compression 151

The 01 B4 is 180, which is encoded in two bytes.The rest of the numbers were
encoded as single bytes, giving a total of 13 bytes for the entire list.

5.4.6 Looking Ahead

This section described three compression schemes for inverted lists, and there are
many others in common use. Even though compression is one of the older areas
of computer science, new compression schemes are developed every year.

Why are these new schemes necessary?Remember at the beginning of this sec-
tion we talked about how compression allows us to trade processor computation
for data throughput.Thismeans that the best choice for a compression algorithm
is tightly coupledwith the state ofmodernCPUs andmemory systems. For a long
time, CPU speed was increasing much faster than memory throughput, so com-
pression schemes with higher compression ratios became more attractive. How-
ever, the dominant hardware trend now is toward many CPU cores with lower
clock speeds.Depending on thememory throughput of these systems, lower com-
pression ratios may be attractive.

More importantly, modern CPUs owe much of their speed to clever tricks
such as branch prediction, which helps the processor guess about how code will
execute. Code that is more predictable can run much faster than unpredictable
code. Many of the newest compression schemes are designed to make the decode
phase more predictable, and therefore faster.

5.4.7 Skipping and Skip Pointers

For many queries, we don’t need all of the information stored in a particular in-
verted list. Instead, it would bemore efficient to read just the small portion of the
data that is relevant to the query. Skip pointers help us achieve that goal.

Consider the Boolean query “galago AND animal”. The word “animal” occurs
in about 300 million documents on the Web versus approximately 1 million for
“galago.” If we assume that the inverted lists for “galago” and “animal” are in doc-
ument order, there is a very simple algorithm for processing this query:

• Let dg be the first document number in the inverted list for “galago.”
• Let da be the first document number in the inverted list for “animal.”
• While there are still documents in the lists for “galago” and “animal,” loop:

– If dg < da, set dg to the next document number in the “galago” list.
– If da < dg , set da to the next document number in the “animal” list.



152 5 Ranking with Indexes

– If da = dg , the document da contains both “galago” and “animal”. Move
both dg and da to the next documents in the inverted lists for “galago” and
“animal,” respectively.

Unfortunately, this algorithm is very expensive. It processes almost all docu-
ments in both inverted lists, so we expect the computer to process this loop about
300 million times. Over 99% of the processing time will be spent processing the
299 million documents that contain “animal” but do not contain “galago.”

We can change this algorithm slightly by skipping forward in the “animal” list.
Every time we find that da < dg , we skip ahead k documents in the “animal” list
to a new document, sa. If sa < dg , we skip ahead by another k documents. We
do this until sa ? dg . At this point, we have narrowed our search down to a range
of k documents that might contain dg , which we can search linearly.

How much time does the modified algorithm take? Since the word “galago”
appears 1 million times, we know that the algorithm will perform 1 million lin-
ear searches of length k, giving an expected cost of 500, 000 × k steps. We also
expect to skip forward 300, 000, 000/k times. This algorithm then takes about
500, 000× k + 300, 000, 000/k steps in total.

k Steps
5 62.5 million

10 35 million
20 25 million
25 24.5 million
40 27.5 million
50 31 million

100 53 million
Table 5.6. Skip lengths (k) and expected processing steps

Table 5.6 shows the number of processing steps required for some example
values of k.We get the best expected performance when we skip 25 documents at
a time. Notice that at this value of k, we expect to have to skip forward 12 times
in the “animal” list for each occurrence of “galago.” This is because of the cost of
linear search: a larger value ofkmeansmore elements to check in the linear search.
If we choose a binary search instead, the best value of k rises to about 208, with
about 9.2 million expected steps.



5.4 Compression 153

If binary search combined with skipping is so much more efficient, why even
consider linear search at all? The problem is compression. For binary search to
work, we need to be able to jump directly to elements in the list, but after com-
pression, every element could take a different amount of space. In addition, delta
encoding may be used on the document numbers, meaning that even if we could
jump to a particular location in the compressed sequence, we would need to de-
compress everything up to that point in order to decode the document numbers.
This is discouraging because our goal is to reduce the amount of the list we need
to process, and it seems that compression forces us to decompress the whole list.

We can solve the compressionproblemwith a list of skip pointers. Skip pointer
lists are small additional data structures built into the index to allow us to skip
through the inverted lists efficiently.

A skip pointer (d, p) contains two parts, a document number d and a byte
(or bit) position p. This means that there is an inverted list posting that starts at
position p, and that the posting immediately before it is for document d. Notice
that this definition of the skip pointer solves both of our compression problems:
we can start decoding at position p, and since we know that d is the document
immediately preceding p, we can use it for decoding.

As a simple example, consider the following list of document numbers, un-
compressed:

5, 11, 17, 21, 26, 34, 36, 37, 45, 48, 51, 52, 57, 80, 89, 91, 94, 101, 104, 119

If we delta-encode this list, we end up with a list of d-gaps like this:

5, 6, 6, 4, 5, 9, 2, 1, 8, 3, 3, 1, 5, 23, 9, 2, 3, 7, 3, 15

We can then add some skip pointers for this list, using 0-based positions (that
is, the number 5 is at position 0 in the list):

(17, 3), (34, 6), (45, 9), (52, 12), (89, 15), (101, 18)

Suppose we try decoding using the skip pointer (34, 6). We move to position
6 in the d-gaps list, which is the number 2. We add 34 to 2, to decode document
number 36.

More generally, if we want to find document number 80 in the list, we scan
the list of skip pointers until we find (52, 12) and (89, 15). 80 is larger than 52
but less than 89, so we start decoding at position 12. We find:



154 5 Ranking with Indexes

• 52 + 5 = 57
• 57 + 23 = 80

At this point, we have successfully found 80 in the list. If instead we were
searching for 85, we would again start at skip pointer (52, 12):

• 52 + 5 = 57
• 57 + 23 = 80
• 80 + 9 = 89

At this point, since 85 < 89, we would know that 85 is not in the list.
In the analysis of skip pointers for the “galago AND animal” example, the effec-

tiveness of the skip pointers depended on the fact that “animal” was much more
common than “galago.”We found that 25 was a good value for k given this query,
but we only get to choose one value for k for all queries. The best way to choose
k is to find the best possible k for some realistic sample set of queries. For most
collections and query loads, the optimal skip distance is around 100 bytes.

5.5 Auxiliary Structures

The inverted file is the primary data structure in a search engine, but usually other
structures are necessary for a fully functional system.

Vocabulary and statistics

An inverted file, as described in this chapter, is just a collection of inverted lists.
To search the index, some kind of data structure is necessary to find the inverted
list for a particular term. The simplest way to solve this problem is to store each
inverted list as a separate file, where each file is named after the corresponding
search term. To find the inverted list for “dog,” the system can simply open the file
named dog and read the contents. However, as we saw in Chapter 4, document
collections can havemillions of unique words, andmost of these words will occur
only once or twice in the collection. This means that an index, if stored in files,
would consist of millions of files, most of which are very small.

Unfortunately, modern file systems are not optimized for this kind of stor-
age. A file system typically will reserve a few kilobytes of space for each file, even
thoughmost files will contain just a few bytes of data.The result is a huge amount
of wasted space. As an example, in the AP89 collection, over 70,000 words occur



5.5 Auxiliary Structures 155

just once (see Table 4.1). These inverted lists would require about 20 bytes each,
for a total of about 2MB of space. However, if the file system requires 1KB for
each file, the result is 70MBof space used to store 2MBof data. In addition,many
file systems still store directory information in unsorted arrays, meaning that file
lookups can be very slow for large file directories.

To fix these problems, inverted lists are usually stored together in a single file,
which explains the name inverted file. An additional directory structure, called
the vocabulary or lexicon, contains a lookup table from index terms to the byte
offset of the inverted list in the inverted file.

In many cases, this vocabulary lookup table will be small enough to fit into
memory. In this case, the vocabulary data can be stored in any reasonable way on
disk and loaded into a hash table at search engine startup. If the search engine
needs to handle larger vocabularies, some kind of tree-based data structure, such
as a B-tree, should be used to minimize disk accesses during the search process.

Galago uses a hybrid strategy for its vocabulary structure. A small file in each
index, called vocabulary, stores an abbreviated lookup table from vocabulary
terms to offsets in the inverted file. This file contains just one vocabulary entry
for each 32K of data in the inverted file. Therefore, a 32TB inverted file would
require less than 1GB of vocabulary space, meaning that it can always be stored
in memory for collections of a reasonable size. The lists in the inverted file are
stored in alphabetical order. To find an inverted list, the search engine uses bi-
nary search to find the nearest entry in the vocabulary table, and reads the offset
from that entry. The engine then reads 32KB of the inverted file, starting at the
offset. This approach finds each inverted list with just one disk seek.

To compute some feature functions, the index needs to contain certain vo-
cabulary statistics, such as the term frequency or document frequency (discussed
in Chapter 4). When these statistics pertain to a specific term, they can be eas-
ily stored at the start of the inverted list. Some of these statistics pertain to the
corpus, such as the total number of documents stored. When there are just a few
of these kinds of statistics, efficient storage considerations can be safely ignored.
Galago stores these collection-wide statistics in an XML file called manifest.

Documents, snippets, and external systems

The search engine, as described so far, returns a list of document numbers and
scores. However, a real user-focused search engine needs to display textual infor-
mation about each document, such as a document title, URL, or text summary



156 5 Ranking with Indexes

(Chapter 6 explains this in more detail). In order to get this kind of information,
the text of the document needs to be retrieved.

In Chapter 3, we saw some ways that documents can be stored for fast access.
There aremanyways to approach this problem, but in the end, a separate system is
necessary to convert search engine results from numbers into something readable
by people.

5.6 Index Construction

Before an index can be used for query processing, it has to be created from the text
collection. Building a small index is not particularly difficult, but as input sizes
grow, some index construction tricks can be useful. In this section, we will look at
simple in-memory index construction first, and then consider the case where the
input data does not fit in memory. Finally, we will consider how to build indexes
using more than one computer.

5.6.1 Simple Construction

Pseudocode for a simple indexer is shown in Figure 5.8.The process involves only
a few steps. A list of documents is passed to the BuildIndex function, and the
function parses each document into tokens, as discussed in Chapter 4. These to-
kens are words, perhaps with some additional processing, such as downcasing or
stemming. The function removes duplicate tokens, using, for example, a hash ta-
ble. Then, for each token, the function determines whether a new inverted list
needs to be created in I , and creates one if necessary. Finally, the current docu-
ment number, n, is added to the inverted list.

The result is a hash table of tokens and inverted lists. The inverted lists are
just lists of integer document numbers and contain no special information. This
is enough to do very simple kinds of retrieval, as we saw in section 5.3.1.

As described, this indexer can be used for many small tasks—for example, in-
dexing less than a few thousand documents. However, it is limited in two ways.
First, it requires that all of the inverted lists be stored in memory, which may not
be practical for larger collections. Second, this algorithm is sequential, with no
obvious way to parallelize it.The primary barrier to parallelizing this algorithm is
the hash table, which is accessed constantly in the inner loop. Adding locks to the
hash table would allow parallelism for parsing, but that improvement alone will



5.6 Index Construction 157

procedure B????I????(D) ?D is a set of text documents
I ? HashTable() ? Inverted list storage
n? 0 ?Document numbering
for all documents d ? D do

n? n+ 1
T ? Parse(d) ? Parse document into tokens
Remove duplicates from T
for all tokens t ? T do

if It ?? I then
It ? Array()

end if
It.append(n)

end for
end for
return I

end procedure

Fig. 5.8. Pseudocode for a simple indexer

not be enough to make use of more than a handful of CPU cores. Handling large
collections will require less reliance on memory and improved parallelism.

5.6.2 Merging

The classic way to solve the memory problem in the previous example is bymerg-
ing. We can build the inverted list structure I until memory runs out. When that
happens, we write the partial index I to disk, then start making a new one. At the
end of this process, the disk is filled with many partial indexes, I1, I2, I3, ..., In.
The system then merges these files into a single result.

By definition, it is not possible to hold even two of the partial index files in
memory at one time, so the input files need to be carefully designed so that they
can bemerged in small pieces. One way to do this is to store the partial indexes in
alphabetical order. It is then possible for a merge algorithm to merge the partial
indexes using very little memory.

Figure 5.9 shows an example of this kind of merging procedure. Even though
this figure shows only two indexes, it is possible to merge many at once.The algo-
rithm is essentially the same as the standard merge sort algorithm. Since both I1
and I2 are sorted, at least one of them points to the next piece of data necessary
to write to I . The data from the two files is interleaved to produce a sorted result.



158 5 Ranking with Indexes

aardvark 2 apple

aardvark actor 15 42 68

3 4 5 2 4

6 9

aardvark 2 appleactor 15 42 683 4 5 2 46 9

Index A

Index B

Combined index

aardvark 2 apple

aardvark actor 15 42 68

3 4 5 2 4

6 9

Index A

Index B

Fig. 5.9.An example of index merging. The first and second indexes are merged together
to produce the combined index.

Since I1 and I2 may have used the same document numbers, the merge function
renumbers documents in I2.

Thismerging process can succeed even if there is only enoughmemory to store
two words (w1 and w2), a single inverted list posting, and a few file pointers. In
practice, a real merge function would read large chunks of I1 and I2, and then
write large chunks to I in order to use the disk most efficiently.

This merging strategy also shows a possible parallel indexing strategy. If many
machines build their own partial indexes, a single machine can combine all of
those indexes together into a single, final index. However, in the next section,
we will explore more recent distributed indexing frameworks that are becoming
popular.

5.6.3 Parallelism and Distribution

The traditional model for search engines has been to use a single, fast machine to
create the index and process queries. This is still the appropriate choice for a large
number of applications, but it is no longer a good choice for the largest systems.
Instead, for these large systems, it is increasingly popular to use many inexpen-
sive servers together and use distributed processing software to coordinate their
activities. MapReduce is a distributed processing tool that makes this possible.

Two factors have forced this shift. First, the amount of data to index in the
largest systems is exploding.Modern web search engines already index tens of bil-
lions of pages, but even larger indexes are coming. Consider that if each person on
earth wrote one blog post each day, the Web would increase in size by over two
trillion pages every year.Optimistically, one typicalmodern computer can handle
a few hundred million pages, although not with the kind of response times that



5.6 Index Construction 159

most users expect.This leaves a huge gulf between the size of theWeb andwhatwe
can handle with current single-computer technology. Note that this problem is
not restricted to a few major web search companies; many more companies want
to analyze the content of theWeb instead of making it available for public search.
These companies have the same scalability problem.

The second factor is simple economics. The incredible popularity of personal
computers has made them very powerful and inexpensive. In contrast, large com-
puters serve a very small market, and therefore have fewer opportunities to de-
velop economies of scale. Over time, this difference in scale has made it difficult
to make a computer that is much more powerful than a personal computer that
is still sold for a reasonable amount of money. Many large information retrieval
systems ran on mainframes in the past, but today’s platform of choice consists of
many inexpensive commodity servers.

Inexpensive servers have a few disadvantages when compared to mainframes.
First, they are more likely to break, and the likelihood of at least one server fail-
ure goes up as you add more servers. Second, they are difficult to program. Most
programmers are well trained for single-threaded programming, less well trained
for threaded or multi-process programming, and not well trained at all for coop-
erative network programming.Many programming toolkits have been developed
to help address this kind of problem. RPC, CORBA, Java RMI, and SOAP have
been developed to allow function calls across machine boundaries. MPI provides
a different abstraction, calledmessage passing, which is popular formany scientific
tasks.None of these techniques are particularly robust against system failures, and
the programmingmodels can be complex. In particular, these systems do not help
distribute data evenly among machines; that is the programmer’s job.

Data placement

Before diving into themechanics of distributed processing, consider the problems
of handling huge amounts of data on a single computer. Distributed processing
and large-scale data processing have one major aspect in common, which is that
not all of the input data is available at once. In distributed processing, the data
might be scattered among many machines. In large-scale data processing, most of
the data is on the disk. In both cases, the key to efficient data processing is placing
the data correctly.

Let’s take a simple example. Suppose you have a text file that contains data
about credit card transactions. Each line of the file contains a credit card number



160 5 Ranking with Indexes

and an amount ofmoney.Howmight you determine the number of unique credit
card numbers in the file?

If the file is not very big, you could read each line, parse the credit card num-
ber, and store the credit card number in a hash table. Once the entire file had been
read, the hash table would contain one entry for each unique credit card number.
Counting the number of entries in the hash table would give you the answer. Un-
fortunately, for a big file, the hash table would be too large to store in memory.

Now suppose you had the very same credit card data, but the transactions in
the file were ordered by credit card number. Counting the number of unique
credit card numbers in this case is very simple. Each line in the file is read and
the credit card number on the line is parsed. If the credit card number found is
different than the one on the line before it, a counter is incremented. When the
end of the file is reached, the counter contains a count of the unique credit card
numbers in the file. No hash table is necessary for this to work.

Now, back to distributed computation. Suppose you havemore than one com-
puter to use for this counting task. You can split the big file of transactions into
small batches of transactions. Each computer can count its fraction, and then the
results can be merged together to produce a final result.

Initially, we start with an unordered file of transactions. We split that file into
small batches of transactions and count the unique credit card numbers in each
batch. How do we combine the results? We could add the number of credit card
numbers found in eachbatch, but this is incorrect, since the same credit cardnum-
ber might appear in more than one batch, and therefore would be counted more
than once in the final total. Instead, we would need to keep a list of the unique
credit card numbers found in each batch, and then merge those lists together to
make a final result list.The size of this final list is the number of unique credit card
numbers in the whole set.

In contrast, suppose the transactions are split into batches with more care, so
that all transactions made with the same credit card end up in the same batch.
With this extra restriction, each batch can be counted individually, and then the
counts from each batch can be added tomake a final result. Nomerge is necessary,
because there is no possibility of double-counting. Each credit card number will
appear in precisely one batch.

These examples might be a little bit tedious, but the point is that proper data
grouping can radically change the performance characteristics of a task. Using a
sorted input file made the counting task easy, reduced the amount of memory
needed to nearly zero, and made it possible to distribute the computation easily.



5.6 Index Construction 161

MapReduce

MapReduce is a distributed programming framework that focuses on data place-
ment and distribution. As we saw in the last few examples, proper data placement
canmake some problems very simple to compute. By focusing on data placement,
MapReduce can unlock the parallelism in some common tasks and make it easier
to process large amounts of data.

MapReduce gets its name from the two pieces of code that a user needs to
write inorder touse the framework: theMapper and theReducer.TheMapReduce
library automatically launches many Mapper and Reducer tasks on a cluster of
machines. The interesting part about MapReduce, though, is the path the data
takes between the Mapper and the Reducer.

Before we look at how theMapper andReducer work, let’s look at the founda-
tions of theMapReduce idea.The functions map and reduce are commonly found
in functional languages. In very simple terms, the map function transforms a list
of items into another list of items of the same length. The reduce function trans-
forms a list of items into a single item. The MapReduce framework isn’t quite
so strict with its definitions: both Mappers and Reducers can return an arbitrary
number of items. However, the general idea is the same.

Map

Reduce
Shuffle

Input

Output

Fig. 5.10. MapReduce



162 5 Ranking with Indexes

We assume that the data comes in a set of records. The records are sent to the
Mapper, which transforms these records into pairs, each with a key and a value.
The next step is the shuffle, which the library performs by itself. This operation
uses a hash function so that all pairs with the same key end up next to each other
and on the same machine. The final step is the reduce stage, where the records are
processed again, but this time in batches, meaning all pairs with the same key are
processed at once. The MapReduce steps are summarized in Figure 5.10.

procedure M??C?????C????(input)
while not input.done() do

record? input.next()
card? record.card
amount? record.amount
Emit(card, amount)

end while
end procedure

Fig. 5.11. Mapper for a credit card summing algorithm

procedure R?????C?????C????(key, values)
total? 0
card? key
while not values.done() do

amount? values.next()
total? total + amount

end while
Emit(card, total)

end procedure

Fig. 5.12. Reducer for a credit card summing algorithm

The credit card data example we saw in the previous section works well as
a MapReduce task. In the Mapper (Figure 5.11), each record is split into a key
(the credit card number) and a value (the money amount in the transaction).The
shuffle stage sorts the data so that the records with the same credit card number
end up next to each other. The reduce stage emits a record for each unique credit



5.6 Index Construction 163

card number, so the total number of unique credit card numbers is the number of
records emitted by the reducer (Figure 5.12).

Typically, we assume that both the Mapper and Reducer are idempotent. By
idempotent, we mean that if the Mapper or Reducer is called multiple times on
the same input, the output will always be the same. This idempotence allows the
MapReduce library to be fault tolerant. If any part of the computation fails, per-
haps because of a hardware machine failure, the MapReduce library can just pro-
cess that part of the input again on a different machine. Even when machines
don’t fail, sometimes machines can be slow because of misconfiguration or slowly
failing parts. In this case, a machine that appears to be normal could return re-
sults much more slowly than other machines in a cluster. To guard against this,
as the computation nears completion, theMapReduce library issues backupMap-
pers and Reducers that duplicate the processing done on the slowest machines.
This ensures that slow machines don’t become the bottleneck of a computation.
The idempotence of the Mapper and Reducer are what make this possible. If the
Mapper or Reducer modified files directly, for example, multiple copies of them
could not be run simultaneously.

Let’s look at the problem of indexing a corpus withMapReduce. In our simple
indexer, we will store inverted lists with word positions.

procedure M??D????????T?P???????(input)
while not input.done() do

document? input.next()
number? document.number
position? 0
tokens? Parse(document)
for each wordw in tokens do

Emit(w, document:position)
position = position + 1

end for
end while

end procedure

Fig. 5.13. Mapper for documents

MapDocumentsToPostings (Figure 5.13) parses each document in the input.
At each word position, it emits a key/value pair: the key is the word itself, and
the value is document:position, which is the document number and the position



164 5 Ranking with Indexes

procedure R?????P???????T?L????(key, values)
word? key
WriteWord(word)
while not input.done() do

EncodePosting(values.next())
end while

end procedure

Fig. 5.14. Reducer for word postings

concatenated together. When ReducePostingsToLists (Figure 5.14) is called, the
emitted postings have been shuffled so that all postings for the same word are
together. The Reducer calls WriteWord to start writing an inverted list and then
uses EncodePosting to write each posting.

5.6.4 Update

So far, we have assumed that indexing is a batch process. This means that a set of
documents is given to the indexer as input, the indexer builds the index, and then
the system allows users to run queries. In practice, most interesting document col-
lections are constantly changing. At the very least, collections tend to get bigger
over time; every day there is more news and more email. In other cases, such as
web search or file system search, the contents of documents can change over time
as well. A useful search engine needs to be able to respond to dynamic collections.

We can solve the problem of update with two techniques: index merging and
result merging. If the index is stored inmemory, there are many options for quick
index update. However, even if the search engine is evaluating queries in mem-
ory, typically the index is stored on a disk. Inserting data in the middle of a file
is not supported by any common file system, so direct disk-based update is not
straightforward. We do know how to merge indexes together, though, as we saw
in section 5.6.2.This gives us a simple approach for adding data to the index:make
a new, smaller index (I2) and merge it with the old index (I1) to make a new in-
dex containing all of the data (I). Postings in I1 for any deleted documents can
be ignored during the merge phase so they do not appear in I .

Index merging is a reasonable update strategy when index updates come in
large batches, perhaps many thousands of documents at a time. For single docu-
ment updates, it isn’t a very good strategy, since it is time-consuming to write the
entire index to disk. For these small updates, it is better to just build a small index



5.7 Query Processing 165

for the new data, but notmerge it into the larger index.Queries are evaluated sep-
arately against the small index and the big index, and the result lists aremerged to
find the top k results.

Result merging solves the problem of how to handle new documents: just put
them in a new index. But how dowe delete documents from the index?The com-
mon solution is to use a deleted document list. During query processing, the sys-
tem checks the deleted document list to make sure that no deleted documents
enter the list of results shown to the user. If the contents of a document change,
we can delete the old version from the index by using a deleted document list and
then add a new version to the recent documents index.

Results merging allows us to consider a small, in-memory index structure to
hold new documents. This in-memory structure could be a hash table of arrays,
as shown in Figure 5.8, and therefore would be simple and quick to update, even
with only a single document.

To gain even more performance from the system, instead of using just two
indexes (an in-memory index and a disk-based index), we can use many indexes.
Using too many indexes is a bad idea, since each new index slows down query
processing.However, using too few indexes results in slow indexbuild throughput
because of excessive disk traffic. A particularly elegant solution to this problem is
geometric partitioning. In geometric partitioning, the smallest index, I0, contains
about as much data as would fit in memory. The next index, I1, contains about r
times as much data as I1. Ifm is the amount of bytes of memory in the machine,
index In then contains between mrn and (m + 1)rn bytes of data. If index In
ever contains more than (m + 1)rn, it is merged into index In+1. If r = 2, the
system can hold 1000m bytes of index data using just 10 indexes.

5.7 Query Processing

Once an index is built, we need to process the data in it to produce query results.
Evenwith simple algorithms, processing queries using an index ismuch faster than
it is without one.However, clever algorithms can boost query processing speed by
ten to a hundred times over the simplest versions.Wewill explore the simplest two
query processing techniques first, called document-at-a-time and term-at-a-time,
and then move on to faster and more flexible variants.



166 5 Ranking with Indexes

5.7.1 Document-at-a-time Evaluation

Document-at-a-time retrieval is the simplest way, at least conceptually, to per-
form retrieval with an inverted file. Figure 5.15 is a picture of document-at-a-time
retrieval for the query “salt water tropical”. The inverted lists are shown horizon-
tally, although the postings have been aligned so that each column represents a
different document. The inverted lists in this example hold word counts, and the
score, for this example, is just the sum of the word counts in each document. The
vertical gray lines indicate the different steps of retrieval. In the first step, all the
counts for the first document are added to produce the score for that document.
Once the scoring for the first document has completed, the second document is
scored, then the third, and then the fourth.

1:2tropical 2:2 3:1

1:1salt 4:1

1:1water 2:1 4:1

1:4score 2:3 3:1 4:2

Fig. 5.15. Document-at-a-time query evaluation. The numbers (x:y) represent a docu-
ment number (x) and a word count (y).

Figure 5.16 shows a pseudocode implementation of this strategy. The param-
eters areQ, the query; I , the index; f and g, the sets of feature functions; and k,
the number of documents to retrieve. This algorithm scores documents using the
abstract model of ranking described in section 5.2. However, in this simplified
example, we assume that the only non-zero feature values for g(Q) correspond to
the words in the query. This gives us a simple correspondence between inverted
lists and features: there is one list for each query term, and one feature for each
list. Later in this chapter we will explore structured queries, which are a standard
way of moving beyond this simple model.

For eachwordwi in the query, an inverted list is fetched from the index.These
inverted lists are assumed to be sorted in order by document number. The Invert-
edList object starts by pointing at the first posting in each list. All of the fetched
inverted lists are stored in an array,L.



5.7 Query Processing 167

procedure D???????A?AT???R????????(Q, I , f , g, k)
L?Array()
R? PriorityQueue(k)
for all termswi inQ do

li ? InvertedList(wi, I)
L.add( li )

end for
for all documents d ? I do

sd ? 0
for all inverted lists li inL do

if li.getCurrentDocument() = d then
sd ? sd + gi(Q)fi(li) ?Update the document score

end if
li.movePastDocument( d )

end for
R.add( sd, d )

end for
return the top k results fromR

end procedure

Fig. 5.16. A simple document-at-a-time retrieval algorithm

In themain loop, the function loops once for each document in the collection.
At each document, all of the inverted lists are checked. If the document appears
in one of the inverted lists, the feature function fi is evaluated, and the docu-
ment score sD is computed by adding up the weighted function values. Then, the
inverted list pointer is moved to point at the next posting. At the end of each doc-
ument loop, a new document score has been computed and added to the priority
queueR.

For clarity, this pseudocode is free of even simple performance-enhancing
changes. Realistically, however, the priority queue R only needs to hold the top
k results at any one time. If the priority queue ever contains more than k results,
the lowest-scoring documents can be removed until only k remain, in order to
save memory. Also, looping over all documents in the collection is unnecessary;
we can change the algorithm to score only documents that appear in at least one
of the inverted lists.

The primary benefit of thismethod is its frugal use ofmemory.The onlymajor
use ofmemory comes from the priority queue, which only needs to store k entries



168 5 Ranking with Indexes

at a time. However, in a realistic implementation, large portions of the inverted
lists would also be buffered in memory during evaluation.

5.7.2 Term-at-a-time Evaluation

Figure 5.17 shows term-at-a-time retrieval, using the same query, scoring func-
tion, and inverted list data as in the document-at-a-time example (Figure 5.15).
Notice that the computed scores are exactly the same in both figures, although
the structure of each figure is different.

1:1salt 4:1

1:1water 2:1 4:1

1:1partial scores 4:1

1:2new partial scores 4:22:1

1:1old partial scores 4:1

1:2tropical 2:2 3:1

1:2old partial scores 4:22:1

1:4final scores 2:3 3:1 4:2

Fig. 5.17. Term-at-a-time query evaluation

As before, the gray lines indicate the boundaries between each step. In the first
step, the inverted list for “salt” is decoded, and partial scores are stored in accumu-
lators.These scores are called partial scores because they are only a part of the final
document score.The accumulators, which get their name from their job, accumu-
late score information for each document. In the second step, partial scores from
the accumulators are combined with data from the inverted list for “water” to
produce a new set of partial scores. After the data from the list for “tropical” is
added in the third step, the scoring process is complete.

The figure implies that a new set of accumulators is created for each list. Al-
though this is one possible implementation technique, in practice accumulators
are stored in a hash table. The information for each document is updated as the



5.7 Query Processing 169

inverted list data is processed. The hash table contains the final document scores
after all inverted lists have been processed.

procedure T???A?AT???R????????(Q, I , f , g k)
A?HashTable()
L?Array()
R? PriorityQueue(k)
for all termswi inQ do

li ? InvertedList(wi, I)
L.add( li )

end for
for all lists li ? L do

while li is not finished do
d? li.getCurrentDocument()
Ad ? Ad + gi(Q)f(li)
li.moveToNextDocument()

end while
end for
for all accumulatorsAd inA do

sd ? Ad ?Accumulator contains the document score
R.add( sd, d )

end for
return the top k results fromR

end procedure

Fig. 5.18. A simple term-at-a-time retrieval algorithm

The term-at-a-time retrieval algorithm for the abstract ranking model (Fig-
ure 5.18) is similar to the document-at-a-time version at the start. It creates a pri-
ority queue and fetches one inverted list for each term in the query, just like the
document-at-a-time algorithm. However, the next step is different. Instead of a
loop over each document in the index, the outer loop is over each list. The inner
loop then reads each posting of the list, computing the feature functions fi and gi
and adding its weighted contribution to the accumulatorAd. After themain loop
completes, the accumulators are scanned and added to a priority queue, which de-
termines the top k results to be returned.

The primary disadvantage of the term-at-a-time algorithm is the memory us-
age required by the accumulator tableA. Remember that the document-at-a-time



170 5 Ranking with Indexes

strategy requires only the small priority queue R, which holds a limited number
of results. However, the term-at-a-time algorithm makes up for this because of its
more efficient disk access. Since it reads each inverted list from start to finish, it
requiresminimal disk seeking, and it needs very little list buffering to achieve high
speeds. In contrast, the document-at-a-time algorithm switches between lists and
requires large list buffers to help reduce the cost of seeking.

In practice, neither the document-at-a-time nor term-at-a-time algorithms
are used without additional optimizations. These optimizations dramatically im-
prove the running speed of the algorithms, and canhave a large effect on themem-
ory footprint.

5.7.3 Optimization Techniques

There are two main classes of optimizations for query processing. The first is to
read less data from the index, and the second is to process fewer documents. The
two are related, since it would be hard to score the same number of documents
while reading less data. When using feature functions that are particularly com-
plex, focusing on scoring fewer documents should be the main concern. For sim-
ple feature functions, the best speed comes from ignoring as much of the inverted
list data as possible.

List skipping

In section 5.4.7, we covered skip pointers in inverted lists. This kind of forward
skipping is by far themost popular way to ignore portions of inverted lists (Figure
5.19). More complex approaches (for example, tree structures) are also possible
but not frequently used.

Fig. 5.19.Skip pointers in an inverted list.The gray boxes show skip pointers, which point
into the white boxes, which are inverted list postings.

Skip pointers do not improve the asymptotic running time of reading an in-
verted list. Suppose we have an inverted list that is n bytes long, but we add skip
pointers after each c bytes, and the pointers are k bytes long. Reading the entire



5.7 Query Processing 171

list requires reading?(n)bytes, but jumping through the list using the skip point-
ers requires ?(kn/c) time, which is equivalent to ?(n). Even though there is
no asymptotic gain in runtime, the factor of c can be huge. For typical values of
c = 100 and k = 4, skipping through a list results in reading just 2.5% of the
total data.

Notice that as c gets bigger, the amount of data you need to read to skip
through the list drops. So, why not make c as big as possible? The problem is that
if c gets too large, the average performance drops. Let’s look at this problem in
more detail.

Suppose youwant to find pparticular postings in an inverted list, and the list is
n bytes long, withk-byte skip pointers located at c-byte intervals.Therefore, there
are n/c total intervals in the list. To find those p postings, we need to read kn/c
bytes in skip pointers, but we also need to read data in p intervals. On average, we
assume that the postings we want are about halfway between two skip pointers,
so we read an additional pc/2 bytes to find those postings. The total number of
bytes read is then:

kn

c
+

pc

2

Notice that this analysis assumes that p is much smaller than n/c; that’s what
allows us to assume that each posting lies in its own interval. As p grows closer
to n/c, it becomes likely that some of the postings we want will lie in the same
intervals. However, notice that once p gets close to n/c, we need to read almost
all of the inverted list, so the skip pointers aren’t very helpful.

Coming back to the formula, you can see that while a larger value of c makes
the first term smaller, it also makes the second term bigger.Therefore, picking the
perfect value for c depends on the value of p, and we don’t know what p is until
a query is executed. However, it is possible to use previous queries to simulate
skipping behavior and to get a good estimate for c. In the exercises, you will be
asked toplot someof graphs of this formula and to solve for the equilibriumpoint.

Although it might seem that list skipping could save on disk accesses, in prac-
tice it rarely does. Modern disks are much better at reading sequential data than
they are at skipping to random locations. Because of this, most disks require a skip
of about 100,000 postings before any speedup is seen. Even so, skipping is still use-
ful because it reduces the amount of time spent decoding compresseddata that has
been read from disk, and it dramatically reduces processing time for lists that are
cached in memory.



172 5 Ranking with Indexes

Conjunctive processing

The simplest kind of query optimization is conjunctive processing. By conjunctive
processing, we just mean that every document returned to the user needs to con-
tain all of the query terms. Conjunctive processing is the default mode for many
web search engines, inpart because of speed and inpart becauseusers have come to
expect it. With short queries, conjunctive processing can actually improve effec-
tiveness and efficiency simultaneously. In contrast, search engines that use longer
queries, such as entire paragraphs, will not be good candidates for conjunctive
processing.

Conjunctive processing works best when one of the query terms is rare, as in
the query “fish locomotion”. The word “fish” occurs about 100 times as often as
the word “locomotion”. Since we are only interested in documents that contain
both words, the system can skip over most of the inverted list for “fish” in order
to find only the postings in documents that also contain the word “locomotion”.

Conjunctive processing can be employed with both term-at-a-time and docu-
ment-at-a-time systems. Figure 5.20 shows the updated term-at-a-time algorithm
for conjunctive processing. When processing the first term, (i = 0), processing
proceeds normally. However, for the remaining terms, (i > 0), the algorithm
processes postings starting at line ??. It checks the accumulator table for the next
document that contains all of the previous query terms, and instructs list li to
skip forward to that document if there is a posting for it (line ??). If there is a
posting, the accumulator is updated. If the posting does not exist, the accumulator
is deleted (line ??).

The document-at-a-time version (Figure 5.21) is similar to the old document-
at-a-time version, except in the inner loop. It begins by finding the largest docu-
ment d currently pointed to by an inverted list (line 13). This document d is not
guaranteed to contain all the query terms, but it is a reasonable candidate. The
next loop tries to skip all lists forward to point at d (line 16). If this is not success-
ful, the loop terminates and another document d is chosen. If it is successful, the
document is scored and added to the priority queue.

In both algorithms, the system runs fastestwhen the first list (l0) is the shortest
and the last list (ln) is the longest.This results in the biggest possible skip distances
in the last list, which is where skipping will help most.



5.7 Query Processing 173

1: procedure T???A?AT???R????????(Q, I , f , g, k)
2: A?Map()
3: L?Array()
4: R? PriorityQueue(k)
5: for all termswi inQ do
6: li ? InvertedList(wi, I)
7: L.add( li )
8: end for
9: for all lists li ? L do

10: d0 ? ?1
11: while li is not finished do
12: if i = 0 then
13: d? li.getCurrentDocument()
14: Ad ? Ad + gi(Q)f(li)
15: li.moveToNextDocument()
16: else
17: d? li.getCurrentDocument()
18: d? ? A.getNextAccumulator(d)
19: A.removeAccumulatorsBetween(d0,d?)
20: if d = d? then
21: Ad ? Ad + gi(Q)f(li)
22: li.moveToNextDocument()
23: else
24: liskipForwardToDocument(d?)
25: end if
26: d0 ? d?
27: end if
28: end while
29: end for
30: for all accumulatorsAd inA do
31: sd ? Ad ?Accumulator contains the document score
32: R.add( sd, d )
33: end for
34: return the top k results fromR
35: end procedure

Fig. 5.20. A term-at-a-time retrieval algorithm with conjunctive processing



174 5 Ranking with Indexes

1: procedure D???????A?AT???R????????(Q, I , f , g, k)
2: L?Array()
3: R? PriorityQueue(k)
4: for all termswi inQ do
5: li ? InvertedList(wi, I)
6: L.add( li )
7: end for
8: d? ?1
9: while all lists inL are not finished do

10: sd ? 0
11: for all inverted lists li inL do
12: if li.getCurrentDocument() > d then
13: d? li.getCurrentDocument()
14: end if
15: end for
16: for all inverted lists li inL do
17: li.skipForwardToDocument(d)
18: if li.getCurrentDocument() = d then
19: sd ? sd + gi(Q)fi(li) ?Update the document score
20: li.movePastDocument( d )
21: else
22: d? ?1
23: break
24: end if
25: end for
26: if d > ?1 thenR.add( sd, d )
27: end if
28: end while
29: return the top k results fromR
30: end procedure

Fig. 5.21. A document-at-a-time retrieval algorithm with conjunctive processing

Threshold methods

So far, the algorithms we have considered do not do much with the parameter k
until the very last statement. Remember that k is the number of results requested
by the user, and formany search applications this number is something small, such
as 10 or 20. Because of this small value of k, most documents in the inverted lists



5.7 Query Processing 175

will never be shown to the user. Threshold methods focus on this k parameter in
order to score fewer documents.

In particular, notice that for every query, there is some minimum score that
each document needs to reach before it can be shown to the user. This minimum
score is the score of the kth-highest scoring document. Any document that does
not score at least this highlywill never be shown to the user. In this section,wewill
use the Greek letter tau (? ) to represent this value, which we call the threshold.

Ifwe could know the appropriate value for ? before processing the query,many
query optimizations would be possible. For instance, since a document needs a
score of at least ? in order to be useful to the user, we could avoid adding docu-
ments to the priority queue (in the document-at-a-time case) that did not achieve
a score of at least ? . In general, we could safely ignore any document with a score
less than ? .

Unfortunately, we don’t know how to compute the true value of ? without
evaluating the query, but we can approximate it. These approximations will be
called ? ?.Wewant ? ? ? ? , so that we can safely ignore any document with a score
less than ? ?. Of course, the closer our estimate ? ? gets to ? , the faster our algorithm
will run, since it can ignore more documents.

Coming up with an estimate for ? ? is easy with a document-at-a-time strategy.
Remember that R maintains a list of the top k highest-scoring documents seen
so far in the evaluation process. We can set ? ? to the score of the lowest-scoring
document currently inR, assumingR already has k documents in it. With term-
at-a-time evaluation, we don’t have full document scores until the query evalua-
tion is almost finished. However, we can still set ? ? to be the kth-largest score in
the accumulator table.

MaxScore

With reasonable estimates for ? ?, it is possible to start ignoring some of the data
in the inverted lists.This estimate, ? ?, represents a lower bound on the score a doc-
ument needs in order to enter the final ranked list. Therefore, with a little bit of
clever math, we can ignore parts of the inverted lists that will not generate docu-
ment scores above ? ?.

Let’s lookmore closely at how this might happenwith a simple example. Con-
sider the query “eucalyptus tree”. The word “tree” is about 100 times more com-
mon than the word “eucalyptus”, so we expect that most of the time we spend
evaluating this querywill be spent scoring documents that contain theword “tree”



176 5 Ranking with Indexes

and not “eucalyptus”. This is a poor use of time, since we’re almost certain to find
a set of top k documents that contain both words.

eucalyptus

tree

Fig. 5.22. MaxScore retrieval with the query “eucalyptus tree”. The gray boxes indicate
postings that can be safely ignored during scoring.

Figure 5.22 shows this effect in action. We see the inverted lists for “eucalyp-
tus” and “tree” extending across the page, with the postings lined up by document,
as in previous figures in this chapter. This figure shows that there are many doc-
uments that contain the word “tree” and don’t contain the word “eucalyptus”.
Suppose that the indexer computed the largest partial score in the “tree” list, and
that value is called µtree. This is the maximum score (hence MaxScore) that any
document that contains just this word could have.

Suppose that we are interested only in the top three documents in the ranked
list (i.e., k is 3). The first scored document contains just the word “tree”. The next
three documents contain both “eucalyptus” and “tree”.Wewill use ? ? to represent
the lowest score from these three documents. At this point, it is highly likely that
? ? > µtree, because ? ? is the score of a document that contains both query terms,
whereas µtree is a query score for a document that contains just one of the query
terms. This is where the gray boxes come into the story. Once ? ? > µtree, we can
safely skip over all of the gray postings, sincewe have proven that these documents
will not enter the final ranked list.

Thepostings data in the figure is fabricated, but for real inverted lists for “euca-
lyptus” and “tree”, 99% of the postings for “tree” would be gray boxes, and there-
fore would be safe to ignore. This kind of skipping can dramatically reduce query
times without affecting the quality of the query results.

Early termination

The MaxScore approach guarantees that the result of query processing will be ex-
actly the same in the optimized version as it is without optimization. In some
cases, however, it may be interesting to take some risks with quality and process
queries in a way that might lead to different results than the same queries in an
unoptimized system.



5.7 Query Processing 177

Why might we choose to do this? One reason is that some queries are much,
much more expensive than others. Consider the phrase query “to be or not to
be”. This query uses very common terms that would have very long inverted lists.
Running this query to completion could severely reduce the amount of system
resources available to serve other queries. Truncating query processing for this ex-
pensive query can help ensure fairness for others using the same system.

Another reason is that MaxScore is necessarily conservative. It will not skip
over regions of the inverted list that might have a usable candidate document.
Because of this, MaxScore can spend a lot of time looking for a document that
might not exist. Taking a calculated risk to ignore these improbable documents
can pay off in decreased system resource consumption.

How might early termination work? In term-at-a-time systems, we can termi-
nate processing by simply ignoring some of the very frequent query terms. This is
not so different from using a stopword list, except that in this case we would be
ignoring words that usually would not be considered stopwords. Alternatively,
we might decide that after some constant number of postings have been read, no
other terms will be considered. The reasoning here is that, after processing a sub-
stantial number of postings, the ranking should be fairlywell established. Reading
more information will only change the rankings a little. This is especially true for
queries with many (e.g., hundreds) of terms, which can happen when query ex-
pansion techniques are used.

In document-at-a-time systems, early termination means ignoring the docu-
ments at the very end of the inverted lists. This is a poor idea if the documents are
sorted in random order, but this does not have to be the case. Instead, documents
could be sorted in order by some quality metric, such as PageRank. Terminating
early in that case wouldmean ignoring documents that are considered lower qual-
ity than the documents that have already been scored.

List ordering

So far, all the examples in this chapter assume that the inverted lists are stored
in the same order, by document number. If the document numbers are assigned
randomly, this means that the document sort order is random. The net effect is
that the best documents for a query can easily be at the very end of the lists. With
good documents scattered throughout the list, any reasonable query processing
algorithm must read or skip through the whole list to make sure that no good
documents are missed. Since these lists can be long, it makes sense to consider a
more intelligent ordering.



178 5 Ranking with Indexes

One way to improve document ordering is to order documents based on doc-
ument quality, as we discussed in the last section. There are plenty of quality met-
rics that could be used, such as PageRank or the total number of user clicks. If the
smallest document numbers are assigned to the highest-quality documents, it be-
comes reasonable to consider stopping the search early if many good documents
have been found. The threshold techniques from the MaxScore section can be
used here. If we know that documents in the lists are decreasing in quality, we can
compute an upper bound on the scores of the documents remaining in the lists at
every point during retrieval. When ? ? rises above the highest possible remaining
document score, retrieval can be stopped safely without harming effectiveness.

Another option is to order each list by partial score. For instance, for the
“food” list, we could store documents that contain many instances of the word
“food” first. In a web application, this may correspond to putting restaurant pages
early in the inverted list. For a “dog” list, we could store pages about dogs (i.e.,
containing many instances of “dog”) first. Evaluating a query about food or dogs
then becomes very easy. Other queries, however, can be more difficult. For ex-
ample, how do we evaluate the query “dog food”? The best way to do it is to use
an accumulator table, as in term-at-a-time retrieval. However, instead of reading
a whole list at once, we read just small pieces of each list. Once the accumulator
table shows that many good documents have been found, we can stop looking.
As you can imagine, retrieval works fastest with terms that are likely to appear
together, such as “tortilla guacamole”. When the terms are not likely to appear
together—for example, “dirt cheese”—it is likely to take much longer to find the
top documents.

5.7.4 Structured Queries

In the query evaluation examples we have seen so far, our assumption is that each
inverted list corresponds to a single feature, and that we add those features to-
gether to create a final document score. Although this works in simple cases, we
mightwant amore interesting kindof scoring function. For instance, in Figure 5.2
the query had plenty of interesting features, including a phrase (“tropical fish”), a
synonym (“chichlids”), and some non-topical features (e.g., incoming links).

One way to do this is to write specialized ranking code in the retrieval system
that detects these extra features and uses inverted list data directly to compute
scores, but in a way that is more complicated than just a linear combination of
features. This approach greatly increases the kinds of scoring that you can use,
and is very efficient. Unfortunately, it isn’t very flexible.



5.7 Query Processing 179

Another option is to build a system that supports structured queries. Struc-
tured queries are queries written in a query language, which allows you to change
the features used in a query and the way those features are combined. The query
language is not used by normal users of the system. Instead, a query translator
converts the user’s input into a structured query representation. This translation
process is where the intelligence of the system goes, including how toweightword
features and what synonyms to use. Once this structured query has been created,
it is passed to the retrieval system for execution.

You may already be familiar with this kind of model, since database systems
work this way. Relational databases are controlled using Structured Query Lan-
guage (SQL).Many important applications consist of a user interface and a struc-
tured query generator, with the rest of the logic controlled by a database.This sep-
aration of the application logic from the database logic allows the database to be
both highly optimized and highly general.

Galago contains a structured query processing system that is described in de-
tail in Chapter 7. This query language is also used in the exercises.

#combine

#od:1

tropical aquarium fish

#od:1

feature combinations

list data

proximity expressions

Fig. 5.23. Evaluation tree for the structured query #combine(#od:1(tropical fish)
#od:1(aquarium fish) fish)

Figure 5.23 shows a tree representation of a structured query written in the
Galago structured query language: #combine(#od:1(tropical fish) #od:1(aquarium
fish) fish).

This query indicates that the document score should be a combination of the
scores from three subqueries. The first query is #od:1(tropical fish). In the Galago
query language, the #od:1 operator means that the terms inside it need to appear
next to each other, in that order, in a matching document. The same is true of



180 5 Ranking with Indexes

#od:1(aquarium fish). The final query term is fish. Each of these subqueries acts as a
document feature that is combined using the #combine operator.

This query contains examples of the main types of structured query expres-
sions. At the bottom of the tree, we have index terms. These are terms that corre-
spond to inverted lists in the index. Above that level, we have proximity expres-
sions. These expressions combine inverted lists to create more complex features,
such as a feature for “fish” occurring in a document title, or “tropical fish” occur-
ring as a phrase. At the top level, the feature data computed from the inverted lists
is combined into a document score. At this level, the position information from
the inverted lists is ignored.

Galago evaluates structured queries by making a tree of iterator objects that
looks just like the tree shown in Figure 5.23. For instance, an iterator is created
that returns the matching documents for #od:1(tropical fish). The iterator finds
these matching documents by using data from inverted list iterators for “tropical”
and “fish”. The #combine operator is an iterator of document scores, which uses
iterators for #od:1(tropical fish), #od:1(aquarium fish), and fish. Once a tree of itera-
tors like this is made, scoring documents is just a matter of using the root iterator
to step through the documents.

5.7.5 Distributed Evaluation

A single modern machine can handle a surprising load, and is probably enough
for most tasks. However, dealing with a large corpus or a large number of users
may require using more than one machine.

The general approach to using more than one machine is to send all queries to
a directormachine.The director then sendsmessages tomany index servers, which
do some portion of the query processing. The director then organizes the results
of this process and returns them to the user.

The easiest distribution strategy is called document distribution. In this strat-
egy, each index server acts as a search engine for a small fraction of the total doc-
ument collection. The director sends a copy of the query to each of the index
servers, each of which returns the top k results, including the document scores
for these results. These results are merged into a single ranked list by the director,
which then returns the results to the user.

Some ranking algorithms rely on collection statistics, such as the number of
occurrences of a term in the collection or the number of documents containing a
term. These statistics need to be shared among the index servers in order to pro-
duce comparable scores that can be merged effectively. In very large clusters of



5.7 Query Processing 181

machines, the term statistics at the index server level can vary wildly. If each in-
dex server uses only its own term statistics, the same document could receive very
different kinds of scores, depending on which index server is used.

Another distribution method is called term distribution. In term distribution,
a single index is built for the whole cluster of machines. Each inverted list in that
index is then assigned to one index server. For instance, the word “dog” might
be handled by the third server, while “cat” is handled by the fifth server. For a
system with n index servers and a k term query, the probability that all of the
query terms would be on the same server is 1/nk?1. For a cluster of 10 machines,
this probability is just 1% for a three-term query.Therefore, inmost cases the data
to process a query is not stored all on one machine.

One of the index servers, usually the one holding the longest inverted list, is
chosen to process the query. If other index servers have relevant data, that data
is sent over the network to the index server processing the query. When query
processing is complete, the results are sent to a director machine.

The term distribution approach is more complex than document distribution
because of the need to send inverted list data betweenmachines. Given the size of
inverted lists, the messages involved in shipping this data can saturate a network.
In addition, each query is processed using just one processor instead of many,
which increases overall query latency versus document distribution.Themain ad-
vantage of term distribution is seek time. If we have a k-term query and n index
servers, the total number of disk seeks necessary to process a query is O(kn) for
a document-distributed system, but just O(k) in a term-distributed system. For
a system that is disk-bound, and especially one that is seek-bound, term distribu-
tion might be attractive. However, recent research shows that term distribution
is rarely worth the effort.

5.7.6 Caching

We saw inChapter 4 howword frequencies in text follow aZipfian distribution: a
few words occur very often, but a huge number of words occur very infrequently.
It turns out that query distributions are similar. Some queries, such as those about
popular celebrities or current events, tend to be very popular with public search
engines. However, about half of the queries that a search engine receives each day
are unique.

This leads us into a discussion of caching. Broadly speaking, caching means
storing something you might want to use later. With search engines, we usually



182 5 Ranking with Indexes

want to cache ranked result lists for queries, but systems can also cache inverted
lists from disk.

Caching is perfectly suited for search engines. Queries and ranked lists are
small, meaning it doesn’t take much space in a cache to store them. By contrast,
processing a query against a large corpus can be very computationally intensive.
This means that once a ranked list is computed, it usually makes sense to keep it
around.

However, caching does not solve all of our performance problems, because
about half of all queries received each day are unique. Therefore, the search en-
gine itself must be built to handle query traffic very quickly. This leads to com-
petition for resources between the search engine and the caching system. Recent
research suggests that when memory space is tight, caching should focus on the
most popular queries, leaving plenty of room to cache the index. Unique queries
with multiple terms may still share a term and use the same inverted list. This
explains why inverted list caching can have higher hit rates than query caching.
Once the whole index is cached, all remaining resources can be directed toward
caching query results.

When using caching systems, it is important to guard against stale data. Cach-
ing works because we assume that query results will not change over time, but
eventually they do. Cache entries need acceptable timeouts that allow for fresh
results. This is easier when dealing with partitioned indexes like the ones we dis-
cussed in section 5.6.4. Each cache can be associated with a particular index par-
tition, and when that partition is deleted, the cache can also be deleted. Keep in
mind that a system that is built to handle a certain peak throughput with caching
enabled will handle a much smaller throughput with caching off.This means that
if your system ever needs to destroy its cache, be prepared to have a slow system
until the cache becomes suitably populated. If possible, cache flushes should hap-
pen at off-peak load times.

References and Further Reading

This chapter contains information about many topics: indexing, query process-
ing, compression, index update, caching, and distribution just to name a few. All
these topics are in one chapter to highlight how these components work together.

Because of how interconnected these components are, it is useful to look at
studies of real, working systems. Brin and Page (1998) wrote a paper about the
early Google system that is an instructive overview of what it takes to build a fully



5.7 Query Processing 183

working system. Later papers showhow theGoogle architecture has changed over
time—for example Barroso et al. (2003). The MapReduce paper, by Dean and
Ghemawat (2008), gives more detail than this chapter does about how MapRe-
duce was developed and how it works in practice.

The inner workings of commercial search engines are often considered trade
secrets, so the exact details of how they work is not often published. One im-
portant exception is the TodoBR engine, a popular Brazilian web search engine.
Before TodoBR was acquired by Google, their engineers frequently published
papers about its workings. One example is their paper on a two-level caching
scheme (Saraiva et al., 2001), but there are many others.

The book Managing Gigabytes (Witten et al., 1999) is the standard reference
for index construction, and is particularly detailed in its discussion of compres-
sion techniques. Work on compression for inverted lists continues to be an active
area of research. One of the recent highlights of this research is the PFOR se-
ries of compressors from Zukowski et al. (2006), which exploit the performance
characteristics of modern processors to make a scheme that is particularly fast for
decompressing small integers. Büttcher and Clarke (2007) did a recent study on
how compression schemes compare on the latest hardware.

Zobel and Moffat (2006) wrote a review article that outlines all of the impor-
tant recent research in inverted indexes, both in index construction and in query
processing. This article is the best place to look for an understanding of how this
research fits together.

Turtle and Flood (1995) developed the MaxScore series of algorithms. Fagin
et al. (2003) took a similar approach with score-sorted inputs, although they did
not initially apply their ideas to information retrieval. Anh and Moffat (2006)
refined these ideas to make a particularly efficient retrieval system.

Anh and Moffat (2005) and Metzler et al. (2008) cover methods for comput-
ing scores that can be stored in inverted lists. In particular, these papers describe
how to compute scores that are both useful in retrieval and can be stored com-
pactly in the list. Strohman (2007) explores the entire process of building scored
indexes and processing queries efficiently with them.

Many of the algorithms from this chapter are based onmerging two sorted in-
puts; index construction relies on this, as does any kind of document-at-a-time
retrieval process. Knuth wrote an entire volume on just sorting and searching,
which includes large amounts ofmaterial onmerging, including disk-basedmerg-
ing (Knuth, 1998). If the Knuth book is too daunting, any standard algorithms
textbook should be able to give you more detail about how merging works.



184 5 Ranking with Indexes

Lester et al. (2005) developed the geometric partitioning method for index
update. Büttcher et al. (2006) added some extensions to this model, focusing on
how very common terms should be handled during update. Strohman and Croft
(2006) show how to update the index without halting query processing.

Exercises

5.1. Section 5.2 introduced an abstract model of ranking, where documents and
queries are represented by features. What are some advantages of representing
documents and queries by features? What are some disadvantages?

5.2. Our model of ranking contains a ranking function R(Q,D), which com-
pares each document with the query and computes a score. Those scores are then
used to determine the final ranked list.

An alternate ranking model might contain a different kind of ranking func-
tion, f(A,B,Q), where A and B are two different documents in the collection
and Q is the query. When A should be ranked higher than B, f(A,B,Q) eval-
uates to 1. WhenA should be ranked belowB, f(A,B,Q) evaluates to –1.

If you have a ranking functionR(Q,D), show how you can use it in a system
that requires one of the form f(A,B,Q).Why can you not go the other way (use
f(A,B,Q) in a system that requiresR(Q,D))?

5.3. Suppose you build a search engine that uses one hundred computers with a
million documents stored on each one, so that you can search a collection of 100
million documents. Would you prefer a ranking function like R(Q,D) or one
like f(A,B,Q) (from the previous problem). Why?

5.4. Suppose your search engine has just retrieved the top 50 documents from
your collection based on scores from a ranking function R(Q,D). Your user in-
terface can show only 10 results, but you can pick any of the top 50 documents to
show. Why might you choose to show the user something other than the top 10
documents from the retrieved document set?

5.5. Documents can easily contain thousands of non-zero features. Why is it im-
portant that queries have only a few non-zero features?

5.6. Indexes are not necessary to search documents. Your web browser, for in-
stance, has a Find function in it that searches text without using an index. When
should you use an inverted index to search text? What are some advantages to
using an inverted index? What are some disadvantages?



5.7 Query Processing 185

5.7. Section 5.3 explains many different ways to store document information in
inverted lists. What kind of inverted lists might you build if you needed a very
small index?What kind would you build if you needed to findmentions of cities,
such as Kansas City or São Paulo?

5.8. Write a program that can build a simple inverted index of a set of text docu-
ments. Each inverted listwill contain thefile names of the documents that contain
that word.

Suppose the file A contains the text “the quick brown fox”, and file B contains
“the slow blue fox”. The output of your program would be:

% ./your-program A B
blue B
brown A
fox A B
quick A
slow B
the A B

5.9. In section 5.4.1, we created an unambiguous compression scheme for 2-bit
binary numbers. Find a sequence of numbers that takes up more space when it is
“compressed” using our scheme than when it is “uncompressed.”

5.10. Suppose a company develops a new unambiguous lossless compression
scheme for 2-bit numbers called SuperShrink. Its developers claim that it will re-
duce the size of any sequence of 2-bit numbers by at least 1 bit. Prove that the
developers are lying. More specifically, prove that either:

• SuperShrink never uses less space than an uncompressed encoding, or
• There is an input to SuperShrink such that the compressed version is larger

than the uncompressed input

You can assume that each 2-bit input number is encoded separately.

5.11. Why do we need to know something about the kind of data we will com-
press before choosing a compression algorithm? Focus specifically on the result
from Exercise 5.10.

5.12. Develop an encoder for theElias-? code.Verify that your programproduces
the same codes as in Table 5.2.



186 5 Ranking with Indexes

5.13. Identify the optimal skip distance k when performing a two-term Boolean
AND query where one term occurs 1 million times and the other term appears
100 million times. Assume that a linear search will be used once an appropriate
region is found to search in.

5.14. In section 5.7.3, we saw that the optimal skip distance c can be determined
by minimizing the quantity kn/c + pc/2, where k is the skip pointer length, n
is the total inverted list size, c is the skip interval, and p is the number of postings
to find.

Plot this function using k = 4, n = 1,000,000, and p = 1,000, but varying c.
Then, plot the same function, but set p = 10,000. Notice how the optimal value
for c changes.

Finally, take the derivative of the function kn/c + pc/2 in terms of c to find
the optimum value for c for a given set of other parameters (k, n, and p).

5.15. In Chapter 4, you learned about Zipf ’s law, and how approximately 50%
of words found in a collection of documents will occur only once. Your job is to
design a program that will verify Zipf ’s law using MapReduce.

Your program will output a list of number pairs, like this:

195840,1
70944,2
34039,3
...
1,333807

This sample output indicates that 195,840words appeared once in the collection,
70,944 appeared twice, and 34,039 appeared three times, but one word appeared
333,807 times. Your programwill print this kind of list for a document collection.

Your program will use MapReduce twice (two Map phases and two Reduce
phases) to produce this output.

5.16. Write theprogramdescribed inExercise 5.15using theGalago search toolkit.
Verify that it works by indexing the Wikipedia collection provided on the book
website.



6
Queries and Interfaces

“This is Information Retrieval, not Information
Dispersal.”

Jack Lint, Brazil

6.1 Information Needs and Queries

Although the index structures and ranking algorithms are key components of a
search engine, from the user’s point of view the search engine is primarily an in-
terface for specifying queries and examining results. People can’t change the way
the ranking algorithm works, but they can interact with the system during query
formulation and reformulation, andwhile they are browsing the results.These in-
teractions are a crucial part of the process of information retrieval, and can deter-
mine whether the search engine is viewed as providing an effective service. In this
chapter, we discuss techniques for query transformation and refinement, and for
assembling and displaying the search results. We also discuss cross-language search
engineshere because they rely heavily on the transformation of queries and results.

InChapter 1, we described an information need as themotivation for a person
using a search engine.There aremany types of information needs, and researchers
have categorized them using dimensions such as the number of relevant docu-
ments being sought, the type of information that is needed, and the tasks that
led to the requirement for information. It has also been pointed out that in some
cases it can be difficult for people to define exactly what their information need
is, because that information is a gap in their knowledge.1 From the point of view
of the search engine designer, there are two important consequences of these ob-
servations about information needs:

• Queries can represent very different information needs and may require dif-
ferent search techniques and ranking algorithms to produce the best rankings.

1 This is Belkin’s well-known Anomalous State of Knowledge (ASK) hypothesis (Belkin
et al., 1982/1997).



188 6 Queries and Interfaces

• Aquery canbe a poor representationof the informationneed.This canhappen
because the user finds it difficult to express the information need. More often,
however, it happens because the user is encouraged to enter short queries, both
by the search engine interface and by the fact that long queries often fail.

Thefirst point is discussed further inChapter 7.The secondpoint is amajor theme
in this chapter. We present techniques—such as spelling correction, query expan-
sion, and relevance feedback—that are designed to refine the query, either auto-
matically or through user interaction. The goal of this refinement process is to
produce a query that is a better representation of the information need, and con-
sequently to retrieve better documents. On the output side, the way that results
are displayed is an important part of helping the user understand whether his in-
formation need has been met. We discuss techniques such as snippet generation,
result clustering, and document highlighting, that are designed to help this process
of understanding the results.

Short queries consisting of a small number of keywords (between two and
three on average inmost studies ofweb search) are by far themost popular formof
query currently used in search engines. Given that such short queries can be am-
biguous and imprecise,2 why don’t people use longer queries?There are a number
of reasons for this. In the past, query languages for search engines were designed to
be used by expert users, or search intermediaries. They were called intermediaries
because they acted as the interface between the person looking for information
and the search engine. These query languages were quite complex. For example,
here is a query made up by an intermediary for a search engine that provides legal
information:

User query:Are there any cases that discuss negligent maintenance or fail-
ure to maintain aids to navigation such as lights, buoys, or channel mark-
ers?
Intermediary query:NEGLECT! FAIL! NEGLIG! /5 MAINT! REPAIR! /P NAV-
IGAT! /5 AID EQUIP! LIGHT BUOY ”CHANNEL MARKER”

This query language uses wildcard operators and various forms of proximity op-
erators to specify the information need. A wildcard operator is used to define the
minimum string match required for a word to match the query. For example,NE-
GLECT!will match “neglected”, “neglects”, or just “neglect”. A proximity operator

2 Would you go up to a person and say, “Tropical fish?”, or even worse, “Fish?”, if you
wanted to ask what types of tropical fish were easiest to care for?



6.1 Information Needs and Queries 189

is used to define constraints on the distance between words that are required for
them to match the query. One type of proximity constraint is adjacency. For ex-
ample, the quotes around ”CHANNEL MARKER” specify that the two words must
occur next to each other. The more general window operator specifies a width (in
words) of a text window that is allowed for the match. For example, /5 specifies
that the words must occur within five words of each other. Other typical prox-
imity operators are sentence and paragraph proximity. For example, /P specifies
that the words must occur in the same paragraph. In this query language, if no
constraint is specified, it is assumed to be a BooleanOR.

Some of these query language operators are still available in search engine in-
terfaces, such as using quotes for a phrase or a “+” to indicate a mandatory term,
but in general there is an emphasis on simple keyword queries (sometimes called
“natural language” queries) in order to make it possible for most people to do
their own searches.3 But if we want to make querying as natural as possible, why
not encourage people to type in better descriptions of what they are looking for
instead of just a couple of keywords? Indeed, in applications where people expect
other people to answer their questions, such as the community-based question
answering systems described in section 10.3, the average query length goes up to
around 30 words. The problem is that current search technology does not do a
good job with long queries.Most web search engines, for example, only rank doc-
uments that contain all the query terms. If a person enters a query with 30 words
in it, the most likely result is that nothing will be found. Even if documents con-
taining all the words can be found, the subtle distinctions of language used in a
long, grammatically correct query will often be lost in the results. Search engines
use ranking algorithms based primarily on a statistical view of text as a collection
of words, not on syntactic and semantic features.

Givenwhat happens to long queries, people have quickly learned that theywill
get the most reliable results by thinking of a few keywords that are likely to be as-
sociated with the information they are looking for, and using these as the query.
This places quite a burden on the user, and the query refinement techniques de-
scribed here are designed to reduce this burden and compensate for poor queries.

3 Note that the search engine may still be using a complex query language (such as that
described in section 7.4.2) internally, but not in the interface.



190 6 Queries and Interfaces

6.2 Query Transformation and Refinement

6.2.1 Stopping and Stemming Revisited

As mentioned in the last section, the most common form of query used in cur-
rent search engines consists of a small number of keywords. Some of these queries
use quotes to indicate a phrase, or a “+” to indicate that a word must be present,
but for the remainder of this chapter we will make the simplifying assumption
that the query is simply text.4 The initial stages of processing a text query should
mirror the processing steps that are used for documents. Words in the query text
must be transformed into the same terms that were produced by document texts,
or there will be errors in the ranking.This sounds obvious, but it has been a source
of problems in a number of search projects. Despite this restriction, there is scope
for some useful differences between query and document transformation, par-
ticularly in stopping and stemming. Other steps, such as parsing the structure or
tokenizing, will either not be needed (keyword queries have no structure) or will
be essentially the same.

We mentioned in section 4.3.3 that stopword removal can be done at query
time instead of during document indexing. Retaining the stopwords in the in-
dexes increases the flexibility of the system to deal with queries that contain stop-
words. Stopwords can be treated as normal words (by leaving them in the query),
removed, or removed except under certain conditions (such as being used with
quote or “+” operators).

Query-based stemming is another technique for increasing the flexibility of the
search engine. If thewords in documents are stemmed during indexing, thewords
in the queries must also be stemmed. There are circumstances, however, where
stemming the query words will reduce the accuracy of the results. The query “fish
village” will, for example, produce very different results from the query “fishing
village”, but many stemming algorithms would reduce “fishing” to “fish”. By not
stemming during document indexing, we are able to make the decision at query
time whether or not to stem “fishing”. This decision could be based on a number
of factors, such as whether the word was part of a quoted phrase.

For query-based stemming to work, we must expand the query using the ap-
propriate word variants, rather than reducing the queryword to aword stem.This
is because documents have not been stemmed. If the query word “fishing” was re-

4 Based on a recent sample of web queries, about 1.5% of queries used quotes, and less
than 0.5% used a “+” operator.



6.2 Query Transformation and Refinement 191

placed with the stem “fish”, the query would no longer match documents that
contained “fishing”. Instead, the query should be expanded to include the word
“fish”. This expansion is done by the system (not the user) using some form of
synonym operator, such as that described in section 7.4.2. Alternatively, we could
index the documents using stems as well aswords.This will make query execution
more efficient, but increases the size of the indexes.

Every stemming algorithm implicitly generates stem classes. A stem class is the
group of words that will be transformed into the same stem by the stemming al-
gorithm. They are created by simply running the stemming algorithm on a large
collection of text and recording which words map to a given stem. Stem classes
can be quite large. For example, here are three stem classes created with the Porter
Stemmer on TREC news collections (the first entry in each list is the stem):

/bank banked banking bankings banks
/ocean oceaneering oceanic oceanics oceanization oceans
/polic polical polically police policeable policed
-policement policer policers polices policial
-policically policier policiers policies policing
-policization policize policly policy policying policys

These classes are not only long (the “polic” class has 22 entries), but they also
contain a number of errors.Thewords relating to “police” and “policy” should not
be in the same class, and this will cause a loss in ranking accuracy. Other words are
not errors, but may be used in different contexts. For example, “banked” is more
often used in discussions of flying and pool, but this stem class will add words
that aremore common in financial discussions.The length of the lists is an issue if
the stem classes are used to expand the query. Adding 22 words to a simple query
will certainly negatively impact response time and, if not done properly using a
synonym operator, could cause the search to fail.

Both of these issues can be addressed using an analysis of word co-occurrence
in the collection of text.The assumption behind this analysis is that word variants
that couldbe substitutes for eachother should co-occur often indocuments.More
specifically, we do the following steps:

1. For all pairs of words in the stem classes, count how often they co-occur in
text windows ofW words.W is typically in the range 50–100.

2. Compute a co-occurrence or association metric for each pair. This measures
how strong the association is between the words.



192 6 Queries and Interfaces

3. Construct a graph where the vertices represent words and the edges are be-
tween words whose co-occurrence metric is above a threshold T .

4. Find the connected components of this graph. These are the new stem classes.
The term association measure used in TREC experiments was based on Dice’s

coefficient. This measure has been used since the earliest studies of term similarity
and automatic thesaurus construction in the 1960s and 1970s. If na is the num-
ber of windows (or documents) containing word a, nb is the number of windows
containing word b, nab is the number of windows containing both words a and b,
andN is the number of text windows in the collection, then Dice’s coefficient is
defined as 2 · nab/(na + nb). This is simply the proportion of term occurrences
that are co-occurrences.There are other possible associationmeasures, which will
be discussed later in section 6.2.3.

Two vertices are in the same connected component of a graph if there is a path
between them. In the case of the graph representing word associations, the con-
nected components will be clusters or groups of words, where each word has an
association above the threshold T with at least one other member of the cluster.
The parameter T is set empirically. We will discuss this and other clustering tech-
niques in section 9.2.

Applying this technique to the three example stem classes, and using TREC
data to do the co-occurrence analysis, results in the following connected compo-
nents:

/policies policy
/police policed policing
/bank banking banks

The new stem classes are smaller, and the inappropriate groupings (e.g., pol-
icy/police) have been split up. In general, experiments show that this technique
produces good ranking effectiveness with a moderate level of query expansion.

What about the “fishing village” query? The relevant stem class produced by
the co-occurrence analysis is

/fish fished fishing

which means that we have not solved that problem. As mentioned before, the
query context determines whether stemming is appropriate. It would be reason-
able to expand the query “fishing in Alaska” with the words “fish” and “fished”,
but not the query “fishing village”. The co-occurrence analysis described earlier



6.2 Query Transformation and Refinement 193

uses context in a general way, but not at the level of co-occurrence with specific
query words.

With the recent availability of large query logs in applications such as web
search, the concept of validating or even generating stemclasses through statistical
analysis canbe extended to these resources. In this case, the analysiswould look for
word variants that tended to co-occur with the same words in queries. This could
be a solution to the fish/fishing problem, in that “fish” is unlikely to co-occurwith
“village” in queries.

Comparing this stemming technique to those described in section 4.3.4, it
could be described as a dictionary-based approach, where the dictionary is gen-
erated automatically based on input from an algorithmic stemmer (i.e., the stem
classes). This technique can also be used for stemming with languages that do
not have algorithmic stemmers available. In that case, the stem classes are based
on very simple criteria, such as grouping all words that have similar n-grams. A
simple example would be to generate classes from words that have the same first
three characters. These initial classes are much larger than those generated by an
algorithmic stemmer, but the co-occurrence analysis reduces the final classes to
similar sizes. Retrieval experiments confirm that typically there is little difference
in ranking effectiveness between an algorithmic stemmer and a stemmer based
on n-gram classes.

6.2.2 Spell Checking and Suggestions

Spell checking is an extremely important part of query processing. Approximately
10–15% of queries submitted to web search engines contain spelling errors, and
people have come to rely on the “Did you mean: ...” feature to correct these er-
rors. Query logs contain plenty of examples of simple errors such as the following
(taken from a recent sample of web queries):

poiner sisters
brimingham news
catamarn sailing
hair extenssions
marshmellow world
miniture golf courses
psyhics
home doceration



194 6 Queries and Interfaces

These errors are similar to those that may be found in a word processing docu-
ment. In addition, however, there will be many queries containing words related
to websites, products, companies, and people that are unlikely to be found in any
standard spelling dictionary. Some examples from the same query log are:

realstateisting.bc.com
akia 1080i manunal
ultimatwarcade
mainscourcebank
dellottitouche

The wide variety in the type and severity of possible spelling errors in queries
presents a significant challenge. In order to discusswhich spelling correction tech-
niques are themost effective for search engine queries, we first have to review how
spelling correction is done for general text.

The basic approach used in many spelling checkers is to suggest corrections
for words that are not found in the spelling dictionary. Suggestions are found by
comparing the word that was not found in the dictionary to words that are in the
dictionary using a similarity measure. The most common measure for compar-
ing words (or more generally, strings) is the edit distance, which is the number of
operations required to transform one of the words into the other. TheDamerau-
Levenshtein distancemetric counts theminimumnumber of insertions, deletions,
substitutions, or transpositions of single characters required to do the transfor-
mation.5 Studies have shown that 80% or more of spelling errors are caused by an
instance of one of these types of single-character errors.

As an example, the following transformations (shown with the type of error
involved) all have Damerau-Levenshtein distance 1 since only a single operation
or edit is required to produce the correct word:

extenssions? extensions (insertion error)
poiner? pointer (deletion error)
marshmellow?marshmallow (substitution error)
brimingham? birmingham (transposition error)

The transformation doceration? decoration, on the other hand, has edit dis-
tance 2 since it requires two edit operations:

5 The Levenshtein distance is similar but does not include transposition as a basic opera-
tion.



6.2 Query Transformation and Refinement 195

doceration? deceration
deceration? decoration
A variety of techniques and data structures have been used to speed up the

calculation of edit distances between the misspelled word and the words in the
dictionary. These include restricting the comparison to words that start with the
same letter (since spelling errors rarely change thefirst letter),words that are of the
same or similar length (since spelling errors rarely change the length of the word),
and words that sound the same.6 In the latter case, phonetic rules are used tomap
words to codes.Wordswith the same codes are considered as possible corrections.
The Soundex code is a simple type of phonetic encoding that was originally used
for the problemofmatchingnames inmedical records.The rules for this encoding
are:

1. Keep the first letter (in uppercase).
2. Replace these letters with hyphens: a, e, i, o, u, y, h, w.
3. Replace the other letters by numbers as follows:

1: b, f, p, v
2: c, g, j, k, q, s, x, z
3: d, t
4: l
5: m, n
6: r

4. Delete adjacent repeats of a number.
5. Delete the hyphens.
6. Keep the first three numbers or pad out with zeros.

Some examples of this code are:

extenssions? E235; extensions? E235
marshmellow?M625;marshmallow?M625
brimingham? B655; birmingham? B655
poiner? P560; pointer? P536

The last example shows that the correct word may not always have the same
Soundex code. More elaborate phonetic encodings have been developed specifi-
cally for spelling correction (e.g., theGNUAspell checker7 uses a phonetic code).

6 A word that is pronounced the same as another word but differs in meaning is called a
homophone.

7 http://aspell.net/



196 6 Queries and Interfaces

These encodings can be designed so that the edit distance for the codes can be used
to narrow the search for corrections.

A given spelling error may have many possible corrections. For example, the
spelling error “lawers” has the following possible corrections (among others) at
edit distance 1: lawers? lowers, lawyers, layers, lasers, lagers. The spelling correc-
tor has to decide whether to present all of these to the user, and in what order to
present them. A typical policy would be to present them in decreasing order of
their frequency in the language. Note that this process ignores the context of the
spelling error. For example, if the error occurred in the query “trial lawers”, this
would have no impact on the presentation order of the suggested corrections.The
lack of context in the spelling correction process also means that errors involv-
ing valid words will be missed. For example, the query “miniature golf curses” is
clearly an example of a single-character deletion error, but this error has produced
the valid word “curses” and so would not be detected.

The typical interface for the “Did youmean:...” feature requires the spell check-
er to produce the single best suggestion. This means that ranking the suggestions
using context and frequency information is very important for query spell check-
ing compared to spell checking in a word processor, where suggestions can be
made available on a pull-down list. In addition, queries contain a large number of
run-on errors, where word boundaries are skipped or mistyped. The two queries
“ultimatwarcade” and “mainscourcebank” are examples of run-on errors that also
contain single-character errors. With the appropriate framework, leaving out a
separator such as a blank can be treated as just another class of single-character
error.

The noisy channel model for spelling correction is a general framework that
can address the issues of ranking, context, and run-on errors. The model is called
a “noisy channel” because it is based on Shannon’s theory of communication
(Shannon & Weaver, 1963). The intuition is that a person chooses a word w to
output (i.e., write), based on a probability distribution P (w). The person then
tries to write the word w, but the noisy channel (presumably the person’s brain)
causes the person to write the word e instead, with probability P (e|w).

The probabilitiesP (w), called the languagemodel , capture information about
the frequency of occurrence of a word in text (e.g., what is the probability of the
word “lawyer” occurring in a document or query?), and contextual information
such as the probability of observing a word given that another word has just been
observed (e.g., what is the probability of “lawyer” following theword “trial”?).We



6.2 Query Transformation and Refinement 197

will havemore to say about languagemodels inChapter 7, but for nowwe can just
assume it is a description of word occurrences in terms of probabilities.

The probabilitiesP (e|w), called the errormodel , represent information about
the frequency of different types of spelling errors. The probabilities for words (or
strings) that are edit distance 1 away from the word w will be quite high, for ex-
ample. Words with higher edit distances will generally have lower probabilities,
althoughhomophoneswill have high probabilities.Note that the errormodelwill
have probabilities for writing the correct word (P (w|w)) as well as probabilities
for spelling errors. This enables the spelling corrector to suggest a correction for
all words, even if the originalwordwas correctly spelled. If the highest-probability
correction is the same word, then no correction is suggested to the user. If, how-
ever, the context (i.e., the language model) suggests that another word may be
more appropriate, then it can be suggested. This, in broad terms, is how a spelling
corrector can suggest “course” instead of “curse” for the query “golf curse”.

So howdowe estimate the probability of a correction?What the personwrites
is the word e, so we need to calculate P (w|e), which is the probability that the
correct word isw given that we can see the person wrote e. If we are interested in
finding the correction with the maximum value of this probability, or if we just
want to rank the corrections, it turns out we can use P (e|w)P (w), which is the
product of the error model probability and the language model probability.8

To handle run-on errors and context, the language model needs to have in-
formation about pairs of words in addition to single words. The language model
probability for a word is then calculated as a mixture of the probability that the
word occurs in text and the probability that it occurs following the previousword,
or

?P (w) + (1? ?)P (w|wp)

where ? is a parameter that specifies the relative importance of the two probabili-
ties, andP (w|wp) is the probability of a wordw following the previous wordwp.
As an example, consider the spelling error “fish tink”. To rank the possible correc-
tions for “tink”, wemultiply the error model probabilities for possible corrections
by the language model probabilities for those corrections. The words “tank” and
“think”will bothhave high error-model probabilities since they require only a sin-
gle character correction. In addition, bothwordswill have similar probabilities for
P (w) since both are quite common. The probability P (tank|fish), however,
8 Bayes’ Rule, which is discussed in Chapter 7, is used to express P (w|e) in terms of the
component probabilities.



198 6 Queries and Interfaces

will be much higher than P (think|fish), and this will result in “tank” being a
more likely correction than “think”.

Where does the information for the languagemodel probabilities come from?
In many applications, the best source for statistics about word occurrence in text
will be the collectionof documents that is being searched. In the case ofweb search
(and someother applications), therewill also be a query log containingmillions of
queries submitted to the search engine. Since our task is to correct the spelling of
queries, the query log is likely to be the best source of information. It also reduces
the number of pairs of words that need to be recorded in the language model,
compared to analyzing all possible pairs in a large collection of documents. In
addition to these sources, if a trusted dictionary is available for the application, it
should be used.

The estimation of theP (e|w) probabilities in the errormodel can be relatively
simple or quite complex.The simple approach is to assume that all errors with the
same edit distance have equal probability. Additionally, only strings within a cer-
tain edit distance (usually 1 or 2) are considered. More sophisticated approaches
have been suggested that base the probability estimates on the likelihood of mak-
ing certain types of errors, such as typing an “a” when the intention was to type
an “e” . These estimates are derived from large collections of text by finding many
pairs of correctly and incorrectly spelled words.

Cucerzan and Brill (2004) describe an iterative process for spell checking
queries using information froma query log and dictionary.The steps, in simplified
form, are as follows:

1. Tokenize the query.
2. For each token, a set of alternative words and pairs of words is found using

an edit distance modified by weighting certain types of errors, as described
earlier. The data structure that is searched for the alternatives contains words
and pairs from both the query log and the trusted dictionary.

3. The noisy channel model is then used to select the best correction.
4. The process of looking for alternatives and finding the best correction is re-

peated until no better correction is found.

By having multiple iterations, the spelling corrector can potentially make sugges-
tions that are quite far (in terms of edit distance) from the original query. As an
example, given the query “miniture golfcurses”, the spelling corrector would go
through the following iterations:



6.2 Query Transformation and Refinement 199

miniture golfcurses
miniature golfcourses
miniature golf courses

Experiments with this spelling corrector show that the language model from the
query log is the most important component in terms of correction accuracy. In
addition, using context in the form of word pairs in the language model is crit-
ical. Having at least two iterations in the correction process also makes a signif-
icant difference. The error model was less important, however, and using a sim-
ple model where all errors have the same probability was nearly as effective as the
more sophisticatedmodel.Other studies have shown that the errormodel ismore
important when the languagemodel is based just on the collection of documents,
rather than the query log.

The best approach to building a spelling corrector for queries in a search ap-
plication obviously depends on the data available. If a large amount of query
log information is available, then this should be incorporated. Otherwise, the
sources available will be the collection of documents for the application and, in
some cases, a trusted dictionary. One approach would be to use a general-purpose
spelling corrector, such as Aspell, and create an application-specific dictionary.
Building a spelling corrector based on the noisy channel model, however, is likely
to be more effective and more adaptable, even if query log data is not available.

6.2.3 Query Expansion

In the early development of search engines, starting in the 1960s, an online the-
saurus was considered an essential tool for the users of the system. The thesaurus
described the indexing vocabulary that had been used for the document collec-
tion, and included information about synonyms and related words or phrases.
This was particularly important because the collection had typically been manu-
ally indexed (tagged)9 using the terms in the thesaurus. Because the terms in the
thesaurus were carefully chosen and subject to quality control, the thesaurus was
also referred to as a controlled vocabulary. Using the thesaurus, users could deter-
mine what words and phrases could be used in queries, and could expand an ini-
tial query using synonyms and related words. Table 6.1 shows part of an entry in
9 In information retrieval, indexing is often used to refer to the process of representing
a document using an index term, in addition to the process of creating the indexes to
search the collection. More recently, the process of manual indexing has been called
tagging, particularly in the context of social search applications (see Chapter 10).



200 6 Queries and Interfaces

the Medical Subject (MeSH) Headings thesaurus that is used in the National Li-
brary ofMedicine search applications.10 The“tree number” entries indicate, using
a numbering scheme, where this term is found in the tree of broader and narrow
terms. An “entry term” is a synonym or related phrase for the term.

MeSH Heading Neck Pain
Tree Number C10.597.617.576
Tree Number C23.888.592.612.553
Tree Number C23.888.646.501
Entry Term Cervical Pain
Entry Term Neckache
Entry Term Anterior Cervical Pain
Entry Term Anterior Neck Pain
Entry Term Cervicalgia
Entry Term Cervicodynia
Entry Term Neck Ache
Entry Term Posterior Cervical Pain
Entry Term Posterior Neck Pain

Table 6.1. Partial entry for the Medical Subject (MeSH) Heading “Neck Pain”

Although the use of an explicit thesaurus is less common in current search ap-
plications, a number of techniques have been proposed for automatic and semi-
automatic query expansion. A semi-automatic technique requires user interac-
tion, such as selecting the expansion terms from a list suggested by the expansion
technique.Web search engines, for example, provide query suggestions to the user
in the form of the original query words expanded with one or more additional
words, or replaced with alternative words.

Query expansion techniques are usually based on an analysis of word or term
co-occurrence, in either the entire document collection, a large collection of
queries, or the top-ranked documents in a result list. From this perspective, query-
based stemming can also be regarded as a query expansion technique, with the
expansion terms limited to word variants. Automatic expansion techniques that
use a general thesaurus, such as Wordnet,11 have not been shown to be effective.

10 http://www.nlm.nih.gov/mesh/meshhome.html
11 http://wordnet.princeton.edu/



6.2 Query Transformation and Refinement 201

The key to effective expansion is to choose words that are appropriate for the
context, or topic, of the query. For example, “aquarium” may be a good expan-
sion term for “tank” in the query “tropical fish tanks”, but not appropriate for the
query “armor for tanks”. A general thesaurus lists related terms for many differ-
ent contexts, which is why it is difficult to use automatically. The techniques we
will describe use a variety of approaches to address this problem, such as using all
the words in a query to find related words rather than expanding each word sepa-
rately. One well-known expansion technique, called pseudo-relevance feedback, is
discussed in the next section along with techniques that are based on user feed-
back about the relevance of documents in the results list.

Term associationmeasures are an important part ofmany approaches to query
expansion, and consequently a number of alternatives have been suggested. One
of these, Dice’s coefficient, was mentioned in section 6.2.1. The formula for this
measure is

2 · nab
na + nb

rank
=

nab
na + nb

where rank= means that the formula is rank equivalent (produces the same ranking
of terms).12

Another measure, mutual information, has been used in a number of studies
of word collocation. For two words (or terms) a and b, it is defined as

log P (a, b)
P (a)P (b)

and measures the extent to which the words occur independently.13 P (a) is the
probability that word a occurs in a text window of a given size, P (b) is the prob-
ability that word b occurs in a text window, and P (a, b) is the probability that
a and b occur in the same text window. If the occurrences of the words are in-
dependent, P (a, b) = P (a)P (b) and the mutual information will be 0. As an
example, we might expect that the two words “fishing” and “automobile” would
occur relatively independently of one another. If two words tend to co-occur, for

12 More formally, two functions are defined to be rank equivalent if they produce the
same ordering of items when sorted according to function value. Monotonic trans-
forms (such as log), scaling (multiplying by a constant), and translation (adding a con-
stant) are all examples of rank-preserving operations.

13 This is actually the pointwisemutual information measure, just to be completely accu-
rate.



202 6 Queries and Interfaces

example “fishing” and “boat”,P (a, b)will be greater thanP (a)P (b) and themu-
tual information will be higher.

To calculate mutual information, we use the following simple normalized fre-
quency estimates for the probabilities: P (a) = na/N , P (b) = nb/N , and
P (a, b) = nab/N , where na is the number of windows (or documents) contain-
ing word a, nb is the number of windows containing word b, nab is the number of
windows containing both words a and b, and N is the number of text windows
in the collection. This gives the formula:

log P (a, b)
P (a)P (b)

= logN. nab
na.nb

rank
=

nab
na.nb

A problem that has been observed with this measure is that it tends to favor
low-frequency terms. For example, consider two words with frequency 10 (i.e.,
na = nb = 10) that co-occur half the time (nab = 5). The association measure
for these two terms is 5×10?2. For two termswith frequency 1,000 that co-occur
half the time (nab = 500), the association measure is 5 × 10?4. The expected
mutual information measure addresses this problem by weighting the mutual in-
formation value using the probabilityP (a, b). Although the expected mutual in-
formation in general is calculated over all combinations of the events of word oc-
currence and non-occurrence, we are primarily interested in the case where both
terms occur, giving the formula:

P (a, b). log P (a, b)
P (a)P (b)

=
nab
N

log(N. nab
na.nb

)
rank
= nab. log(N.

nab
na.nb

)

If we take the same example as before and assume N = 106, this gives an as-
sociation measure of 23.5 for the low-frequency terms, and 1,350 for the high-
frequency terms, clearly favoring the latter case. In fact, the bias toward high-
frequency terms can be a problem for this measure.

Another popular associationmeasure that has beenused in a variety of applica-
tions isPearson’s Chi-squared (?2)measure.Thismeasure compares the number of
co-occurrences of two words with the expected number of co-occurrences if the
two words were independent, and normalizes this comparison by the expected
number. Using our estimates, this gives the formula:

(nab ?N.naN .
nb
N
)2

N.na
N
.nb
N

rank
=

(nab ? 1N .na.nb)
2

na.nb



6.2 Query Transformation and Refinement 203

The term N.P (a).P (b) = N.na
N
.nb
N

is the expected number of co-occurrences
if the two terms occur independently. The ?2 test is usually calculated over all
combinations of the events of word occurrence and non-occurrence, similar to
the expectedmutual informationmeasure, but our focus is on the casewhere both
terms co-occur. In fact, when N is large, this restricted form of ?2 produces the
same term rankings as the full form. It should also be noted that?2 is very similar
to the mutual information measure and may be expected to favor low-frequency
terms.

Table 6.2 summarizes the association measures we have discussed. To see how
they work in practice, we have calculated the top-ranked terms in a TREC news
collection using each measure for the words in the sample query “tropical fish”.

Measure Formula
Mutual information nabna.nb

(MIM )
Expected Mutual Information nab. log(N. nabna.nb )

(EMIM )

Chi-square (nab?
1
N
.na.nb)

2

na.nb
(?2)

Dice’s coefficient nabna+nb
(Dice)

Table 6.2. Term association measures

Table 6.3 shows the strongly associated words for “tropical” assuming an un-
limitedwindow size (in otherwords, co-occurrences are counted at the document
level). There are two obvious features to note. The first is that the ranking for
?2 is identical to the one for MIM. The second is that MIM and ?2 favor low-
frequency words, as expected. These words are not unreasonable (“itto”, for ex-
ample, is the International Tropical Timber Organization, and “xishuangbanna”
is a Chinese tropical botanic garden), but they are so specialized that they are un-
likely to be much use for many queries. The top terms for the EMIM and Dice
measures are much more general and, in the case of EMIM, sometimes too gen-
eral (e.g., “most”).

Table 6.4 shows the top-ranked words for “fish”. Note that because this is a
higher-frequency term, the rankings forMIM and ?2 are no longer identical, al-
though both still favor low-frequency terms. The top-ranked words for EMIM



204 6 Queries and Interfaces

MIM EMIM ?2 Dice
trmm forest trmm forest
itto tree itto exotic

ortuno rain ortuno timber
kuroshio island kuroshio rain

ivirgarzama like ivirgarzama banana
biofunction fish biofunction deforestation
kapiolani most kapiolani plantation
bstilla water bstilla coconut

almagreb fruit almagreb jungle
jackfruit area jackfruit tree
adeo world adeo rainforest

xishuangbanna america xishuangbanna palm
frangipani some frangipani hardwood

yuca live yuca greenhouse
anthurium plant anthurium logging

Table 6.3. Most strongly associated words for “tropical” in a collection of TREC news
stories. Co-occurrence counts are measured at the document level.

and Dice are quite similar, although in different ordering. To show the effect of
changing the window size, Table 6.5 gives the top-ranked words found using a
windowof fivewords.The small window size has an effect on the results, although
bothMIM and?2 still find low-frequency terms.Thewords forEMIM are some-
what improved, being more specific. Overall, it appears that the simple Dice’s co-
efficient is the most stable and reliable over a range of window sizes.

Themost significant feature of these tables, however, is that even the best rank-
ings contain virtually nothing that would be useful to expand the query “tropical
fish”! Instead, thewords are associatedwith other contexts, such as tropical forests
and fruits, or fishing conservation. One way to address this problem would be to
findwords that are strongly associatedwith the phrase “tropical fish”.UsingDice’s
coefficient with the same collection of TREC documents as the previous tables,
this produces the following 10 words at the top of the ranking:

goldfish, reptile, aquarium, coral, frog, exotic, stripe, regent, pet, wet

Clearly, this is doing much better at finding words associated with the right con-
text. To use this technique, however, we would have to find associations for every
group of words that could be used in a query. This is obviously impractical, but



6.2 Query Transformation and Refinement 205

MIM EMIM ?2 Dice
zoologico water arlsq species
zapanta species happyman wildlife
wrint wildlife outerlimit fishery
wpfmc fishery sportk water

weighout sea lingcod fisherman
waterdog fisherman longfin boat
longfin boat bontadelli sea

veracruzana area sportfisher habitat
ungutt habitat billfish vessel

ulocentra vessel needlefish marine
needlefish marine damaliscu endanger
tunaboat land bontebok conservation
tsolwana river taucher river
olivacea food orangemouth catch

motoroller endanger sheepshead island

Table 6.4.Most strongly associatedwords for “fish” in a collection of TRECnews stories.
Co-occurrence counts are measured at the document level.

MIM EMIM ?2 Dice
zapanta wildlife gefilte wildlife
plar vessel mbmo vessel

mbmo boat zapanta boat
gefilte fishery plar fishery
hapc species hapc species
odfw tuna odfw catch

southpoint trout southpoint water
anadromous fisherman anadromous sea

taiffe salmon taiffe meat
mollie catch mollie interior

frampton nmf frampton fisherman
idfg trawl idfg game

billingsgate halibut billingsgate salmon
sealord meat sealord tuna
longline shellfish longline caught

Table 6.5.Most strongly associatedwords for “fish” in a collection of TRECnews stories.
Co-occurrence counts are measured in windows of five words.



206 6 Queries and Interfaces

there are other approaches that accomplish the same thing.One alternativewould
be to analyze the word occurrences in the retrieved documents for a query. This
is the basis of pseudo-relevance feedback, which is discussed in the next section.
Another approach that has been suggested is to index everyword in the collection
by thewords that co-occurwith it, creating a virtual document14 representing that
word. For example, the following list is the top 35most strongly associated words
for “aquarium” (using Dice’s coefficient):

zoology, cranmore, jouett, zoo, goldfish, fish, cannery, urchin, reptile,
coral, animal, mollusk, marine, underwater, plankton, mussel, oceanog-
raphy, mammal, species, exhibit, swim, biologist, cabrillo, saltwater, crea-
ture, reef, whale, oceanic, scuba, kelp, invertebrate, park, crustacean, wild,
tropical

These words would form the index terms for the document representing “aquar-
ium”. To find expansion words for a query, these virtual documents are ranked in
the sameway as regular documents, giving a ranking for the correspondingwords.
In our example, the document for “aquarium” contains the words “tropical” and
“fish” with highweights, so it is likely that it would be highly ranked for the query
“tropical fish”. This means that “aquarium” would be a highly ranked expansion
term.Thedocument for aword such as “jungle”, on the other hand,would contain
“tropical” with a high weight but is unlikely to contain “fish”.This document, and
the corresponding word, would be much further down the ranking than “aquar-
ium”.

All of the techniques that rely on analyzing the document collection face both
computational and accuracy challenges due to the huge size and variability in
quality of the collections in search applications. At the start of this section, it was
mentioned that instead of analyzing the document collection, either the result
list or a large collection of queries could be used. Recent studies and experience
indicate that a large query log is probably the best resource for query expansion.
Not only do these logs contain many short pieces of text that are are easier to an-
alyze than full text documents, they also contain other data, such as information
on which documents were clicked on during the search (i.e., clickthrough data).

As an example of how the query log can be used for expansion, the following
list shows the 10 most frequent words associated with queries that contain “trop-
ical fish” in a recent query log sample from a popular web search engine:

14 Sometimes called a context vector.



6.2 Query Transformation and Refinement 207

stores, pictures, live, sale, types, clipart, blue, freshwater, aquarium, sup-
plies

These words indicate the types of queries that people tend to submit about trop-
ical fish (sales, supplies, pictures), and most would be good words to suggest for
query expansion. In current systems, suggestions are usually made in the form of
whole queries rather than expansion words, and here again the query log will be
extremely useful in producing the best suggestions. For example, “tropical fish
supplies” will be a much more common query than “supplies tropical fish” and
would be a better suggestion for this expansion.

From this perspective, query expansion can be reformulated as a problem of
finding similar queries, rather than expansion terms. Similar queries may not al-
ways contain the same words. For example, the query “pet fish sales” may be a
reasonable suggestion as an alternative to “tropical fish”, even though it doesn’t
contain the word “tropical”. It has long been recognized that semantically similar
queries canbe foundby grouping thembasedon the relevant documents theyhave
in common, rather than just the words. Clickthrough data is very similar to rele-
vance data, and recent studies have shown that queries canbe successfully grouped
or clustered based on the similarity of their clickthrough data.Thismeans that ev-
ery query is represented using the set of pages that are clicked on for that query,
and the similarity between the queries is calculated using ameasure such as Dice’s
coefficient, except that in this case nab will be the number of clicked-on pages the
two queries have in common, and na, nb are the number of pages clicked on for
each query.

In summary, both automatic and semi-automatic query expansion methods
have been proposed, although the default in many search applications is to sug-
gest alternative queries to the user. Some termassociationmeasures are better than
others, but term association based on single words does not produce good expan-
sion terms, because it does not capture the context of the query. The best way to
capture query context is to use a query log, both to analyze word associations and
to find similar queries based on clickthrough data. If there is no query log avail-
able, the best alternative would be to use pseudo-relevance feedback, as described
in the next section. Of the methods described for constructing an automatic the-
saurus based on the document collection, the best alternative is to create virtual
documents for each word and rank them for each query.



208 6 Queries and Interfaces

6.2.4 Relevance Feedback

Relevance feedback is a query expansion and refinement technique with a long
history. First proposed in the 1960s, it relies on user interaction to identify rel-
evant documents in a ranking based on the initial query. Other semi-automatic
techniques were discussed in the last section, but instead of choosing from lists of
terms or alternative queries, in relevance feedback the user indicates which docu-
ments are interesting (i.e., relevant) and possiblywhich documents are completely
off-topic (i.e., non-relevant). Based on this information, the system automatically
reformulates the query by adding terms and reweighting the original terms, and a
new ranking is generated using this modified query.

This process is a simple example of using machine learning in information
retrieval, where training data (the identified relevant and non-relevant docu-
ments) is used to improve the system’s performance.Modifying the query is in fact
equivalent to learning a classifier that distinguishes between relevant and non-
relevant documents. We discuss classification and classification techniques fur-
ther inChapters 7 and9.Relative tomany other applications ofmachine learning,
however, the amount of training data generated in relevance feedback is extremely
limited since it is based on the user’s input for this query session only, and not on
historical data such as clickthrough.

The specific method for modifying the query depends on the underlying re-
trieval model. In the next chapter, we describe how relevance feedback works in
the vector space model and the probabilistic model. In general, however, words
that occur more frequently in the relevant documents than in the non-relevant
documents, or in the collection as a whole, are added to the query or increased
in weight.The same general idea is used in the technique of pseudo-relevance feed-
back, where instead of asking the user to identify relevant documents, the system
simply assumes that the top-ranked documents are relevant.Words that occur fre-
quently in these documents may then be used to expand the initial query. Once
again, the specifics of how this is done depend on the underlying retrieval model.
Wedescribe pseudo-relevance feedback based on the languagemodel approach to
retrieval in the next chapter. The expansion terms generated by pseudo-relevance
feedback will depend on the whole query, since they are extracted from docu-
ments ranked highly for that query, but the quality of the expansion will be de-
termined by how many of the top-ranked documents in the initial ranking are in
fact relevant.

As a simple example of how this process works, consider the ranking shown
in Figure 6.1, which was generated using a popular search engine with the query



6.2 Query Transformation and Refinement 209

1. Badmans Tropical Fish

A freshwater aquarium page covering all aspects of the tropical fish hobby. ... to 

Badman's Tropical Fish. ... world of aquariology with Badman's Tropical Fish. ... 

2. Tropical Fish

Notes on a few species and a gallery of photos of African cichlids. 

3. The Tropical Tank Homepage - Tropical Fish and Aquariums

Info on tropical fish and tropical aquariums, large fish species index with ... Here you 

will find lots of information on Tropical Fish and Aquariums. ... 

4. Tropical Fish Centre

Offers a range of aquarium products, advice on choosing species, feeding, and health 

care, and a discussion board. 

5. Tropical fish - Wikipedia, the free encyclopedia

Tropical fish are popular aquarium fish , due to their often bright coloration. ... Practical 

Fishkeeping • Tropical Fish Hobbyist • Koi. Aquarium related companies: ... 

6. Tropical Fish Find

Home page for Tropical Fish Internet Directory ... stores, forums, clubs, fish facts, 

tropical fish compatibility and aquarium ... 

7. Breeding tropical fish

... intrested in keeping and/or breeding Tropical, Marine, Pond and Coldwater fish. ... 

Breeding Tropical Fish ... breeding tropical, marine, coldwater & pond fish. ... 

8. FishLore

Includes tropical freshwater aquarium how-to guides, FAQs, fish profiles, articles, and 

forums. 

9. Cathy's Tropical Fish Keeping

Information on setting up and maintaining a successful freshwater aquarium. 

10.Tropical Fish Place

Tropical Fish information for your freshwater fish tank ... great amount of information 

about a great hobby, a freshwater tropical fish tank. ... 

Fig. 6.1. Top ten results for the query “tropical fish”

“tropical fish”. To expand this query using pseudo-relevance feedback, we might
assume that all these top 10 documents were relevant. By analyzing the full text
of these documents, the most frequent terms, with their frequencies, can be iden-
tified as:

a (926), td (535), href (495), http (357), width (345), com (343), nbsp
(316), www (260), tr (239), htm (233), class (225), jpg (221)



210 6 Queries and Interfaces

Clearly, these words are not appropriate to use as expansion terms, because they
consist of stopwords and HTML expressions that will be common in the whole
collection. In other words, they do not represent the topics covered in the top-
ranked documents. A simple way to refine this process is to count words in the
snippets of the documents and ignore stopwords. This analysis produces the fol-
lowing list of frequent words:

tropical (26), fish (28), aquarium (8), freshwater (5), breeding (4),
information (3), species (3), tank (2), Badman’s (2), page (2), hobby (2),
forums (2)

These words are much better candidates for query expansion, and do not have
the problem of inadequate context that occurs when we try to expand “tropical”
and “fish” separately. If the user was, however, specifically interested in breeding
tropical fish, the expansion terms could be improved using true relevance feed-
back, where the document ranked seventh would be explicitly tagged as relevant.
In this case, the most frequent terms are:

breeding (4), fish (4), tropical (4), marine (2), pond (2), coldwater (2),
keeping (1), interested (1)

Themajor effect of using this list would be to increase theweight of the expansion
term “breeding”. The specific weighting, as we have said, depends on the underly-
ing retrieval model.

Both relevance feedback andpseudo-relevance feedback have been extensively
investigated in the research literature, and have been shown to be effective tech-
niques for improving ranking.They are, however, seldom incorporated into oper-
ational search applications. In the case of pseudo-relevance feedback, this appears
to be primarily because the results of this automatic process can be unpredictable.
If the initial ranking does not contain many relevant documents, the expansion
terms foundbypseudo-relevance feedback are unlikely to behelpful and, for some
queries, can make the ranking significantly worse. To avoid this, the candidate ex-
pansion terms could be shown to the user, but studies have shown that this is not
particularly effective. Suggesting alternative queries based on an analysis of query
logs is a more reliable alternative for semi-automatic query expansion.

Relevance feedback, on the other hand, has been used in some applications,
such as document filtering. Filtering involves tracking a person’s interests over
time, and some applications allow people to modify their profiles using relevance
feedback. Another simple use of relevance feedback is the “more like this” fea-
ture in some early web search engines.This feature allowed users to click on a link



6.2 Query Transformation and Refinement 211

associated with each document in a result list in order to generate a ranked list
of other documents similar to the clicked-on document. The new ranked list of
documents was based on a query formed by extracting and weighting important
words from the clicked-on document. This is exactly the relevance feedback pro-
cess, but limited to a single relevant document for training data.

Although these applications have had some success, the alternative approach
of asking users to choose a different query from a list of suggested queries is cur-
rently more popular. There is no guarantee, of course, that the suggested queries
will contain exactly what the user is looking for, and in that sense relevance feed-
back supports more precise query reformulation. There is an assumption, how-
ever, underlying the use of relevance feedback: that the user is looking for many
relevant documents, not just the one or two that may be in the initial ranked list.
For somequeries, such as looking for background information on a topic, thismay
be true, but for many queries in the web environment, the user will be satisfied
with the initial ranking and will not need relevance feedback. Lists of suggested
queries will be helpful when the initial query fails, whereas relevance feedback is
unlikely to help in that case.

6.2.5 Context and Personalization

One characteristic ofmost current search engines is that the results of a query will
be the same regardless of who submitted the query, why the query was submit-
ted, where the query was submitted, or what other queries were submitted in the
same session. All that matters is what words were used to describe the query. The
other factors, known collectively as the query context, will affect the relevance of
retrieved documents and could potentially have a significant impact on the rank-
ing algorithm. Most contextual information, however, has proved to be difficult
to capture and represent in a way that provides consistent effectiveness improve-
ments.

Much research has been done, in particular, on learning user models or pro-
files to represent a person’s interests so that a search can be personalized. If the
system knew that a person was interested in sports, for example, the documents
retrieved for the query “vikings”may be different than those retrieved by the same
query for a person interested in history. Although this idea is appealing, there are
a number of problems with actually making it work. The first is the accuracy of
the user models.Themost common proposal is to create the profiles based on the
documents that the person looks at, such as web pages visited, email messages,



212 6 Queries and Interfaces

or word processing documents on the desktop. This type of profile represents a
person using words weighted by their importance. Words that occur frequently
in the documents associated with that person, but are not commonwords in gen-
eral, will have the highest weights. Given that documents contain hundreds or
even thousands of words, and the documents visited by the person represent only
a snapshot of their interests, these models are not very specific. Experiments have
shown that using such models does not improve the effectiveness of ranking on
average.

An alternative approach would be to ask the user to describe herself using pre-
defined categories. In addition to requiring additional (and optional) interactions
that most people tend to avoid, there is still the fundamental problem that some-
onewith a general interest in sportsmay still want to ask a question about history.
This suggests that a category of interest could be specified for each query, such as
specifying the “history” category for the query “vikings”, but this is no different
than simply entering a less ambiguous query. It ismuchmore effective for a person
to enter an extra word or two in her query to clarify it—such as “vikings quarter-
backs” or “vikings exploration”, for example—than to try to classify a query into
a limited set of categories.

Another issue that is raised by any approach to personalization based on user
models is privacy. People have understandable concerns about personal details be-
ing recorded in corporate and government databases. In response, techniques for
maintaining anonymity while searching and browsing on the Web are becoming
an increasingly popular area for research and development. Given this, a search
engine that creates profiles based on web activity may be viewed negatively, espe-
cially since the benefit of doing this is currently not clear.

Problems with user modeling and privacy do not mean that contextual infor-
mation is not useful, but rather that the benefits of any approach based on context
need to be examined carefully. There are examples of applications where the use
of contextual information is clearly effective. One of these is the use of query logs
and clickthrough data to improve web search. The context in this case is the his-
tory of previous searches and search sessions that are the same or very similar. In
general, this history is based on the entire user population. A particular person’s
search history may be useful for “caching” results for common search queries, but
learning from a large number of queries across the population appears to bemuch
more effective.

Another effective application of context is local search, which uses geographic
information derived from the query, or from the location of the device that the



6.2 Query Transformation and Refinement 213

query comes from, tomodify the ranking of search results. For example, the query
“fishing supplies” will generate a long list of web pages for suppliers from all over
the country (or the world). The query “fishing supplies Cape Cod”, however,
should use the context provided by the location “Cape Cod” to rank suppliers in
that region higher than any others. Similarly, if the query “fishing supplies” came
from amobile device in a town inCapeCod, then this information could be used
to rank suppliers by their proximity to that town.

Local search based on queries involves the following steps:

1. Identify the geographic region associated with web pages. This is done either
by using location metadata that has been manually added to the document,
or by automatically identifying locations, such as place names, city names, or
country names, in the document text.

2. Identify the geographic region associated with the query using automatic
techniques. Analysis of query logs has shown that 10–15% of queries contain
some location reference.

3. Rank web pages using a comparison of the query and document location in-
formation in addition to the usual text- and link-based features.

Automatically identifying the location information in text is a specific exam-
ple of the information extraction techniques mentioned in Chapter 4. Location
names are mapped to specific regions and coordinates using a geographic ontol-
ogy15 and algorithms developed for spatial reasoning in geographic information
systems. For example, the location “Cape Cod” in a document might be mapped
to bounding rectangles based on latitude and longitude, as shown in Figure 6.2,
whereas a town location would be mapped to more specific coordinates (or a
smaller bounding rectangle). Although this sounds straightforward, there are
many issues involved in identifying location names (for example, there are more
than 35 places named Springfield in the United States), deciding which locations
are significant (if a web page discusses the “problems withWashington lobbyists”,
should “Washington” be used as locationmetadata?), and combiningmultiple lo-
cation references in a document.
15 Anontology is essentially the same thing as a thesaurus. It is a representationof the con-

cepts in a domain and the relationships between them, whereas a thesaurus describes
words, phrases, and relationships between them.Ontologies usually have a richer set of
relationships than a thesaurus. A taxonomy is another term used to describe categories
of concepts.



214 6 Queries and Interfaces

The geographic comparison used in the ranking could involve inclusion (for
example, the location metadata for a supplier’s web page indicates that the sup-
plier is located in the bounding box that represents Cape Cod), distance (for ex-
ample, the supplier is within 10 miles of the town that the query mentioned), or
other spatial relationships. From both an efficiency and effectiveness perspective,
there will be implications for exactly how and when the geographic information
is incorporated into the ranking process.

Fig. 6.2. Geographic representation of Cape Cod using bounding rectangles

To summarize, the most useful contextual information for improving search
quality is based on past interactions with the search engine (i.e., the query log
and session history). Local search based on geographic context can also produce
substantial improvements for a subset of queries. In both cases, context is used to
provide additional features to enhance the original query (query expansion pro-
vides additional words, and local search provides geographic distance). To under-
stand the context for a specific query, however, there is no substitute for the user
providing a more specific query. Indeed, local search in most cases relies on the
location being specified in the query. Typically, more specific queries come from
users examining the results and then reformulating the query. The results display,
whichwe discuss next, must convey the context of the query termmatches so that
the user can decide which documents to look at in detail or how to reformulate
the query.



6.3 Showing the Results 215

6.3 Showing the Results

6.3.1 Result Pages and Snippets

Successful interactions with a search engine depend on the user understanding
the results. Many different visualization techniques have been proposed for dis-
playing search output (Hearst, 1999), but formost search engines the result pages
consist of a ranked list of document summaries that are linked to the actual doc-
uments or web pages. A document summary for a web search typically contains
the title and URL of the web page, links to live and cached versions of the page,
and, most importantly, a short text summary, or snippet, that is used to convey the
content of the page. In addition, most result pages contain advertisements con-
sisting of short descriptions and links. Query words that occur in the title, URL,
snippet, or advertisements are highlighted tomake them easier to identify, usually
by displaying them in a bold font.

Figure 6.3 gives an example of a document summary from a result page for
a web search. In this case, the snippet consists of two partial sentences. Figure
6.1 gives more examples of snippets that are sometimes full sentences, but often
text fragments, extracted from the web page. Some of the snippets do not even
contain the query words. In this section, we describe some of the basic features of
the algorithms used for snippet generation.

Tropical Fish

One of the U.K.s Leading suppliers of Tropical, Coldwater, Marine 

Fish and Invertebrates plus.. . next day fish delivery service ...  

www.tropicalfish.org.uk/tropical_fish.htm Cached page

Fig. 6.3. Typical document summary for a web search

Snippet generation is an example of text summarization. Summarization tech-
niques have been developed for a number of applications, but primarily have been
tested using news stories from the TREC collections. A basic distinction is made
between techniques that produce query-independent summaries and those that
produce query-dependent summaries. Snippets in web search engine result pages
are clearly query-dependent summaries, since the snippet that is generated for a
page will depend on the query that retrieved it, but some query-independent fea-
tures, such as the position of the text in the page andwhether the text is in a head-
ing, are also used.



216 6 Queries and Interfaces

The development of text summarization techniques started with H. P. Luhn
in the 1950s (Luhn, 1958). Luhn’s approach was to rank each sentence in a doc-
ument using a significance factor and to select the top sentences for the summary.
The significance factor for a sentence is calculated based on the occurrence of sig-
nificant words. Significant words are defined in his work as words of medium fre-
quency in the document, where “medium” means that the frequency is between
predefined high-frequency and low-frequency cutoff values. Given the significant
words, portions of the sentence that are “bracketed” by these words are consid-
ered, with a limit set for the number of non-significant words that can be between
two significant words (typically four). The significance factor for these bracketed
text spans is computed by dividing the square of the number of significant words
in the span by the total number of words. Figure 6.4 gives an example of a text
span for which the significance factor is 42/7 = 2.3. The significance factor for
a sentence is the maximum calculated for any text span in the sentence.

w  w  w  w  w  w  w  w  w  w  w. 

                        (Initial sentence) 

 

w  w  s  w  s  s  w  w  s  w  w. 

                (Identify significant words) 

 

w  w [s  w  s  s  w  w  s] w  w. 

(Text span bracketed by significant words) 

 

Fig. 6.4. An example of a text span of words (w) bracketed by significant words (s) using
Luhn’s algorithm

Tobemore specific about the definitionof a significantword, the following is a
frequency-based criterion that has been used successfully inmore recent research.
If fd,w is the frequency of word w in document d, then w is a significant word if
it is not a stopword (which eliminates the high-frequency words), and

fd,w ?

???
7? 0.1× (25? sd), if sd < 25
7, if 25 ? sd ? 40
7 + 0.1× (sd ? 40), otherwise,

where sd is the number of sentences in document d. As an example, the second
page ofChapter 1of this book contains less than25 sentences (roughly 20), and so
the significantwordswill benon-stopwordswith a frequency greater thanor equal



6.3 Showing the Results 217

to 6.5. The only words that satisfy this criterion are “information” (frequency 9),
“story” (frequency 8), and “text” (frequency 7).

Most work on summarization since Luhn has involved improvements to this
basic approach, including better methods of selecting significant words and se-
lecting sentences or sentence fragments. Snippet generation techniques can also
be viewed as variations of Luhn’s approach with query words being used as the
significant words and different sentence selection criteria.

Typical features that would be used in selecting sentences for snippets to sum-
marize a text document such as a news story would include whether the sentence
is a heading, whether it is the first or second line of the document, the total num-
ber of query terms occurring in the sentence, the number of unique query terms
in the sentence, the longest contiguous run of query words in the sentence, and
a density measure of query words, such as Luhn’s significance factor. In this ap-
proach, aweighted combination of featureswould be used to rank sentences.Web
pages, however, often are much less structured than a news story, and can contain
a lot of text that would not be appropriate for snippets. To address this, snip-
pet sentences are often selected from the metadata associated with the web page,
such as the “description” identified by the <meta name=”description” content= ...>
HTML tags, or from external sources, such as web directories.16 Certain classes
of web pages, such as Wikipedia entries, are more structured and have snippet
sentences selected from the text.

Although many variations are possible for snippet generation and document
summaries in result pages, somebasic guidelines for effective summaries have been
derived from an analysis of clickthrough data (Clarke et al., 2007). The most im-
portant is that whenever possible, all of the query terms should appear in the
summary, showing their relationship to the retrieved page. When query terms
are present in the title, however, they need not be repeated in the snippet.This al-
lows for the possibility of using sentences from metadata or external descriptions
that may not have query terms in them. Another guideline is that URLs should
be selected and displayed in a manner that emphasizes their relationship to the
query by, for example, highlighting the query terms present in the URL. Finally,
search engine users appear to prefer readable prose in snippets (such as complete
or near-complete sentences) rather than lists of keywords and phrases. A feature
that measures readability should be included in the computation of the ranking
for snippet selection.

16 For example, the Open Directory Project, http://www.dmoz.org.



218 6 Queries and Interfaces

The efficient implementation of snippet generation will be an important part
of the search engine architecture since the obvious approach of finding, opening,
and scanning document files would lead to unacceptable overheads in an envi-
ronment requiring high query throughput. Instead, documents must be fetched
from a local document store or cache at query time and decompressed.The docu-
ments that are processed for snippet generation should have all HTML tags and
other “noise” (such as Javascript) removed, althoughmetadatamust still be distin-
guished from text content. In addition, sentence boundaries should be identified
andmarked at indexing time, to avoid this potentially time-consuming operation
when selecting snippets.

6.3.2 Advertising and Search

Advertising is a key component ofweb search engines since that is how companies
generate revenue. In the case of advertising presented with search results (spon-
sored search), the goal is to find advertisements that are appropriate for the query
context. When browsing web pages, advertisements are selected for display based
on the contents of pages. Contextual advertising is thought to lead to more user
clicks on advertisements (clickthrough), which is how payments for advertising
are determined. Search engine companies maintain a database of advertisements,
which is searched to find the most relevant advertisements for a given query or
web page. An advertisement in this database usually consists of a short text de-
scription and a link to aweb page describing the product or service inmore detail.
Searching the advertisement database can therefore be considered a special case of
general text search.

Nothing is ever that simple, however. Advertisements are not selected solely
based on their ranking in a simple text search. Instead, advertisers bid for key-
words that describe topics associated with their product. The amount bid for a
keyword thatmatches a query is an important factor in determining which adver-
tisement is selected. In addition, some advertisements generatemore clickthrough
because they are more appealing to the user population. The popularity of an ad-
vertisement, as measured by the clickthrough over time that is captured in the
query log, is another significant factor in the selection process. The popularity
of an advertisement can be measured over all queries or on a query-specific ba-
sis. Query-specific popularity can be used only for queries that occur on a regular
basis. For the large number of queries that occur infrequently (so-called long-tail



6.3 Showing the Results 219

queries17), the general popularity of advertisements can be used. By taking all of
these factors into account, namely relevance, bids, and popularity, the search en-
gine company can devise strategies to maximize their expected profit.

As an example, a pet supplies company that specializes in tropical fish may
place the highest bid for the keywords “aquarium” and “tropical fish”. Given the
query “tropical fish”, this keyword is certainly relevant. The content of the ad-
vertisement for that company should also contain words that match the query.
Given that, this company’s advertisement will receive a high score for relevance
and a high score based on the bid. Even though it has made the highest bid, how-
ever, there is still some chance that another advertisement will be chosen if it is
very popular and has a moderately high bid for the same keywords.

Much ongoing research is directed at developing algorithms to maximize the
advertiser’s profit, drawing on fields such as economics and game theory. From
the information retrieval perspective, the key issues are techniques for matching
short pieces of text (the query and the advertisement) and selecting keywords to
represent the content of web pages.

When searching the Web, there are usually many pages that contain all of the
query terms. This is not the case, however, when queries are compared to adver-
tisements. Advertisements contain a small number of words or keywords relative
to a typical page, and the database of advertisements will be several orders ofmag-
nitude smaller than the Web. It is also important that variations of advertisement
keywords that occur in queries are matched. For example, if a pet supply com-
pany has placed a high bid for “aquarium”, they would expect to receive some
traffic from queries about “fish tanks”. This, of course, is the classic vocabulary
mismatchproblem, andmany techniques have been proposed to address this, such
as stemming and query expansion. Since advertisements are short, techniques for
expanding the documents as well as the queries have been considered.

Two techniques that have performed well in experiments are query reformu-
lation based on user sessions in query logs (Jones et al., 2006) and expansion of
queries and documents using external sources, such as the Web (Metzler et al.,
2007).

Studies have shown that about 50% of the queries in a single session are refor-
mulations,where theusermodifies the original query throughword replacements,

17 The term “long-tail” comes from the long tail of the Zipf distribution described in
Chapter 4. Assuming that a query refers to a specific combination of words, most
queries occur infrequently, and a relatively small number account for the majority of
the query instances that are processed by search engines.



220 6 Queries and Interfaces

insertions, and deletions. Given a large number of candidate associations between
queries and phrases in those queries, statistical tests, such as those described in
section 6.2.3, can be used to determine which associations are significant. For ex-
ample, the association between the phrases “fish tank” and “aquarium”may occur
often in search sessions as users reformulate their original query to find more web
pages. If this happens often enough relative to the frequency of these phrases, it
will be considered significant.The significant associations can be used as potential
substitutions, so that, given an initial query, a ranked list of query reformulations
can be generated, with the emphasis on generating queries that contain matches
for advertising keywords.

The expansion technique consists of using theWeb to expand either the query,
the advertisement text, or both. A form of pseudo-relevance feedback is used
where the advertisement text or keywords are used as a query for a web search,
and expansion words are selected from the highest-ranking web pages. Experi-
ments have shown that the most effective relevance ranking of advertisements is
when exactmatches of thewhole query are rankedfirst, followed by exactmatches
of the whole query with words replaced by stems, followed by a probabilistic sim-
ilarity match of the expanded query with the expanded advertisement. The type
of similarity match used is described in section 7.3.

fish tanks at Target
Find fish tanks Online. Shop & Save at Target.com Today. 

www.target.com

Aquariums
540+ Aquariums at Great Prices. 

fishbowls.pronto.com

Freshwater Fish Species
Everything you need to know to keep your setup clean and beautiful 

www.FishChannel.com 

Pet Supplies at Shop.com
Shop millions of products and buy from our trusted merchants. 

shop.com

Custom Fish Tanks
Choose From 6,500+ Pet Supplies. Save On Custom Fish Tanks!

 shopzilla.com 

Fig. 6.5. Advertisements displayed by a search engine for the query “fish tanks”



6.3 Showing the Results 221

As an example, Figure 6.5 shows the list of advertisements generated by a
search engine for the query “fish tanks”. Two of the advertisements are obvious
matches, in that “fish tanks” occurs in the titles. Two of the others (the second and
fourth) have no words in common with the query, although they are clearly rele-
vant. Using the simple pseudo-relevance feedback technique described in section
6.2.4 would produce both “aquarium” (frequency 10) and “acrylic” (frequency
7) as expansion terms based on the top 10 results.This would give advertisements
containing “aquarium”, such as the second one, a higher relevance score in the se-
lection process. The fourth advertisement has presumably been selected because
the pet supplier has bid on the keyword “aquarium”, and potentially becausemany
people have clicked on this advertisement. The third advertisement is similar and
matches one of the query words.

In the case of contextual advertising for web pages, keywords typically are ex-
tracted from the contents of the page and then used to search the advertising
database to select advertisements for display along with the contents of the page.
Keyword selection techniques are similar to the summarization techniques de-
scribed in the last section, with the focus on keywords rather than sentences. A
simple approach would be to select the top words ranked by a significance weight
based on relative frequencies in the document and the collection of documents.

Amore effective approach is to use a classifier based onmachine learning tech-
niques, as described in Chapter 9. A classifier uses a weighted combination of
features to determine which words and phrases are significant. Typical features
include the frequency in the document, the number of documents in which the
word or phrase occurs, functions of those frequencies (such as taking the log or
normalizing), frequency of occurrence in the query log, location of the word or
phrase in the document (e.g., the title, body, anchor text, metadata, URL), and
whether the word or phrase was capitalized or highlighted in someway.Themost
useful features are the document and query log frequency information (Yih et al.,
2006).

6.3.3 Clustering the Results

The results returned by a search engine are often related to different aspects of the
query topic. In the case of an ambiguous query, these groups of documents can
represent very different interpretations of the query. For example, we have seen
how the query “tropical fish” retrieves documents related to aquariums, pet sup-
plies, images, and other subtopics. An even simpler query, such as “fish”, is likely



222 6 Queries and Interfaces

to retrieve a heterogeneous mix of documents about the sea, software products, a
rock singer, and anything else that happens to use the name “fish”. If a user is in-
terested in a particular aspect of a query topic, scanning through many pages on
different aspects could be frustrating. This is the motivation for the use of cluster-
ing techniques on search results. Clustering groups documents that are similar in
content and labels the clusters so they can be quickly scanned for relevance.

Pictures (38) 

Aquarium Fish (28) 

Tropical Fish Aquarium (26) 

Exporter (31) 

Supplies (32) 

Plants, Aquatic (18) 

Fish Tank (15) 

Breeding (16) 

Marine Fish (16) 

Aquaria (9) 

Fig. 6.6. Clusters formed by a search engine from top-ranked documents for the query
“tropical fish”. Numbers in brackets are the number of documents in the cluster.

Figure 6.6 shows a list of clusters formed by a web search engine from the top-
ranked documents for the query “tropical fish”. This list, where each cluster is de-
scribed or labeled using a single word or phrase and includes a number indicating
the size of the cluster, is displayed to the side of the usual search results. Users that
are interested in one of these clusters can click on the cluster label to see a list of
those documents, rather than scanning the ranked list to find documents related
to that aspect of the query. In this example, the clusters are clearly related to the
subtopics we mentioned previously, such as supplies and pictures.

Clustering techniques are discussed in detail in Chapter 9. In this section, we
focus on the specific requirements for the task of clustering search results.Thefirst
of these requirements is efficiency. The clusters that are generated must be specific
to each query and are based on the top-rankeddocuments for that query.The clus-
ters for popular queries could be cached, but clusterswill still need to be generated
online for most queries, and this process has to be efficient. One consequence of
this is that cluster generation is usually based on the text of document snippets,



6.3 Showing the Results 223

rather than the full text. Snippets typically containmany fewerwords than the full
text, which will substantially speed up calculations that involve comparing word
overlap. Snippet text is also designed to be focused on the query topic, whereas
documents can contain many text passages that are only partially relevant.

The second important requirement for result clusters is that they are easy to
understand. In the example in Figure 6.6, each cluster is labeled by a single word
or phrase, and the user will assume that every document in that cluster will be
described by that concept. In the cluster labeled “Pictures”, for example, it is rea-
sonable to expect that every document would contain some pictures of fish. This
is an example of a monothetic classification, where every member of a class has
the property that defines the class.18 This may sound obvious, but in fact it is not
the type of classification produced bymost clustering algorithms.Membership of
a class or cluster produced by an algorithm such as K-means19 is based on word
overlap. In other words, members of clusters share many properties, but there is
no single defining property. This is known as a polythetic classification. For result
clustering, techniques that produce monothetic classifications (or, at least, those
that appear to bemonothetic) are preferred because they are easier to understand.

As an example, consider documents in the search resultsD1,D2,D3, andD4
that contain the terms (i.e.,words orphrases){a, b, c, d, e, f, g}.The sets of terms
representing each document are:

D1 = {a, b, c}
D2 = {a, d, e}
D3 = {d, e, f, g}
D4 = {f, g}

A monothetic algorithm may decide that a and e are significant terms and pro-
duce the two clusters {D1, D2} (with cluster label a) and {D2, D3} (labeled e).
Note that these clusters are overlapping, in that a document may belong to more
than one cluster. A polythetic algorithm may decide that, based on term overlap,
the only significant cluster is {D2, D3, D4}—D2 has two terms in commonwith
D3, andD3 has two terms in commonwithD4. Note that these three documents
have no single term in common, and it is not clear how this cluster would be la-
beled.
18 This is also the definition of a class proposed by Aristotle over 2,400 years ago.
19 K-means clustering is described in Chapter 9, but basically a document is compared

to representatives of the existing clusters and added to the most similar cluster.



224 6 Queries and Interfaces

Ifwe consider the list of snippets shown inFigure 6.1, a simple clustering based
on the non-stopwords that occur in more than one document would give us:

aquarium (5) (Documents 1, 3, 4, 5, 8)
freshwater (4) (1, 8, 9, 10)
species (3) (2, 3, 4)
hobby (3) (1, 5, 10)
forums (2) (6, 8)

In an actual implementation of this technique, both words and phrases would
be considered and many more of the top-ranking snippets (say, 200) would be
used. Additional features of thewords and phrases, such as whether they occurred
in titles or snippets, the length of the phrase, and the collection frequency of the
phrase, as well as the overlap of the resulting clusters, would be considered in
choosing the final set of clusters.

An alternative approach for organizing results into meaningful groups is to
use faceted classification or, more simply, facets. A faceted classification consists of
a set of categories, usually organized into a hierarchy, together with a set of facets
that describe the important properties associatedwith the category.Aproduct de-
scribed by a faceted classification, for example, could be labeled bymore than one
category and will have values for every facet. Faceted classifications are primar-
ily manually defined, although it is possible to support faceted browsing for data
that has been structured using a database schema, and techniques for construct-
ing faceted classifications automatically are being studied. The major advantage
of manually defining facets is that the categories are in general easier for the user
to understand than automatically generated cluster labels. The disadvantages are
that a classification has to be defined for each new application and domain, and
manual classifications tend to be static and not as responsive to new data as dy-
namically constructed clusters.

Facets are very common in e-commerce sites. Figure 6.7 shows the set of cat-
egories returned for the query “tropical fish” for a search on a popular retailer’s
site. The numbers refer to the number of products in each category that match
the query. These categories are displayed to the side of the search results, similar
to the clusters discussed earlier. If the “Home&Garden” category is selected, Fig-
ure 6.8 shows that what is displayed is a list of subcategories, such as “pet supplies”,
together with facets for this category, which include the brand name, supplier or
vendor name, discount level, and price. A given product, such as an aquarium, can
be found under “pet supplies” and in the appropriate price level, discount level,



6.3 Showing the Results 225

etc.This type of organization provides the user with both guidance and flexibility
in browsing the search results.

Books (7,845) 

Home & Garden (2,477) 

Apparel (236) 

Home Improvement (169) 

Jewelry & Watches (76) 

Sports & Outdoors (71) 

Office Products (68) 

Toys & Games (62) 

Everything Else (44) 

Electronics (26) 

Baby (25) 

 

 

DVD (12) 

Music (11) 

Software (10) 

Gourmet Food (6) 

Beauty (4) 

Automotive (4) 

Magazine Subscriptions (3) 

Health & Personal Care (3) 

Wireless Accessories (2) 

Video Games (1) 
 

 

Fig. 6.7. Categories returned for the query “tropical fish” in a popular online retailer

Home & Garden  

Kitchen & Dining (149) 

Furniture & Décor (1,776) 

Pet Supplies (368) 

Bedding & Bath (51) 

Patio & Garden (22) 

Art & Craft Supplies (12) 

Home Appliances (2) 

Vacuums, Cleaning & Storage 

(107) 

 

Brand   

     <brand names> 

Seller  

     <vendor names> 

 

Discount   

Up to 25% off (563) 

25% ! 50% off (472) 

50% ! 70% off (46) 

70% off or more (46) 

 

Price   

$0!$24 (1,032) 

$25!$49 (394) 

$50!$99 (797) 

$100!$199 (206) 

$200!$499 (39) 

$500!$999 (9) 

$1000!$1999 (5) 

$5000!$9999 (7) 

 

Fig. 6.8. Subcategories and facets for the “Home & Garden” category



226 6 Queries and Interfaces

6.4 Cross-Language Search

By translating queries for one or more monolingual search engines covering dif-
ferent languages, it is possible to do cross-language search20 (see Figure 6.9). A
cross-language search engine receives a query in one language (e.g., English) and
retrieves documents in a variety of other languages (e.g., French and Chinese).
Users typically will not be familiar with a wide range of languages, so a cross-
language search system must do the query translation automatically. Since the
system also retrieves documents in multiple languages, some systems also trans-
late these for the user.

Translated 

Queries

Search engines for 

other languages

Retrieved 

documents 

in other 

languages

User

Translate

Query

Translate

Fig. 6.9. Cross-language search

The most obvious approach to automatic translation would be to use a large
bilingual dictionary that contained the translation of a word in the source lan-
guage (e.g., English) to the target language (e.g., French). Sentenceswould thenbe
translated by looking up eachword in the dictionary.Themain issue is how to deal
with ambiguity, since many words have multiple translations. Simple dictionary-
based translations are generally poor, but a number of techniques have been de-
veloped, such as query expansion (section 6.2.3), that reduce ambiguity and in-

20 Also called cross-language information retrieval (CLIR), cross-lingual search, andmul-
tilingual search.



6.4 Cross-Language Search 227

crease the ranking effectiveness of a cross-language system to be comparable to a
monolingual system.

Themost effective and generalmethods for automatic translation are based on
statisticalmachine translationmodels (Manning&Schütze, 1999).When translat-
ing a document or aweb page, in contrast to a query, not only is ambiguity a prob-
lem, but the translated sentences should also be grammatically correct.Words can
change order, disappear, or become multiple words when a sentence is translated.
Statistical translation models represent each of these changes with a probability.
This means that the model describes the probability that a word is translated into
another word, the probability that words change order, and the probability that
words disappear or become multiple words. These probabilities are used to calcu-
late the most likely translation for a sentence.21

Although amodel that is based on word-to-word translation probabilities has
some similarities to a dictionary-based approach, if the translation probabilities
are accurate, they canmake a large difference to the quality of the translation.Un-
usual translations for an ambiguous word can then be easily distinguished from
more typical translations. More recent versions of these models, called phrase-
based translation models, further improve the use of context in the translation by
calculating the probabilities of translating sequences of words, rather than just in-
dividual words. A word such as “flight”, for example, could be more accurately
translated as the phrase “commercial flight”, instead of being interpreted as “bird
flight”.

The probabilities in statistical machine translation models are estimated pri-
marily by using parallel corpora. These are collections of documents in one lan-
guage together with the translations into one or more other languages. The cor-
pora are obtained primarily from government organizations (such as the United
Nations), news organizations, and by mining the Web, since there are hundreds
of thousands of translated pages.The sentences in the parallel corpora are aligned
either manually or automatically, which means that sentences are paired with
their translations.The aligned sentences are then used for training the translation
model.
21 The simplest form of a machine translation model is actually very similar to the query

likelihood model described in section 7.3.1. The main difference is the incorporation
of a translation probability P (wi|wj), which is the probability that a wordwj can be
translated into the wordwi, in the estimation ofP (Q|D).P (Q|D) is the probability
of generating a query from a document, which in the translation model becomes the
probability that a query is a translation of the document.



228 6 Queries and Interfaces

Special attention has to be paid to the translation of unusual words, espe-
cially proper nouns such as people’s names. For these words in particular, the
Web is a rich resource. Automatic transliteration techniques are also used to ad-
dress the problem of people’s names. Proper names are not usually translated into
another language, but instead are transliterated, meaning that the name is writ-
ten in the characters of another language according to certain rules or based on
similar sounds. This can lead to many alternative spellings for the same name.
For example, the Libyan leader Muammar Qaddafi’s name can found in many
different transliterated variants on web pages, such as Qathafi, Kaddafi, Qadafi,
Gadafi, Gaddafi, Kathafi, Kadhafi, Qadhafi, Qazzafi, Kazafi, Qaddafy, Qadafy,
Quadhaffi, Gadhdhafi, al-Qaddafi, Al-Qaddafi, and Al Qaddafi. Similarly, there
are a number of variants of “Bill Clinton” on Arabic web pages.

Although they are not generally regarded as cross-language search systems,
web search engines can often retrieve pages in a variety of languages. For that
reason, many search engines have made translation available on the result pages.
Figure 6.10 shows an example of a page retrieved for the query “pecheur france”,
where the translation option is shown as a hyperlink. Clicking on this link pro-
duces a translation of the page (not the snippet), which makes it clear that the
page contains links to archives of the sportsmagazineLe pêcheur de France, which
is translated as “The fisherman of France”. Although the translation provided is
not perfect, it typically provides enough information for someone to understand
the contents and relevance of the page. These translations are generated automat-
ically usingmachine translation techniques, since any human intervention would
be prohibitively expensive.

Le pêcheur de France archives @ peche poissons - [ Translate this page ]

Le pêcheur de France Les média Revues de pêche Revue de presse Archives de la revue 
Le pêcheur de France janvier 2003 n°234 Le pêcheur de France mars 2003 ...

 

Fig. 6.10. A French web page in the results list for the query “pecheur france”

References and Further Reading

This chapter has covered a wide range of topics that have been studied for a num-
ber of years.Consequently, there aremany references that are relevant andprovide



6.4 Cross-Language Search 229

more detail than we are able to cover here. The following papers and books rep-
resent some of the more significant contributions, but each contains pointers to
other work for people interested in gaining a deeper understanding of a specific
topic.

The advantages and disadvantages of Boolean queries relative to “natural lan-
guage” or keyword queries has been discussed for more than 30 years.This debate
has been particularly active in the legal retrieval field, which saw the introduction
of the first search engines using ranking and simple queries on large collections in
the early 1990s. Turtle (1994) describes one of the few quantitative comparisons
of expert Boolean searching to ranking based on simple queries, and found that
simple queries are surprisingly effective, even in this professional environment.
The next chapter contains more discussion of the Boolean retrieval model.

A more detailed description of query-based stemming based on corpus analy-
sis can be found in J. Xu and Croft (1998). A good source for the earlier history
of associationmeasures such asDice’s coefficient that have been used for informa-
tion retrieval is van Rijsbergen (1979). Peng et al. (2007) describe a more recent
version of corpus-based stemming for web search.

Kukich (1992) provides an overview of spelling correction techniques. For
a more detailed introduction to minimum edit distance and the noisy channel
model for spelling correction, see Jurafsky and Martin (2006). Guo et al. (2008)
describe an approach that combines query refinement steps, such as spelling cor-
rection, stemming, and identification of phrases, into a singlemodel.Their results
indicate that the unified model can potentially improve effectiveness relative to
carrying out these steps as separate processes.

Query expansion has been the subject of much research. Efthimiadis (1996)
gives a general overview and history of query expansion techniques, including
thesaurus-based expansion.Asmentionedbefore, vanRijsbergen (1979)describes
the development of association measures for information retrieval, including the
mutual information measure. In computational linguistics, the paper by Church
and Hanks (1989) is often referred to for the use of the mutual information mea-
sure in constructing lexicons (dictionaries). Manning and Schütze (1999) give
a good overview of these and the other association measures mentioned in this
chapter.

Jing and Croft (1994) describe a technique for constructing an “association
thesaurus” from virtual documents consisting of the words that co-occur with
other words. The use of query log data to support expansion is described in
Beeferman and Berger (2000) and Cui et al. (2003).



230 6 Queries and Interfaces

Rocchio (1971) pioneered the work on relevance feedback, which was then
followed up by a large amount of work that is reviewed in Salton and McGill
(1983) and van Rijsbergen (1979). J. Xu and Croft (2000) is a frequently cited
paper on pseudo-relevance feedback that compared “local” techniques based on
top-ranked documents to “global” techniques based on the term associations in
the collection. The book, based on 10 years of TREC experiments (Voorhees
& Harman, 2005), contains many descriptions of both relevance feedback and
pseudo-relevance feedback techniques.

Context and personalization is a popular topic. Many publications can be
found inworkshops and conferences, such as the Information Interaction inCon-
text Symposium(IIiX).22 Wei andCroft (2007)describe an experiment that raises
questions about the potential benefit of user profiles.Chen et al. (2006) andZhou
et al. (2005) both discuss index structures for efficiently processing local search
queries, but also provide general overviews of local search. V. Zhang et al. (2006)
discusses local search with an emphasis on analyzing query logs.

Theoriginalwork on text summarizationwas done byLuhn (1958).Goldstein
et al. (1999) describe more recent work on summarization based on sentence se-
lection. The work of Berger and Mittal (2000), in contrast, generates summaries
based on statistical models of the document. Sun et al. (2005) describe a tech-
niques based on clickthrough data. The papers of Clarke et al. (2007) and Turpin
et al. (2007) focus specifically on snippet generation.

Feng et al. (2007) give a general overview of the issues in sponsored search.
Metzler et al. (2007) and Jones et al. (2006) discuss specific techniques formatch-
ing queries to short advertisements. A discussion of the issues in contextual adver-
tising (providing advertisements while browsing), as well as a specific technique
for selecting keywords from a web page, can be found in Yih et al. (2006).

As mentioned earlier, many visualization techniques have been proposed over
the years for search results, andwe have ignoredmost of these in this book.Hearst
(1999) provides a good overview of the range of techniques. Leouski and Croft
(1996) presented one of the first evaluations of techniques for result clustering.
Hearst and Pedersen (1996) show the potential benefits of this technique, and
Zamir and Etzioni (1999) emphasize the importance of clusters that made sense
to the user andwere easy to label. Lawrie andCroft (2003) discuss a technique for
building a hierarchical summary of the results, andZeng et al. (2004) focus on the

22 This conference grew out of the Information Retrieval in Context (IRiX) workshops,
whose proceedings can also be found on the Web.



6.4 Cross-Language Search 231

selection of phrases from the results as the basis of clusters.The relative advantages
and disadvantages of clustering and facets are discussed in Hearst (2006).

More generally, there is a whole community ofHCI23 (Human-Computer In-
teraction) researchers concerned with the design and evaluation of interfaces for
information systems. Shneiderman et al. (1998) is an example of this type of re-
search, and Marchionini (2006) gives a good overview of the importance of the
search interface for interactive, or exploratory, search.

Cross-language searchhas been studied atTREC(Voorhees&Harman, 2005)
and at a European evaluation forum called CLEF24 for a number of years. The
first collection of papers in this area was in Grefenstette (1998). Issues that arise
in specific CLIR systems, such as transliteration (AbdulJaleel & Larkey, 2003),
are discussed in many papers in the literature. Manning and Schütze (1999) and
Jurafsky andMartin (2006) give overviews of statisticalmachine translationmod-
els.

Finally, there has been a large body of work in the information science lit-
erature that has looked at how people actually search and interact with search
engines. This research is complementary to the more systems-oriented approach
taken in this chapter, and is a crucial part of understanding the process of looking
for information and relevance. The Journal of the American Society of Informa-
tion Science and Technology ( JASIST) is the best source for these type of papers,
and Ingwersen and Järvelin (2005) provide an interesting comparison of the com-
puter science and information science perspectives on search.

Exercises

6.1. Using theWikipedia collection provided at the bookwebsite, create a sample
of stem clusters by the following process:

1. Index the collection without stemming.
2. Identify the first 1,000 words (in alphabetical order) in the index.
3. Create stem classes by stemming these 1,000 words and recording which

words become the same stem.
4. Compute association measures (Dice’s coefficient) between all pairs of stems

in each stem class. Compute co-occurrence at the document level.

23 Sometimes referred to as CHI.
24 http://clef.isti.cnr.it/



232 6 Queries and Interfaces

5. Create stem clusters by thresholding the association measure. All terms that
are still connected to each other form the clusters.

Compare the stem clusters to the stem classes in terms of size and the quality (in
your opinion) of the groupings.

6.2. Create a simple spelling corrector based on the noisy channel model. Use a
single-word language model, and an error model where all errors with the same
edit distance have the same probability. Only consider edit distances of 1 or 2.
Implement your own edit distance calculator (example code can easily be found
on the Web).

6.3. Implement a simple pseudo-relevance feedback algorithm for the Galago
search engine. Provide examples of the query expansions that your algorithmdoes,
and summarize the problems and successes of your approach.

6.4. Assuming you had a gazetteer of place names available, sketch out an algo-
rithm for detecting place names or locations in queries. Show examples of the
types of queries where your algorithm would succeed and where it would fail.

6.5. Describe the snippet generation algorithm in Galago. Would this algorithm
work well for pages with little text content? Describe in detail how you would
modify the algorithm to improve it.

6.6. Pick a commercial web search engine and describe how you think the query
is matched to the advertisements for sponsored search. Use examples as evidence
for your ideas. Do the same thing for advertisements shown with web pages.

6.7. Implement a simple algorithm that selects phrases from the top-ranked pages
as the basis for result clusters. Phrases should be considered as any two-word se-
quence. Your algorithm should take into account phrase frequency in the results,
phrase frequency in the collection, and overlap in the clusters associated with the
phrases.

6.8. Find four different types of websites that use facets, and describe them with
examples.

6.9. Give five examples of web page translation that you think is poor. Why do
you think the translation failed?



7
Retrieval Models

“There is no certainty, only opportunity.”

V, V for Vendetta

7.1 Overview of Retrieval Models

During the last 45 years of information retrieval research, one of the primary goals
has been to understand and formalize the processes that underlie a person mak-
ing the decision that a piece of text is relevant to his information need. To develop
a complete understanding would probably require understanding how language
is represented and processed in the human brain, and we are a long way short of
that.We can, however, propose theories about relevance in the formofmathemat-
ical retrievalmodels and test those theories by comparing them to human actions.
Good models should produce outputs that correlate well with human decisions
on relevance. To put it another way, ranking algorithms based on good retrieval
models will retrieve relevant documents near the top of the ranking (and conse-
quently will have high effectiveness).

How successful has modeling been? As an example, ranking algorithms for
general search improved in effectiveness by over 100% in the 1990s, as measured
using the TREC test collections. These changes in effectiveness corresponded to
improvements in the associated retrieval models. Web search effectiveness has
also improved substantially over the past 10 years. In experiments with TREC
web collections, the most effective ranking algorithms come from well-defined
retrieval models. In the case of commercial web search engines, it is less clear what
the retrieval models are, but there is no doubt that the ranking algorithms rely on
solid mathematical foundations.

It is possible to develop ranking algorithmswithout an explicit retrievalmodel
through trial and error. Using a retrieval model, however, has generally proved to
be the best approach. Retrieval models, like all mathematical models, provide a



234 7 Retrieval Models

framework for defining new tasks and explaining assumptions. When problems
are observed with a ranking algorithm, the retrieval model provides a structure
for testing alternatives that will be much more efficient than a brute force (try ev-
erything) approach.

In this discussion, we must not overlook the fact that relevance is a complex
concept. It is quite difficult for a person to explain why one document is more
relevant than another, and when people are asked to judge the relevance of docu-
ments for a given query, they can often disagree. Information scientists have writ-
ten volumes about the nature of relevance, but we will not dive into that material
here. Instead, we discuss two key aspects of relevance that are important for both
retrieval models and evaluation measures.

The first aspect is the difference between topical and user relevance, which was
mentioned in section1.1.Adocument is topically relevant to a query if it is judged
to be on the same topic. In other words, the query and the document are about
the same thing. A web page containing a biography of Abraham Lincoln would
certainly be topically relevant to the query “AbrahamLincoln”, and would also be
topically relevant to the queries “U.S. presidents” and “Civil War”. User relevance
takes into account all the other factors that go into a user’s judgment of relevance.
This may include the age of the document, the language of the document, the
intended target audience, the novelty of the document, and so on. A document
containing just a list of all the U.S. presidents, for example, would be topically
relevant to the query “Abraham Lincoln” but may not be considered relevant to
the person who submitted the query because they were looking for more detail
on Lincoln’s life. Retrieval models cannot incorporate all the additional factors
involved in user relevance, but some do take these factors into consideration.

The second aspect of relevance that we consider is whether it is binary ormul-
tivalued. Binary relevance simply means that a document is either relevant or
not relevant. It seems obvious that some documents are less relevant than others,
but still more relevant than documents that are completely off-topic. For exam-
ple, we may consider the document containing a list of U.S. presidents to be less
topically relevant than the Lincoln biography, but certainly more relevant than
an advertisement for a Lincoln automobile. Based on this observation, some re-
trieval models and evaluation measures explicitly introduce relevance as a multi-
valued variable.Multiple levels of relevance are certainly important in evaluation,
when people are asked to judge relevance. Having just three levels (relevant, non-
relevant, unsure) has been shown tomake the judges’ taskmuch easier. In the case
of retrieval models, however, the advantages of multiple levels are less clear. This



7.1 Overview of Retrieval Models 235

is because most ranking algorithms calculate a probability of relevance and can
represent the uncertainty involved.

Many retrieval models have been proposed over the years. Two of the oldest
are the Boolean and vector spacemodels. Although these models have been largely
superseded by probabilistic approaches, they are often mentioned in discussions
about information retrieval, and so we describe them briefly before going into the
details of other models.

7.1.1 Boolean Retrieval

The Boolean retrieval model was used by the earliest search engines and is still in
use today. It is also known as exact-match retrieval since documents are retrieved
if they exactly match the query specification, and otherwise are not retrieved. Al-
though this defines a very simple form of ranking, Boolean retrieval is not gener-
ally described as a ranking algorithm. This is because the Boolean retrieval model
assumes that all documents in the retrieved set are equivalent in terms of rele-
vance, in addition to the assumption that relevance is binary. The name Boolean
comes from the fact that there only two possible outcomes for query evaluation
(TRUE and FALSE) and because the query is usually specified using operators from
Boolean logic (AND,OR,NOT). Asmentioned inChapter 6, proximity operators
and wildcard characters are also commonly used in Boolean queries. Searching
with a regular expression utility such as grep is another example of exact-match
retrieval.

There are some advantages to Boolean retrieval. The results of the model are
very predictable and easy to explain to users.The operands of a Boolean query can
be any document feature, not just words, so it is straightforward to incorporate
metadata such as a document date or document type in the query specification.
From an implementation point of view, Boolean retrieval is usually more efficient
than ranked retrieval because documents can be rapidly eliminated from consid-
eration in the scoring process.

Despite these positive aspects, the major drawback of this approach to search
is that the effectiveness depends entirely on the user. Because of the lack of a so-
phisticated ranking algorithm, simple queries will not work well. All documents
containing the specified query words will be retrieved, and this retrieved set will
be presented to the user in some order, such as by publication date, that has lit-
tle to do with relevance. It is possible to construct complex Boolean queries that
narrow the retrieved set to mostly relevant documents, but this is a difficult task



236 7 Retrieval Models

that requires considerable experience. In response to the difficulty of formulat-
ing queries, a class of users known as search intermediaries (mentioned in the last
chapter) became associated with Boolean search systems. The task of an interme-
diary is to translate a user’s information need into a complex Boolean query for
a particular search engine. Intermediaries are still used in some specialized areas,
such as in legal offices.The simplicity and effectiveness of modern search engines,
however, has enabled most people to do their own searches.

As an example of Boolean query formulation, consider the following queries
for a search engine that has indexed a collection of news stories.The simple query:

lincoln

would retrieve a large number of documents thatmention Lincoln cars and places
named Lincoln in addition to stories about President Lincoln. All of these doc-
uments would be equivalent in terms of ranking in the Boolean retrieval model,
regardless of how many times the word “lincoln” occurs or in what context it oc-
curs. Given this, the user may attempt to narrow the scope of the search with the
following query:

president AND lincoln

This query will retrieve a set of documents that contain both words, occurring
anywhere in the document. If there are a number of stories involving themanage-
ment of the FordMotor Company and Lincoln cars, these will be retrieved in the
same set as stories about President Lincoln, for example:

Ford Motor Company today announced that Darryl Hazel will succeed
Brian Kelley as president of Lincoln Mercury.

If enoughof these types of documentswere retrieved, the usermay try to eliminate
documents about cars by using theNOT operator, as follows:

president AND lincoln AND NOT (automobile OR car)

This would remove any document that contains even a single mention of the
words “automobile” or “car” anywhere in the document. The use of theNOT op-
erator, in general, removes toomany relevant documents along with non-relevant
documents and is not recommended. For example, one of the top-ranked docu-
ments in a web search for “President Lincoln” was a biography containing the
sentence:

Lincoln’s body departs Washington in a nine-car funeral train.



7.1 Overview of Retrieval Models 237

UsingNOT (automobile OR car) in the query would have removed this document.
If the retrieved set is still too large, the user may try to further narrow the query
by adding in additional words that should occur in biographies:

president AND lincoln AND biography AND life AND birthplace AND get-
tysburg AND NOT (automobile OR car)

Unfortunately, in aBoolean search engine, putting toomany search terms into the
query with the AND operator often results in nothing being retrieved. To avoid
this, the user may try using anOR instead:

president AND lincoln AND (biography OR life OR birthplace OR gettysburg)
AND NOT (automobile OR car)

This will retrieve any document containing the words “president” and “lincoln”,
along with any one of the words “biography”, “life”, “birthplace”, or “gettysburg”
(and does not mention “automobile” or “car”).

After all this, we have a query that may do a reasonable job at retrieving a set
containing some relevant documents, but we still can’t specify which words are
more important or that havingmore of the associatedwords is better than any one
of them. For example, a document containing the following text was retrieved at
rank 500 by a web search (which does use measures of word importance):

President’s Day - Holiday activities - crafts, mazes, word searches, ... “The
Life of Washington” Read the entire book online! Abraham Lincoln Re-
search Site ...

A Boolean retrieval system would make no distinction between this document
and the other 499 that are ranked higher by the web search engine. It could, for
example, be the first document in the result list.

The process of developing queries with a focus on the size of the retrieved set
has been called searching by numbers, and is a consequence of the limitations of
the Boolean retrieval model. To address these limitations, researchers developed
models, such as the vector space model, that incorporate ranking.

7.1.2 The Vector Space Model

The vector space model was the basis for most of the research in information re-
trieval in the 1960s and 1970s, and papers using this model continue to appear
at conferences. It has the advantage of being a simple and intuitively appealing
framework for implementing term weighting, ranking, and relevance feedback.



238 7 Retrieval Models

Historically, it was very important in introducing these concepts, and effective
techniques have been developed through years of experimentation. As a retrieval
model, however, it has major flaws. Although it provides a convenient computa-
tional framework, it provides little guidance on the details of how weighting and
ranking algorithms are related to relevance.

In thismodel, documents andqueries are assumed tobepart of a t-dimensional
vector space, where t is the number of index terms (words, stems, phrases, etc.). A
documentDi is represented by a vector of index terms:

Di = (di1, di2, . . . , dit),

where dij represents the weight of the jth term. A document collection contain-
ing n documents can be represented as a matrix of term weights, where each row
represents a document and each column describes weights that were assigned to
a term for a particular document:

Term1 Term2 . . . T ermt
Doc1 d11 d12 . . . d1t
Doc2 d21 d22 . . . d2t

...
...

Docn dn1 dn2 . . . dnt

Figure 7.1 gives a simple example of the vector representation for four docu-
ments.The term-documentmatrix has been rotated so that now the terms are the
rows and the documents are the columns. The term weights are simply the count
of the terms in the document. Stopwords are not indexed in this example, and
the words have been stemmed. DocumentD3, for example, is represented by the
vector (1, 1, 0, 2, 0, 1, 0, 1, 0, 0, 1).

Queries are represented the same way as documents. That is, a queryQ is rep-
resented by a vector of t weights:

Q = (q1, q2, . . . , qt),

where qj is the weight of the jth term in the query. If, for example the query was
“tropical fish”, then using the vector representation in Figure 7.1, the query would
be (0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1). One of the appealing aspects of the vector space
model is the use of simple diagrams to visualize the documents and queries. Typ-
ically, they are shown as points or vectors in a three-dimensional picture, as in



7.1 Overview of Retrieval Models 239

D1   Tropical Freshwater Aquarium Fish. 
D2   Tropical Fish, Aquarium Care, Tank Setup. 
D3   Keeping Tropical Fish and Goldfish in Aquariums,  
        and Fish Bowls. 
D4   The Tropical Tank Homepage - Tropical Fish and  
        Aquariums. 

Terms                            Documents 

                             D1       D2       D3       D4          

aquarium    1    1    1    1 

bowl         0    0    1    0 

care    0    1    0    0  

fish         1    1    2    1 

freshwater   1    0    0    0 

goldfish                  0    0    1    0   

homepage     0    0    0    1 

keep    0    0    1    0 

setup    0    1    0    0 

tank   0    1    0    1 

tropical         1    1    1    2 

Fig. 7.1. Term-document matrix for a collection of four documents

Figure 7.2. Although this can be helpful for teaching, it is misleading to think
that an intuition developed using three dimensions can be applied to the actual
high-dimensional document space. Remember that the t terms represent all the
document features that are indexed. In enterprise and web applications, this cor-
responds to hundreds of thousands or evenmillions of dimensions.

Given this representation, documents could be ranked by computing the dis-
tance between the points representing the documents and the query. More com-
monly, a similarity measure is used (rather than a distance or dissimilarity mea-
sure), so that the documents with the highest scores are the most similar to the
query. A number of similarity measures have been proposed and tested for this
purpose. The most successful of these is the cosine correlation similarity measure.
The cosine correlation measures the cosine of the angle between the query and
the document vectors. When the vectors are normalized so that all documents
and queries are represented by vectors of equal length, the cosine of the angle be-
tween two identical vectors will be 1 (the angle is zero), and for two vectors that
do not share any non-zero terms, the cosine will be 0. The cosine measure is de-
fined as:



240 7 Retrieval Models

T
e
r
m
2

Term3

Doc1

Query

Doc2

Fig. 7.2. Vector representation of documents and queries

Cosine(Di, Q) =

t?
j=1

dij · qj?
t?

j=1

dij2 ·
t?

j=1

qj2

The numerator of this measure is the sum of the products of the term weights
for the matching query and document terms (known as the dot product or in-
ner product). The denominator normalizes this score by dividing by the product
of the lengths of the two vectors. There is no theoretical reason why the cosine
correlation should be preferred to other similarity measures, but it does perform
somewhat better in evaluations of search quality.

As an example, consider two documents D1 = (0.5, 0.8, 0.3) and D2 =
(0.9, 0.4, 0.2) indexedby three terms,where thenumbers represent termweights.
Given the query Q = (1.5, 1.0, 0) indexed by the same terms, the cosine mea-
sures for the two documents are:



7.1 Overview of Retrieval Models 241

Cosine(D1, Q) =
(0.5× 1.5) + (0.8× 1.0)?

(0.52 + 0.82 + 0.32)(1.52 + 1.02)

=
1.55?

(0.98× 3.25)
= 0.87

Cosine(D2, Q) =
(0.9× 1.5) + (0.4× 1.0)?

(0.92 + 0.42 + 0.22)(1.52 + 1.02)

=
1.75?

(1.01× 3.25)
= 0.97

The second document has a higher score because it has a high weight for the first
term, which also has a high weight in the query. Even this simple example shows
that ranking based on the vector space model is able to reflect term importance
and the number of matching terms, which is not possible in Boolean retrieval.

In this discussion, we have yet to say anything about the form of the term
weightingused in the vector spacemodel. In fact,manydifferentweighting schemes
have been tried over the years. Most of these are variations on tf.idf weighting,
which was described briefly in Chapter 2. The term frequency component, tf, re-
flects the importance of a term in a documentDi (or query). This is usually com-
puted as a normalized count of the term occurrences in a document, for example
by

tfik =
fik
t?

j=1

fij

where tfik is the term frequency weight of term k in document Di, and fik is
the number of occurrences of term k in the document. In the vector space model,
normalization is part of the cosine measure. A document collection can contain
documents of many different lengths. Although normalization accounts for this
to some degree, long documents can have many terms occurring once and others
occurring hundreds of times. Retrieval experiments have shown that to reduce the
impact of these frequent terms, it is effective to use the logarithm of the number
of term occurrences in tf weights rather than the raw count.

The inverse document frequency component (idf ) reflects the importance of
the term in the collection of documents. The more documents that a term occurs
in, the less discriminating the term is between documents and, consequently, the
less useful it will be in retrieval. The typical form of this weight is



242 7 Retrieval Models

idfk = log
N

nk

where idfk is the inverse document frequency weight for term k,N is the number
of documents in the collection, andnk is the number of documents inwhich term
k occurs. The form of this weight was developed by intuition and experiment,
although an argument can bemade that idf measures the amount of information
carried by the term, as defined in information theory (Robertson, 2004).

The effects of these two weights are combined by multiplying them (hence
the name tf.idf). The reason for combining them this way is, once again, mostly
empirical. Given this, the typical form of document term weighting in the vector
space model is:

dik =
(log(fik) + 1) · log(N/nk)?

t?
k=1

[(log(fik) + 1.0) · log(N/nk)]2

Theformof query termweighting is essentially the same.Adding 1 to the term fre-
quency component ensures that terms with frequency 1 have a non-zero weight.
Note that, in this model, term weights are computed only for terms that occur in
the document (or query). Given that the cosine measure normalization is incor-
porated into the weights, the score for a document is computed using simply the
dot product of the document and query vectors.

Although there is no explicit definition of relevance in the vector spacemodel,
there is an implicit assumption that relevance is related to the similarity of query
and document vectors. In other words, documents “closer” to the query are more
likely to be relevant. This is primarily a model of topical relevance, although fea-
tures related to user relevance could be incorporated into the vector representa-
tion. No assumption is made about whether relevance is binary or multivalued.

In the last chapter we described relevance feedback, a technique for query
modification based on user-identified relevant documents. This technique was
first introduced using the vector space model. The well-known Rocchio algorithm
(Rocchio, 1971) was based on the concept of an optimal query, which maximizes
the difference between the average vector representing the relevant documents
and the average vector representing the non-relevant documents. Given that only
limited relevance information is typically available, themost common (and effec-
tive) form of the Rocchio algorithm modifies the initial weights in query vector
Q to produce a new queryQ? according to



7.2 Probabilistic Models 243

q?j = ?.qj + ?.
1

|Rel|
?

Di?Rel

dij ? ?.
1

|Nonrel|
?

Di?Nonrel

dij

where qj is the initial weight of query term j,Rel is the set of identified relevant
documents, Nonrel is the set of non-relevant documents, |.| gives the size of a
set, dij is the weight of the jth term in document i, and ?, ?, and ? are parame-
ters that control the effect of each component. Previous studies have shown that
the set of non-relevant documents is best approximated by all unseen documents
(i.e., all documents not identified as relevant), and that reasonable values for the
parameters are 8, 16, and 4 for ?, ?, and ?, respectively.

This formula modifies the query term weights by adding a component based
on the average weight in the relevant documents and subtracting a component
based on the average weight in the non-relevant documents. Query terms with
weights that are negative are dropped. This results in a longer or expanded query
because terms that occur frequently in the relevant documents but not in the orig-
inal query will be added (i.e., they will have non-zero positive weights in themod-
ified query). To restrict the amount of expansion, typically only a certain number
(say, 50) of the terms with the highest average weights in the relevant documents
will be added to the query.

7.2 Probabilistic Models

Oneof the features that a retrievalmodel should provide is a clear statement about
the assumptions uponwhich it is based.TheBoolean and vector space approaches
make implicit assumptions about relevance and text representation that impact
the design and effectiveness of ranking algorithms. The ideal situation would be
to show that, given the assumptions, a ranking algorithm based on the retrieval
model will achieve better effectiveness than any other approach. Such proofs are
actually very hard to come by in information retrieval, since we are trying to for-
malize a complex human activity. The validity of a retrieval model generally has
to be validated empirically, rather than theoretically.

One early theoretical statement about effectiveness, known as the Probabil-
ity Ranking Principle (Robertson, 1977/1997), encouraged the development of
probabilistic retrieval models, which are the dominant paradigm today. These
models have achieved this status because probability theory is a strong founda-
tion for representing and manipulating the uncertainty that is an inherent part



244 7 Retrieval Models

of the information retrieval process. The Probability Ranking Principle, as origi-
nally stated, is as follows:

If a reference retrieval system’s1 response to each request is a ranking of
the documents in the collection in order of decreasing probability of rel-
evance to the user who submitted the request, where the probabilities are
estimated as accurately as possible on the basis of whatever data have been
made available to the system for this purpose, the overall effectiveness of
the system to its userwill be the best that is obtainable on the basis of those
data.

Given some assumptions, such as that the relevance of a document to a query
is independent of other documents, it is possible to show that this statement is
true, in the sense that ranking by probability of relevance will maximize preci-
sion, which is the proportion of relevant documents, at any given rank (for exam-
ple, in the top 10 documents). Unfortunately, the Probability Ranking Principle
doesn’t tell us how to calculate or estimate the probability of relevance. There are
many probabilistic retrievalmodels, and each one proposes a differentmethod for
estimating this probability. Most of the rest of this chapter discusses some of the
most important probabilistic models.

In this section, we start with a simple probabilistic model based on treating
information retrieval as a classification problem. We then describe a popular and
effective ranking algorithm that is based on this model.

7.2.1 Information Retrieval as Classification

In any retrieval model that assumes relevance is binary, there will be two sets of
documents, the relevant documents and the non-relevant documents, for each
query. Given a new document, the task of a search engine could be described as
deciding whether the document belongs in the relevant set or the non-relevant2

set. That is, the system should classify the document as relevant or non-relevant,
and retrieve it if it is relevant.

Given some way of calculating the probability that the document is relevant
and the probability that it is non-relevant, then it would seem reasonable to clas-
sify the document into the set that has the highest probability. In other words,

1 A “reference retrieval system” would now be called a search engine.
2 Note that we never talk about “irrelevant” documents in information retrieval; instead
they are “non-relevant.”



7.2 Probabilistic Models 245

wewould decide that a documentD is relevant ifP (R|D) > P (NR|D), where
P (R|D) is a conditional probability representing the probability of relevance
given the representation of that document, and P (NR|D) is the conditional
probability of non-relevance (Figure 7.3). This is known as the Bayes Decision
Rule, and a system that classifies documents this way is called a Bayes classifier.

In Chapter 9, we discuss other applications of classification (such as spam fil-
tering) and other classification techniques, but here we focus on the ranking algo-
rithm that results from this probabilistic retrieval model based on classification.

Relevant

Documents

Non Relevant!

Documents

The!rain!in!Spain!falls

mainly!in!the!plain!

The!rain!in!Spain!falls

mainly!in!the!plain!

The!rain!in!Spain!falls

mainly!in!the!plain!

The!rain!in!Spain!falls

mainly!in!the!plain

Document

P(R|D)

P(NR|D)

Fig. 7.3. Classifying a document as relevant or non-relevant

The question that faces us now is how to compute these probabilities. To start
with, let’s focus on P (R|D). It’s not clear how we would go about calculating
this, but given information about the relevant set, we should be able to calcu-
lateP (D|R). For example, if we had information about how often specific words
occurred in the relevant set, then, given a new document, it would be relatively
straightforward to calculate how likely it would be to see the combination of
words in the document occurring in the relevant set. Let’s assume that the prob-
ability of the word “president” in the relevant set is 0.02, and the probability of
“lincoln” is 0.03. If a new document contains the words “president” and “lincoln”,
we could say that the probability of observing that combination of words in the



246 7 Retrieval Models

relevant set is 0.02 × 0.03 = 0.0006, assuming that the two words occur inde-
pendently.3

So how does calculating P (D|R) get us to the probability of relevance? It
turns out there is a relationship between P (R|D) and P (D|R) that is expressed
by Bayes’ Rule:4

P (R|D) = P (D|R)P (R)
P (D)

where P (R) is the a priori probability of relevance (in other words, how likely
any document is to be relevant), andP (D) acts as a normalizing constant. Given
this, we can express our decision rule in the following way: classify a document as
relevant if P (D|R)P (R) > P (D|NR)P (NR). This is the same as classifying
a document as relevant if:

P (D|R)
P (D|NR)

>
P (NR)

P (R)

The left-hand side of this equation is known as the likelihood ratio. In most clas-
sification applications, such as spam filtering, the system must decide which class
the document belongs to in order to take the appropriate action. For information
retrieval, a search engine only needs to rank documents, rather thanmake that de-
cision (which is hard). If we use the likelihood ratio as a score, the highly ranked
documents will be those that have a high likelihood of belonging to the relevant
set.

To calculate the document scores, we still need to decide how to come up
with values for P (D|R) and P (D|NR). The simplest approach is to make the
same assumptions that we made in our earlier example; that is, we represent doc-
uments as a combination of words and the relevant and non-relevant sets using
word probabilities. In thismodel, documents are represented as a vector of binary
features,D = (d1, d2, . . . , dt), wheredi = 1 if term i is present in the document,
and 0 otherwise.The other major assumption wemake is term independence (also
known as the Naïve Bayes assumption). This means we can estimate P (D|R) by
the product of the individual term probabilities

?t
i=1 P (di|R) (and similarly for

P (D|NR)). Because this model makes the assumptions of term independence
and binary features in documents, it is known as the binary independence model .
3 Given two events A and B, the joint probability P (A ? B) is the probability of both
events occurring together. In general, P (A ? B) = P (A|B)P (B). If A and B are
independent, this means that P (A ?B) = P (A)P (B).

4 Named after Thomas Bayes, a British mathematician.



7.2 Probabilistic Models 247

Words obviously do not occur independently in text. If the word “Microsoft”
occurs in a document, it is very likely that the word “Windows” will also occur.
The assumption of term independence, however, is a common one since it usually
simplifies the mathematics involved in the model. Models that allow some form
of dependence between terms will be discussed later in this chapter.

Recall that a document in this model is a vector of 1s and 0s representing the
presence and absence of terms. For example, if there were five terms indexed, one
of the document representations might be (1, 0, 0, 1, 1), meaning that the doc-
ument contains terms 1, 4, and 5. To calculate the probability of this document
occurring in the relevant set, we need the probabilities that the terms are 1 or 0
in the relevant set. If pi is the probability that term i occurs (has the value 1) in
a document from the relevant set, then the probability of our example document
occurring in the relevant set is p1 × (1? p2)× (1? p3)× p4 × p5. The prob-
ability (1? p2) is the probability of term 2 not occurring in the relevant set. For
the non-relevant set, we use si to represent the probability of term i occurring.5

Going back to the likelihood ratio, using pi and si gives us a score of

P (D|R)
P (D|NR)

=
?

i:di=1

pi
si
·
?

i:di=0

1? pi
1? si

where
?

i:di=1
means that it is a product over the terms that have the value 1 in

the document. We can now do a bit of mathematical manipulation to get:?
i:di=1

pi
si
· (
?

i:di=1

1? si
1? pi

·
?

i:di=1

1? pi
1? si

) ·
?

i:di=0

1? pi
1? si

=
?

i:di=1

pi(1? si)
si(1? pi)

·
?
i

1? pi
1? si

The second product is over all terms and is therefore the same for all documents,
so we can ignore it for ranking. Since multiplying lots of small numbers can lead
to problems with the accuracy of the result, we can equivalently use the logarithm
of the product, which means that the scoring function is:?

i:di=1

log pi(1? si)
si(1? pi)

5 In many descriptions of this model, pi and qi are used for these probabilities. We use
si to avoid confusion with the qi used to represent query terms.



248 7 Retrieval Models

You might be wondering where the query has gone, given that this is a doc-
ument ranking algorithm for a specific query. In many cases, the query provides
us with the only information we have about the relevant set. We can assume that,
in the absence of other information, terms that are not in the query will have the
same probability of occurrence in the relevant and non-relevant documents (i.e.,
pi = si). In that case, the summation will only be over terms that are both in
the query and in the document. This means that, given a query, the score for a
document is simply the sum of the term weights for all matching terms.

If we have no other information about the relevant set, we could make the
additional assumptions that pi is a constant and that si could be estimated by
using the term occurrences in thewhole collection as an approximation.Wemake
the second assumption based on the fact that the number of relevant documents is
much smaller than the total number of documents in the collection.With a value
of 0.5 for pi in the scoring function described earlier, this gives a term weight for
term i of

log
0.5(1? ni

N
)

ni
N
(1? 0.5)

= log N ? ni
ni

whereni is the number of documents that contain term i, andN is the number of
documents in the collection.This shows that, in the absence of information about
the relevant documents, the term weight derived from the binary independence
model is very similar to an idf weight. There is no tf component, because the
documents were assumed to have binary features.

If we do have information about term occurrences in the relevant and non-
relevant sets, it can be summarized in a contingency table, shown in Table 7.1.This
information could be obtained through relevance feedback, where users identify
relevant documents in initial rankings. In this table, ri is the number of relevant
documents containing term i, ni is the number of documents containing term i,
N is the total number of documents in the collection, and R is the number of
relevant documents for this query.

Relevant Non-relevant Total
di = 1 ri ni ? ri ni
di = 0 R? ri N ? ni ?R+ ri N ? ni
Total R N ?R N

Table 7.1. Contingency table of term occurrences for a particular query



7.2 Probabilistic Models 249

Given this table, the obvious estimates6 for pi and si would be pi = ri/R (the
number of relevant documents that contain a termdivided by the total number of
relevant documents) and si = (ni ? ri)/(N ?R) (the number of non-relevant
documents that contain a term divided by the total number of non-relevant doc-
uments). Using these estimates could cause a problem, however, if some of the
entries in the contingency table were zeros. If ri was zero, for example, the term
weight would be log 0. To avoid this, a standard solution is to add 0.5 to each
count (and 1 to the totals), which gives us estimates of pi = (ri + 0.5)/(R+ 1)
and si = (ni?ri+0.5)/(N?R+1.0). Putting these estimates into the scoring
function gives us:?

i:di=qi=1

log (ri + 0.5)/(R? ri + 0.5)
(ni ? ri + 0.5)/(N ? ni ?R + ri + 0.5)

Although this document score sums term weights for just the matching query
terms, with relevance feedback the query can be expanded to include other impor-
tant terms from the relevant set. Note that if we have no relevance information,
we can set r and R to 0, which would give a pi value of 0.5, and would produce
the idf-like term weight discussed before.

So how good is this document score when used for ranking? Not very good,
it turns out. Although it does provide a method of incorporating relevance in-
formation, in most cases we don’t have this information and instead would be
using term weights that are similar to idf weights. The absence of a tf compo-
nent makes a significant difference to the effectiveness of the ranking, and most
effectivenessmeasures will drop by about 50% if the ranking ignores this informa-
tion. This means, for example, that we might see 50% fewer relevant documents
in the top ranks if we used the binary independence model ranking instead of the
best tf.idf ranking.

It turns out, however, that the binary independence model is the basis for one
of the most effective and popular ranking algorithms, known as BM25.7

6 We use the term estimate for a probability value calculated using data such as a contin-
gency table because this value is only an estimate for the true value of the probability
and would change if more data were available.

7 BM stands for Best Match, and 25 is just a numbering scheme used by Robertson and
his co-workers to keep track of weighting variants (Robertson & Walker, 1994).



250 7 Retrieval Models

7.2.2 The BM25 Ranking Algorithm

BM25 extends the scoring function for the binary independence model to in-
clude document and query term weights. The extension is based on probabilistic
arguments and experimental validation, but it is not a formal model.

BM25 has performed very well in TREC retrieval experiments and has influ-
enced the ranking algorithms of commercial search engines, including web search
engines.There are some variations of the scoring function for BM25, but themost
common form is:?
i?Q

log (ri + 0.5)/(R? ri + 0.5)
(ni ? ri + 0.5)/(N ? ni ?R + ri + 0.5)

· (k1 + 1)fi
K + fi

· (k2 + 1)qfi
k2 + qfi

where the summation is now over all terms in the query; andN ,R, ni, and ri are
the same as described in the last section, with the additional condition that r and
R are set to zero if there is no relevance information; fi is the frequency of term
i in the document; qfi is the frequency of term i in the query; and k1, k2, andK
are parameters whose values are set empirically.

Theconstantk1 determineshowthe tf componentof the termweight changes
as fi increases. If k1 = 0, the term frequency component would be ignored and
only termpresence or absencewouldmatter. Ifk1 is large, the termweight compo-
nent would increase nearly linearly with fi. In TREC experiments, a typical value
for k1 is 1.2, which causes the effect of fi to be very non-linear, similar to the use
of log f in the termweights discussed in section 7.1.2.Thismeans that after three
or four occurrences of a term, additional occurrences will have little impact. The
constant k2 has a similar role in the query term weight. Typical values for this pa-
rameter are in the range 0 to 1,000, meaning that performance is less sensitive to
k2 than it is to k1. This is because query term frequencies are much lower and less
variable than document term frequencies.

K is a more complicated parameter that normalizes the tf component by doc-
ument length. Specifically

K = k1((1? b) + b ·
dl

avdl
)

where b is a parameter, dl is the length of the document, and avdl is the average
length of a document in the collection.The constant b regulates the impact of the
length normalization, where b = 0 corresponds to no length normalization, and



7.2 Probabilistic Models 251

b = 1 is full normalization. InTREC experiments, a value of b = 0.75was found
to be effective.

As an example calculation, let’s consider a query with two terms, “president”
and “lincoln”, each of which occurs only once in the query (qf = 1).Wewill con-
sider the typical case where we have no relevance information (r andR are zero).
Let’s assume that we are searching a collection of 500,000 documents (N ), and
that in this collection, “president” occurs in 40,000 documents (n1 = 40, 000)
and “lincoln” occurs in 300 documents (n2 = 300). In the documentwe are scor-
ing (which is about President Lincoln), “president” occurs 15 times (f1 = 15)
and “lincoln” occurs 25 times (f2 = 25).The document length is 90%of the aver-
age length (dl/avdl = 0.9).Theparameter valueswe use arek1 = 1.2, b = 0.75,
and k2 = 100. With these values, K = 1.2 · (0.25 + 0.75 · 0.9) = 1.11, and
the document score is:

BM25(Q,D) =

log (0 + 0.5)/(0? 0 + 0.5)
(40000? 0 + 0.5)/(500000? 40000? 0 + 0 + 0.5)

×(1.2 + 1)15
1.11 + 15

× (100 + 1)1
100 + 1

+ log (0 + 0.5)/(0? 0 + 0.5)
(300? 0 + 0.5)/(500000? 300? 0 + 0 + 0.5)

×(1.2 + 1)25
1.11 + 25

× (100 + 1)1
100 + 1

= log 460000.5/40000.5 · 33/16.11 · 101/101
+ log 499700.5/300.5 · 55/26.11 · 101/101

= 2.44 · 2.05 · 1 + 7.42 · 2.11 · 1
= 5.00 + 15.66 = 20.66

Notice the impact from the first part of the weight that, without relevance in-
formation, is nearly the same as an idf weight (as we discussed in section 7.2.1).
Because the term “lincoln” is much less frequent in the collection, it has a much
higher idf component (7.42 versus 2.44). Table 7.2 gives scores for different num-
bers of term occurrences. This shows the importance of the “lincoln” term and
that even one occurrence of a term can make a large difference in the score. Re-
ducing the number of term occurrences from25 or 15 to 1makes a significant but



252 7 Retrieval Models

not dramatic difference. This example also demonstrates that it is possible for a
document containing a large number of occurrences of a single important term to
score higher than a document containing both query terms (15.66 versus 12.74).

Frequency of Frequency of BM25
“president” “lincoln” score

15 25 20.66
15 1 12.74
15 0 5.00
1 25 18.2
0 25 15.66

Table 7.2. BM25 scores for an example document

The score calculation may seem complicated, but remember that some of the
calculation of term weights can occur at indexing time, before processing any
query. If there is no relevance information, scoring a document simply involves
adding the weights for matching query terms, with a small additional calculation
if query terms occur more than once (i.e., if qf > 1). Another important point is
that the parameter values for the BM25 ranking algorithm can be tuned (i.e., ad-
justed to obtain the best effectiveness) for each application.The process of tuning
is described further in section 7.7 and Chapter 8.

To summarize, BM25 is an effective ranking algorithm derived from a model
of information retrieval viewed as classification. This model focuses on topical
relevance and makes an explicit assumption that relevance is binary. In the next
section, we discuss another probabilistic model that incorporates term frequency
directly in the model, rather than being added in as an extension to improve per-
formance.

7.3 Ranking Based on Language Models

Language models are used to represent text in a variety of language technologies,
such as speech recognition, machine translation, and handwriting recognition.
The simplest form of language model, known as a unigram language model, is a
probability distribution over the words in the language. This means that the lan-
guage model associates a probability of occurrence with every word in the in-



7.3 Ranking Based on Language Models 253

dex vocabulary for a collection. For example, if the documents in a collection
contained just five different words, a possible language model for that collection
might be (0.2, 0.1, 0.35, 0.25, 0.1), where each number is the probability of a
word occurring. If we treat each document as a sequence of words, then the proba-
bilities in the language model predict what the next word in the sequence will be.
For example, if the five words in our language were “girl”, “cat”, “the”, “boy”, and
“touched”, then the probabilities predict which of these words will be next. These
words cover all the possibilities, so the probabilities must add to 1. Because this
is a unigram model, the previous words have no impact on the prediction. With
thismodel, for example, it is just as likely to get the sequence “girl cat” (probability
0.2× 0.1) as “girl touched” (probability 0.2× 0.1).

In applications such as speech recognition, n-gram language models that pre-
dict words based on longer sequences are used. An n-grammodel predicts a word
based on the previous n ? 1 words. The most common n-gram models are bi-
gram (predicting based on the previous word) and trigram (predicting based on
the previous two words) models. Although bigram models have been used in in-
formation retrieval to represent two-word phrases (see section 4.3.5), we focus
our discussion on unigram models because they are simpler and have proven to
be very effective as the basis for ranking algorithms.

For search applications, we use language models to represent the topical con-
tent of a document. A topic is something that is talked about often but rarely de-
fined in information retrieval discussions. In this approach, we define a topic as a
probability distributionoverwords (in otherwords, a languagemodel). For exam-
ple, if a document is about fishing in Alaska, we would expect to see words associ-
ated with fishing and locations in Alaska with high probabilities in the language
model. If it is about fishing in Florida, some of the high-probability words will be
the same, but there will be more high probability words associated with locations
in Florida. If instead the document is about fishing games for computers, most of
the high-probability words will be associated with game manufacturers and com-
puter use, although there will still be some important words about fishing. Note
that a topic languagemodel, or topic model for short, contains probabilities for all
words, not just the most important. Most of the words will have “default” proba-
bilities that will be the same for any text, but the words that are important for the
topic will have unusually high probabilities.

A languagemodel representation of a document can be used to “generate” new
text by sampling words according to the probability distribution. If we imagine
the language model as a big bucket of words, where the probabilities determine



254 7 Retrieval Models

how many instances of a word are in the bucket, then we can generate text by
reaching in (without looking), drawing out a word, writing it down, putting the
word back in the bucket, and drawing again. Note that we are not saying that we
can generate the original document by this process. In fact, because we are only
using a unigram model, the generated text is going to look pretty bad, with no
syntactic structure. Important words for the topic of the document will, however,
appear often. Intuitively, we are using the language model as a very approximate
model for the topic the author of the document was thinking about when he was
writing it.

When text is modeled as a finite sequence of words, where at each point in
the sequence there are t different possible words, this corresponds to assuming
amultinomial distribution over words. Although there are alternatives, multino-
mial languagemodels are themost common in information retrieval.8 One of the
limitations of multinomial models that has been pointed out is that they do not
describe text burstiness well, which is the observation that once a word is “pulled
out of the bucket,” it tends to be pulled out repeatedly.

In addition to representing documents as language models, we can also repre-
sent the topic of the query as a language model. In this case, the intuition is that
the language model is a representation of the topic that the information seeker
had in mind when she was writing the query. This leads to three obvious possi-
bilities for retrieval models based on language models: one based on the proba-
bility of generating the query text from a document language model, one based
on generating the document text from a query language model, and one based on
comparing the language models representing the query and document topics. In
the next two sections, we describe these retrieval models in more detail.

7.3.1 Query Likelihood Ranking

In the query likelihood retrieval model, we rank documents by the probability
that the query text could be generated by the document languagemodel. In other
words, we calculate the probability that we could pull the query words out of the
“bucket” ofwords representing the document.This is amodel of topical relevance,
in the sense that the probability of query generation is the measure of how likely
it is that a document is about the same topic as the query.

Since we start with a query, we would in general like to calculate P (D|Q) to
rank the documents. Using Bayes’ Rule, we can calculate this by

8 We discuss the multinomial model in the context of classification in Chapter 9.



7.3 Ranking Based on Language Models 255

p(D|Q) rank= P (Q|D)P (D)

where the symbol rank= , as we mentioned previously, means that the right-hand
side is rank equivalent to the left-hand side (i.e., we can ignore the normalizing
constant P (Q)), P (D) is the prior probability of a document, and P (Q|D) is
the query likelihood given the document. In most cases, P (D) is assumed to be
uniform (the same for all documents), and so will not affect the ranking. Mod-
els that assign non-uniform prior probabilities based on, for example, document
date or document length can be useful in some applications, but we will make
the simpler uniform assumption here. Given that assumption, the retrieval model
specifies ranking documents by P (Q|D), which we calculate using the unigram
language model for the document

P (Q|D) =
n?

i=1

P (qi|D)

where qi is a query word, and there are n words in the query.
To calculate this score, we need to have estimates for the languagemodel prob-

abilities P (qi|D). The obvious estimate would be

P (qi|D) =
fqi,D
|D|

where fqi,D is the number of times word qi occurs in document D, and |D| is
the number of words inD. For a multinomial distribution, this is themaximum
likelihood estimate, which means this this is the estimate that makes the observed
value of fqi,D most likely. The major problem with this estimate is that if any of
the query words aremissing from the document, the score given by the query like-
lihood model for P (Q|D) will be zero. This is clearly not appropriate for longer
queries. For example, missing one word out of six should not produce a score of
zero. We will also not be able to distinguish between documents that have differ-
ent numbers of querywordsmissing.Additionally, becausewe are building a topic
model for a document, words associated with that topic should have some prob-
ability of occurring, even if they were not mentioned in the document. For ex-
ample, a language model representing a document about computer games should
have some non-zero probability for the word “RPG” even if that word was not
mentioned in the document. A small probability for that word will enable the
document to receive a non-zero score for the query “RPG computer games”, al-
though itwill be lower than the score for a document that contains all threewords.



256 7 Retrieval Models

Smoothing is a technique for avoiding this estimation problem and overcom-
ing data sparsity, which means that we typically do not have large amounts of
text to use for the language model probability estimates. The general approach
to smoothing is to lower (or discount) the probability estimates for words that
are seen in the document text, and assign that “leftover” probability to the esti-
mates for the words that are not seen in the text. The estimates for unseen words
are usually based on the frequency of occurrence of words in the whole document
collection. IfP (qi|C) is the probability for queryword i in the collection language
model for document collectionC , then the estimate we use for an unseen word in
a document is ?DP (qi|C), where ?D is a coefficient controlling the probability
assigned to unseen words.9 In general,?D can depend on the document. In order
that the probabilities sum to one, the probability estimate for a word that is seen
in a document is (1? ?D)P (qi|D) + ?DP (qi|C).

Tomake this clear, consider a simple examplewhere there are only threewords,
w1, w2, and w3, in our index vocabulary. If the collection probabilities for these
threewords, based onmaximum likelihood estimates, are 0.3, 0.5, and0.2, and the
document probabilities based on maximum likelihood estimates are 0.5, 0.5, and
0.0, then the smoothed probability estimates for the document language model
are:

P (w1|D) = (1? ?D)P (w1|D) + ?DP (w1|C)
= (1? ?D) · 0.5 + ?D · 0.3

P (w2|D) = (1? ?D) · 0.5 + ?D · 0.5
P (w3|D) = (1? ?D) · 0.0 + ?D · 0.2 = ?D · 0.2

Note that term w3 has a non-zero probability estimate, even though it did not
occur in the document text. If we add these three probabilities, we get

P (w1|D) + P (w2|D) + P (w3|D) = (1? ?D) · (0.5 + 0.5)
+?D · (0.3 + 0.5 + 0.2)

= 1? ?D + ?D
= 1

which confirms that the probabilities are consistent.

9 The collection language model probability is also known as the background language
model probability, or just the background probability.



7.3 Ranking Based on Language Models 257

Different forms of estimation result from specifying the value of?D.The sim-
plest choice would be to set it to a constant, i.e.,?D = ?.The collection language
model probability estimate we use for word qi is cqi/|C|, where cqi is the num-
ber of times a query word occurs in the collection of documents, and |C| is the
total number of word occurrences in the collection. This gives us an estimate for
P (qi|D) of:

p(qi|D) = (1? ?)
fqi,D
|D|

+ ?
cqi
|C|

This form of smoothing is known as the Jelinek-Mercermethod. Substituting this
estimate in the document score for the query-likelihood model gives:

P (Q|D) =
n?

i=1

((1? ?)fqi,D
|D|

+ ?
cqi
|C|

)

Aswehave said before, sincemultiplyingmany small numbers together can lead to
accuracy problems, we can use logarithms to turn this score into a rank-equivalent
sum as follows:

logP (Q|D) =
n?

i=1

log((1? ?)fqi,D
|D|

+ ?
cqi
|C|

)

Small values of ? produce less smoothing, and consequently the query tends
to act more like a Boolean AND since the absence of any query word will penalize
the score substantially. In addition, the relative weighting of words, as measured
by themaximum likelihood estimates, will be important in determining the score.
As? approaches 1, the relativeweightingwill be less important, and the query acts
more like a Boolean OR or a coordination level match.10 In TREC evaluations, it
has been shown that values of ? around 0.1 work well for short queries, whereas
values around0.7 are better formuch longer queries. Short queries tend to contain
only significant words, and a low? value will favor documents that contain all the
query words. With much longer queries, missing a word is much less important,
and a high ? places more emphasis on documents that contain a number of the
high-probability words.

At this point, it may occur to you that the query likelihood retrieval model
doesn’t have anything that looks like a tf.idf weight, and yet experiments show
10 A coordination level match simply ranks documents by the number ofmatching query

terms.



258 7 Retrieval Models

that it is as least as effective as the BM25 ranking algorithm. We can, however,
demonstrate a relationship to tf.idfweights by manipulating the query likelihood
score in the following way:

logP (Q|D) =
n?

i=1

log((1? ?)fqi,D
|D|

+ ?
cqi
|C|

)

=
?

i:fqi,D>0

log((1? ?)fqi,D
|D|

+ ?
cqi
|C|

) +
?

i:fqi,D=0

log(? cqi
|C|

)

=
?

i:fqi,D>0

log
((1? ?)fqi,D|D| + ?

cqi
|C|)

?
cqi
|C|

+
n?

i=1

log(? cqi
|C|

)

rank
=

?
i:fqi,D>0

log

??((1? ?)fqi,D|D|
?

cqi
|C|

+ 1

??
In the second line, we split the score into the words that occur in the document
and those that don’t occur (fqi,D = 0). In the third line, we add?

i:fqi,D>0

log(? cqi
|C|

)

to the last term and subtract it from the first (where it ends up in the denomina-
tor), so there is no net effect. The last term is now the same for all documents and
can be ignored for ranking.Thefinal expression gives the document score in terms
of a “weight” for matching query terms. Although this weight is not identical to
a tf.idf weight, there are clear similarities in that it is directly proportional to the
document term frequency and inversely proportional to the collection frequency.

A different form of estimation, and one that is generally more effective, comes
from using a value of?D that is dependent on document length. This approach is
known asDirichlet smoothing, for reasons we will discuss later, and uses

?D =
µ

|D|+ µ

where µ is a parameter whose value is set empirically. Substituting this expression
for ?D in (1? ?D)P (qi|D) + ?DP (qi|C) results in the probability estimation
formula



7.3 Ranking Based on Language Models 259

p(qi|D) =
fqi,D + µ

cqi
|C|

|D|+ µ
which in turn leads to the following document score:

logP (Q|D) =
n?

i=1

log
fqi,D + µ

cqi
|C|

|D|+ µ

Similar to the Jelinek-Mercer smoothing, small values of the parameter (µ in
this case) give more importance to the relative weighting of words, and large val-
ues favor the number of matching terms. Typical values of µ that achieve the best
results in TREC experiments are in the range 1,000 to 2,000 (remember that col-
lection probabilities are very small), and Dirichlet smoothing is generally more
effective than Jelinek-Mercer, especially for the short queries that are common in
most search applications.

So where does Dirichlet smoothing come from? It turns out that a Dirichlet
distribution11 is the natural way to specify prior knowledge when estimating the
probabilities in a multinomial distribution. The process of Bayesian estimation
determines probability estimates based on this prior knowledge and the observed
text. The resulting probability estimate can be viewed as combining actual word
counts from the text with pseudo-counts from theDirichlet distribution. If we had
no text, the probability estimate for term qi would be µ(cqi/|C|)/µ, which is a
reasonable guess based on the collection. The more text we have (i.e., for longer
documents), the less influence the prior knowledge will have.

We can demonstrate the calculation of query likelihood document scores us-
ing the example given in section 7.2.2. The two query terms are “president” and
“lincoln”. For the term “president”, fqi,D =15, and let’s assume that cqi =160,000.
For the term “lincoln”, fqi,D = 25, and we will assume that cqi = 2,400. The num-
ber ofword occurrences in the document |d| is assumed to be 1,800, and the num-
ber of word occurrences in the collection is 109 (500,000 documents times an
average of 2,000 words). The value of µ used is 2,000. Given these numbers, the
score for the document is:
11 Named after the German mathematician Johann Peter Gustav Lejeune Dirichlet (the

first name used seems to vary).



260 7 Retrieval Models

QL(Q,D) = log 15 + 2000× (1.6× 10
5/109)

1800 + 2000

+ log 25 + 2000× (2400/10
9)

1800 + 2000
= log(15.32/3800) + log(25.005/3800)
= ?5.51 +?5.02 = ?10.53

A negative number? Remember that we are taking logarithms of probabilities in
this scoring function, and the probabilities of word occurrence are small. The im-
portant issue is the effectiveness of the rankings produced using these scores. Ta-
ble 7.3 shows the query likelihood scores for the same variations of term occur-
rences that were used in Table 7.2. Although the scores look very different for
BM25 and QL, the rankings are similar, with the exception that the document
containing 15 occurrences of “president” and 1 of “lincoln” is ranked higher than
the document containing 0 occurrences of “president” and 25 occurrences of “lin-
coln” in the QL scores, whereas the reverse is true for BM25.

Frequency of Frequency of QL
“president” “lincoln” score

15 25 –10.53
15 1 –13.75
15 0 –19.05
1 25 –12.99
0 25 –14.40

Table 7.3. Query likelihood scores for an example document

To summarize, query likelihood is a simple probabilistic retrieval model that
directly incorporates term frequency. The problem of coming up with effective
term weights is replaced by probability estimation, which is better understood
and has a formal basis. The basic query likelihood score with Dirichlet smooth-
ing has similar effectiveness to BM25, although it does do better on most TREC
collections. If more sophisticated smoothing based on topic models is used (de-
scribed further in section 7.6), query likelihood consistently outperforms BM25.
Thismeans that instead of smoothing using the collection probabilities for words,
we instead use word probabilities from similar documents.

The simplicity of the languagemodel framework, combinedwith the ability to
describe a variety of retrieval applications and the effectiveness of the associated



7.3 Ranking Based on Language Models 261

ranking algorithms, make this approach a good choice for a retrieval model based
on topical relevance.

7.3.2 Relevance Models and Pseudo-Relevance Feedback

Although the basic query likelihood model has a number of advantages, it is lim-
ited in terms of how it models information needs and queries. It is difficult, for
example, to incorporate information about relevant documents into the ranking
algorithm, or to represent the fact that a query is just one ofmany possible queries
that could be used to describe a particular information need. In this section, we
show how this can be done by extending the basic model.

In the introduction to section 7.3, wementioned that it is possible to represent
the topic of a query as a languagemodel. Instead of calling this the query language
model, we use the name relevance model since it represents the topic covered by
relevant documents.The query can be viewed as a very small sample of text gener-
ated from the relevance model, and relevant documents are much larger samples
of text from the same model. Given some examples of relevant documents for a
query, we could estimate the probabilities in the relevance model and then use
this model to predict the relevance of new documents. In fact, this is a version of
the classificationmodel presented in section 7.2.1, wherewe interpretP (D|R) as
the probability of generating the text in a document given a relevancemodel.This
is also called the document likelihood model. Although this model, unlike the bi-
nary independence model, directly incorporates term frequency, it turns out that
P (D|R) is difficult to calculate and compare across documents. This is because
documents contain a large and extremely variable number of words compared
to a query. Consider two documents Da and Db, for example, containing 5 and
500 words respectively. Because of the large difference in the number of words
involved, the comparison of P (Da|R) and P (Db|R) for ranking will be more
difficult than comparingP (Q|Da) andP (Q|Db), which use the same query and
smoothed representations for the documents. In addition, we still have the prob-
lem of obtaining examples of relevant documents.

There is, however, another alternative. If we can estimate a relevance model
from a query, we can compare this language model directly with the model for a
document. Documents would then be ranked by the similarity of the document
model to the relevance model. A document with a model that is very similar to
the relevance model is likely to be on the same topic. The obvious next question
is how to compare two language models. A well-known measure from probabil-
ity theory and information theory, theKullback-Leibler divergence (referred to as



262 7 Retrieval Models

KL-divergence in this book),12 measures the difference between two probability
distributions. Given the true probability distributionP and another distribution
Q that is an approximation to P , the KL divergence is defined as:

KL(P ||Q) =
?
x

P (x) log P (x)
Q(x)

Since KL-divergence is always positive and is larger for distributions that are fur-
ther apart, we use the negativeKL-divergence as the basis for the ranking function
(i.e., smaller differences mean higher scores). In addition, KL-divergence is not
symmetric, and it matters which distribution we pick as the true distribution. If
we assume the true distribution to be the relevance model for the query (R) and
the approximation to be the document language model (D), then the negative
KL-divergence can be expressed as?

w?V

P (w|R) logP (w|D)?
?
w?V

P (w|R) logP (w|R)

where the summation is over all wordsw in the vocabularyV .The second termon
the right-hand side of this equation does not depend on the document, and can be
ignored for ranking. Given a simple maximum likelihood estimate for P (w|R),
based on the frequency in the query text (fw,Q) and the number of words in the
query (|Q|), the score for a document will be:?

w?V

fw,Q
|Q|

logP (w|D)

Although this summation is over all words in the vocabulary, words that do not
occur in the query have a zero maximum likelihood estimate and will not con-
tribute to the score. Also, query words with frequency k will contribute k ×
logP (w|D) to the score. This means that this score is rank equivalent to the
query likelihood score described in the previous section. In other words, query
likelihood is a special case of a retrieval model that ranks by comparing a rele-
vance model based on a query to a document language model.

The advantage of the more general model is that it is not restricted to the sim-
ple method of estimating the relevancemodel using query term frequencies. If we

12 KL-divergence is also called information divergence, information gain, or relative en-
tropy.



7.3 Ranking Based on Language Models 263

regard the query words as a sample from the relevance model, then it seems rea-
sonable to base the probability of a new sample word on the query words we have
seen. In other words, the probability of pulling a wordw out of the “bucket” rep-
resenting the relevance model should depend on the n query words we have just
pulled out. More formally, we can relate the probability of w to the conditional
probability of observingw given that we just observed the query words q1 . . . qn
by the approximation:

P (w|R) ? P (w|q1 . . . qn)

By definition, we can express the conditional probability in terms of the joint
probability of observingw with the query words:

P (w|R) ? P (w, q1 . . . qn)
P (q1 . . . qn)

P (q1 . . . qn) is a normalizing constant and is calculated as:

P (q1 . . . qn) =
?
w?V

P (w, q1 . . . qn)

Now the question is how to estimate the joint probabilityP (w, q1 . . . qn). Given
a set of documents C represented by language models, we can calculate the joint
probability as follows:

P (w, q1 . . . qn) =
?
D?C

p(D)P (w, q1 . . . qn|D)

We can also make the assumption that:

P (w, q1 . . . qn|D) = P (w|D)
n?

i=1

P (qi|D)

Whenwe substitute this expression forP (w, q1 . . . qn|D) into theprevious equa-
tion, we get the following estimate for the joint probability:

P (w, q1 . . . qn) =
?
D?C

P (D)P (w|D)
n?

i=1

P (qi|D)

How do we interpret this formula? The prior probability P (D) is usually as-
sumed tobe uniformand canbe ignored.Theexpression

?n
i=1 P (qi|D) is, in fact,



264 7 Retrieval Models

the query likelihood score for the documentD. This means that the estimate for
P (w, q1 . . . qn) is simply a weighted average of the language model probabilities
forw in a set of documents, where the weights are the query likelihood scores for
those documents.

Ranking based on relevancemodels actually requires two passes.The first pass
ranks documents using query likelihood to obtain the weights that are needed
for relevancemodel estimation. In the second pass, we use KL-divergence to rank
documents by comparing the relevance model and the document model. Note
also that we are in effect adding words to the query by smoothing the relevance
model using documents that are similar to the query. Many words that had zero
probabilities in the relevancemodel based on query frequency estimates will now
have non-zero values.What we are describing here is exactly the pseudo-relevance
feedback process described in section 6.2.4. In otherwords, relevancemodels pro-
vide a formal retrievalmodel for pseudo-relevance feedback and query expansion.
The following is a summary of the steps involved in ranking using relevance mod-
els:

1. Rank documents using the query likelihood score for queryQ.
2. Select some number of the top-ranked documents to be the set C.
3. Calculate the relevance model probabilities P (w|R) using the estimate for

P (w, q1 . . . qn).
4. Rank documents again using the KL-divergence score:13?

w

P (w|R) logP (w|D)

Some of these steps require further explanation. In steps 1 and 4, the docu-
ment language model probabilities (P (w|D)) should be estimated using Dirich-
let smoothing. In step 2, themodel allows the set C to be thewhole collection, but
because low-ranked documents have little effect on the estimation of P (w|R),
usually only 10–50 of the top-ranked documents are used. This also makes the
computation of P (w|R) substantially faster.

For similar reasons, the summation in step 4 is not done over all words in
the vocabulary. Typically only a small number (10–25) of the highest-probability
words are used. In addition, the importance of the original query words is em-
phasized by combining the original query frequency estimates with the relevance

13 More accurately, this score is the negative cross entropy because we removed the term?
w?V P (w|R) logP (w|R).



7.3 Ranking Based on Language Models 265

model estimates using a similar approach to Jelinek-Mercer, i.e.,?P (w|Q)+(1?
?)P (w|R), where ? is a mixture parameter whose value is determined empiri-
cally (0.5 is a typical value for TREC experiments). This combination makes it
clear that estimating relevance models is basically a process for query expansion
and smoothing.

The next important question, as for all retrieval models, is how well it works.
Based on TREC experiments, ranking using relevance models is one of the best
pseudo-relevance feedback techniques. In addition, relevance models produce a
significant improvement in effectiveness compared to query likelihood ranking
averaged over a number of queries. Like all current pseudo-relevance feedback
techniques, however, the improvements are not consistent, and some queries can
produce worse rankings or strange results.

Tables 7.4 and7.5 show the 16highest-probabilitywords from relevancemod-
els estimated using this technique with some example queries and a large collec-
tion ofTRECnews stories from the 1990s.14 Table 7.4 uses the top 10 documents
from the query likelihood ranking to construct the relevance model, whereas Ta-
ble 7.5 uses the top 50 documents.

The first thing to notice is that, although the words are reasonable, they are
very dependent on the collection of documents that is used. In the TREC news
collection, for example,many of the stories thatmentionAbrahamLincoln are on
the topic of the Lincoln Bedroom in the White House, which President Clinton
used for guests andPresident Lincoln used as an office during theCivilWar.These
types of stories are reflected in the top probabilitywords for the queries “president
lincoln” and “abraham lincoln”. Expanding the query using these words would
clearly favor the retrieval of this type of story rather thanmore general biographies
of Lincoln. The second observation is that there is not much difference between
the words based on 10 documents and the words based on 50 documents. The
words based on 50 documents are, however, somewhat more general because the
larger set of documents contains a greater variety of topics. In the case of the query
“tropical fish”, the relevancemodel words based on 10 documents are clearlymore
related to the topic.

In summary, ranking by comparing a model of the query to a model of the
document using KL-divergence is a generalization of query likelihood scoring.

14 This is a considerably larger collection than was used to generate the term association
tables in Chapter 6. Those tables were based on the ROBUST track data, which con-
sists of just over half a million documents. These tables were generated using all the
TREC news collections, which total more than six million documents.



266 7 Retrieval Models

president lincoln abraham lincoln fishing tropical fish
lincoln lincoln fish fish

president america farm tropic
room president salmon japan

bedroom faith new aquarium
house guest wild water
white abraham water species

america new caught aquatic
guest room catch fair
serve christian tag china
bed history time coral

washington public eat source
old bedroom raise tank

office war city reef
war politics people animal
long old fishermen tarpon

abraham national boat fishery

Table 7.4. Highest-probability terms from relevance model for four example queries (es-
timated using top 10 documents)

This generalization allows for more accurate queries that reflect the relative im-
portance of the words in the topic that the information seeker had in mind when
he was writing the query. Relevance model estimation is an effective pseudo-
relevance feedback technique based on the formal framework of language mod-
els, but as with all these techniques, caution must be used in applying relevance
model–based query expansion to a specific retrieval application.

Language models provide a formal but straightforward method of describing
retrieval models based on topical relevance. Even more sophisticated models can
be developed by incorporating term dependence and phrases, for example. Top-
ical relevance is, however, only part of what is needed for effective search. In the
next section,we focus on a retrievalmodel for combining all the pieces of evidence
that contribute to user relevance, which is what people who use a search engine
really care about.



7.4 Complex Queries and Combining Evidence 267

president lincoln abraham lincoln fishing tropical fish
lincoln lincoln fish fish

president president water tropic
america america catch water
new abraham reef storm

national war fishermen species
great man river boat
white civil new sea
war new year river

washington history time country
clinton two bass tuna
house room boat world
history booth world million
time time farm state
center politics angle time

kennedy public fly japan
room guest trout mile

Table 7.5. Highest-probability terms from relevance model for four example queries (es-
timated using top 50 documents)

7.4 Complex Queries and Combining Evidence

Effective retrieval requires the combination of many pieces of evidence about
a document’s potential relevance. In the case of the retrieval models described
in previous sections, the evidence consists of word occurrences that reflect top-
ical content. In general, however, there can be many other types of evidence that
should be considered. Even considering words, we may want to take into account
whether certain words occur near each other, whether words occur in particular
document structures, such as section headings or titles, or whether words are re-
lated to each other. In addition, evidence such as the date of publication, the doc-
ument type, or, in the case of web search, the PageRank number will also be im-
portant. Although a retrieval algorithm such as query likelihood or BM25 could
be extended to include some of these types of evidence, it is difficult not to resort
to heuristic “fixes” that make the retrieval algorithm difficult to tune and adapt to
new retrieval applications. Instead, what we really need is a framework where we
can describe the different types of evidence, their relative importance, and how
they should be combined. The inference network retrieval model, which has been



268 7 Retrieval Models

used in both commercial and open source search engines (and is incorporated in
Galago), is one approach to doing this.

The inference network model is based on the formalism of Bayesian networks
and is a probabilistic model. The model provides a mechanism for defining and
evaluating operators in a query language. Someof these operators are used to spec-
ify types of evidence, and others describe how it should be combined.The version
of the inference network we will describe uses language models to estimate the
probabilities that are needed to evaluate the queries.

In this section, we first give an overview of the inference network model, and
then show how that model is used as the basis of a powerful query language for
search applications. In the next section, we describe web search and explain how
the inference network model would be used to combine the many sources of evi-
dence required for effective ranking.

Queries described using the inference network query language appear to be
much more complicated than a simple text query with two or three words. Most
users will not understand this language, just as most relational database users do
not understand Structured Query Language (SQL). Instead, applications trans-
late simple user queries into more complex inference network versions. The more
complex query incorporates additional features and weights that reflect the best
combination of evidence for effective ranking. This point will become clearer as
we discuss examples in the next two sections.

7.4.1 The Inference Network Model

A Bayesian network is a probabilistic model that is used to specify a set of events
and the dependencies between them. The networks are directed, acyclic graphs
(DAGs), where the nodes in the graph represent events with a set of possible
outcomes and arcs represent probabilistic dependencies between the events. The
probability, or belief,15 of a particular event outcome can be determined given
the probabilities of the parent events (or a prior probability in the case of a root
node).When used as a retrieval model, the nodes represent events such as observ-
ing a particular document, or a particular piece of evidence, or some combination
of pieces of evidence. These events are all binary, meaning that TRUE and FALSE
are the only possible outcomes.

15 Belief network is the name for a range of techniques used to model uncertainty. A
Bayesian network is a probabilistic belief network.



7.4 Complex Queries and Combining Evidence 269

I

D

 title  body  h1

r1 rN… r1 rN… r1 rN…

q1 q2

!title

!body

!h1

Fig. 7.4. Example inference network model

Figure 7.4 shows an inference net where the evidence being combined are
words in a web page’s title, body, and <h1> headings. In this figure, D is a docu-
ment node.This node corresponds to the event that a document (the web page) is
observed. There is one document node for every document in the collection, and
we assume that only one document is observed at any time. The ri or represen-
tation nodes are document features (evidence), and the probabilities associated
with those features are based on language models ? estimated using the parame-
tersµ.There is one languagemodel for each significant document structure (title,
body, or headings). In addition to features based on word occurrence, ri nodes
also represent proximity features. Proximity features take a number of different
forms, such as requiring words to co-occur within a certain “window” (length)
of text, and will be described in detail in the next section. Features that are not
based on language models, such as document date, are allowed but not shown in
this example.

The query nodes qi are used to combine evidence from representation nodes
and other query nodes.These nodes represent the occurrence ofmore complex ev-
idence and document features. A number of forms of combination are available,
with Boolean AND and OR being two of the simplest. The network as a whole
computes P (I|D,µ), which is the probability that an information need is met



270 7 Retrieval Models

given the document and the parameters µ. The information need node I is a spe-
cial query node that combines all of the evidence from the other query nodes into
a single probability or belief score. This score is used to rank documents. Con-
ceptually, this means we must evaluate an inference network for every document
in the collection, but as with every other ranking algorithm, indexes are used to
speed up the computation. In general, representation nodes are indexed, whereas
query nodes are specified for each query by the user or search application. This
means that indexes for a variety of proximity features, in addition towords, will be
created (as described inChapter 5), significantly expanding the size of the indexes.
In some applications, theprobabilities associatedwithproximity features are com-
puted at query time in order to provide more flexibility in specifying queries.

The connections in the inference network graph are defined by the query and
the representation nodes connected to every document in the collection. The
probabilities for the representation nodes are estimated using language models
for each document. Note that these nodes do not represent the occurrence of a
particular feature in a document, but instead capture the probability that the fea-
ture is characteristic of the document, in the sense that the language model could
generate it. For example, a node for theword “lincoln” represents the binary event
that a document is about that topic (or not), and the language model for the doc-
ument is used to calculate the probability of that event being TRUE.

Since all the events in the inference network are binary, we cannot really use
a multinomial model of a document as a sequence of words. Instead, we use a
multiple-Bernoulli16 model, which is the basis for the binary independencemodel
in section 7.2.1. In that case, a document is represented as a binary feature vec-
tor, which simply records whether a feature is present or not. In order to capture
term frequency information, a different multiple-Bernoulli model is used where
the document is represented by a multiset17 of vectors, with one vector for each
term occurrence (Metzler, Lavrenko, & Croft, 2004). It turns out that with the
appropriate choice of parameters, the probability estimate based on themultiple-
Bernoulli distribution is the same as the estimate for themultinomial distribution
with Dirichlet smoothing, which is

16 Named after the Swissmathematician JakobBernoulli (also known as James or Jacques,
and one of eight famous mathematicians in the same family). The multiple-Bernoulli
model is discussed further in Chapter 9.

17 A multiset (also called a bag) is a set where each member has an associated number
recording the number of times it occurs.



7.4 Complex Queries and Combining Evidence 271

P (ri|D,µ) =
fri,D + µP (ri|C)
|D|+ µ

where fi,D is the number of times feature ri occurs in document D, P (ri|C) is
the collection probability for feature ri, and µ is the Dirichlet smoothing param-
eter. To be more precise, for the model shown in Figure 7.4 we would use fi,D
counts, collection probabilities, and a value for µ that are specific to the docu-
ment structure of interest. For example, if fi,D was the number of times feature ri
occurs in a document title, the collection probabilities would be estimated from
the collection of all title texts, and theµ parameterwould be specific to titles. Also
note that the same estimation formula is used for proximity-based features as for
words. For example, for a feature such as “NewYork” where the wordsmust occur
next to each other, fi,D is the number of times “New York” occurs in the text.

The query nodes, which specify how to combine evidence, are the basis of the
operators in the query language. Although Bayesian networks permit arbitrary
combinations (constrained by the laws of probability), the inference network re-
trievalmodel is based on operators that can be computed efficiently. At each node
in the network, we need to specify the probability of each outcome given all pos-
sible states of the parent nodes. When the number of parent nodes is large, this
could clearly get expensive. Fortunately,many of the interesting combinations can
be expressed as simple formulas.

As an example of the combination process and how it can be done efficiently,
consider Boolean AND. Given a simple network for a query node q with two par-
ent nodes a and b, as shown in Figure 7.5, we can describe the conditional prob-
abilities as shown in Table 7.6.

a b

q

Fig. 7.5. Inference network with three nodes

We can refer to the values in the first column of Table 7.6 using pij , where i
and j refer to the states of the parents. For example, p10 refers to the probability



272 7 Retrieval Models

P (q = TRUE|a, b) a b
0 FALSE FALSE
0 FALSE TRUE
0 TRUE FALSE
1 TRUE TRUE

Table 7.6. Conditional probabilities for example network

that q is TRUE given that a is TRUE and b is FALSE. To compute the probability of
q, we use this table and the probabilities of the parent nodes (which come from
the representation nodes) as follows:

beland(q) = p00P (a = FALSE)P (b = FALSE)

+p01P (a = FALSE)P (b = TRUE)

+p10P (a = TRUE)P (b = FALSE)

+p11P (a = TRUE)P (b = TRUE)

= 0 · (1? pa)(1? pb) + 0 · (1? pa)pb + 0 · pa(1? pb) + 1 · papb
= papb

where pa is the probability that a is true, and pb is the probability that b is true.
We use the name beland(q) to indicate that this is the belief value (probability)
that results from an AND combination.

Thismeans that theAND combinationof evidence is computedby simplymul-
tiplying the probabilities of the parent nodes. If one of the parent probabilities
is low (or zero if smoothing is not used), then the combination will have a low
probability. This seems reasonable for this type of combination. We can define a
number of other combination operators in the same way. If a q node has n par-
ents with probability of being true pi, then the following list defines the common
operators:

belnot(q) = 1? p1

belor(q) = 1?
n?
i

(1? pi)

beland(q) =
n?
i

pi



7.4 Complex Queries and Combining Evidence 273

belwand(q) =
n?
i

pwtii

belmax(q) = max{p1, p2, . . . , pn}

belsum(q) =

?n
i pi
n

belwsum(q) =

?n
i wtipi?n
i wti

wherewti is a weight associated with the ith parent, which indicates the relative
importance of that evidence.Note thatNOT is a unary operator (i.e., has only one
parent).

TheweightedAND operator is very important and one of themost commonly
used in the query language described in the next section. Using this form of com-
bination and restricting the evidence (representation nodes) to individual words
gives the same ranking as query likelihood.

Given this descriptionof theunderlyingmodel and combinationoperators,we
can now define a query language that can be used in a search engine to produce
rankings based on complex combinations of evidence.

7.4.2 The Galago Query Language

The Galago query language presented here is similar to query languages used
in open source search engines that are based on the inference network retrieval
model.18 This version focuses on the most useful aspects of those languages for a
variety of search applications, and adds the ability to use arbitrary features. Note
that the Galago search engine is not based on a specific retrieval model, but in-
stead provides an efficient framework for implementing retrieval models.

Although the query language can easily handle simple unstructured text docu-
ments,many of themore interesting featuresmake use of evidence based on docu-
ment structure.We assume that structure is specified using tag pairs, as inHTML
or XML. Consider the following document:

<html>
<head>
<title>Department Descriptions</title>
</head>

18 Such as Inquery and Indri.



274 7 Retrieval Models

<body>
The following list describes ...
<h1>Agriculture</h1> ...
<h1>Chemistry</h1> ...
<h1>Computer Science</h1> ...
<h1>Electrical Engineering</h1> ...
</body>
</html>

In theGalago query language, a document is viewed as a sequence of text thatmay
contain arbitrary tags. In the example just shown, the document consists of text
marked up with HTML tags.

For each tag type T within a document (e.g., title, body, h1, etc.), we define
the context19 of T to be all of the text and tags that appear within tags of type T.
In the example, all of the text and tags appearing between <body> and </body>
tags define the body context. A single context is generated for each unique tag
name. Therefore, a context defines a subdocument. Note that because of nested
tags, certainword occurrencesmay appear inmany contexts. It is also the case that
there may be nested contexts. For example, within the <body> context there is a
nested <h1> context made up of all of the text and tags that appear within the
body context and within <h1> and </h1> tags. Here are the tags for the title, h1,
and body contexts in this example document:

title context:

<title>Department Descriptions</title>

h1 context:

<h1>Agriculture</h1>
<h1>Chemistry</h1> ...
<h1>Computer Science</h1> ...
<h1>Electrical Engineering</h1> ...

body context:

<body> The following list describes ...
<h1>Agriculture</h1> ...
<h1>Chemistry</h1> ...

19 Contexts are sometimes referred to as fields.



7.4 Complex Queries and Combining Evidence 275

<h1>Computer Science</h1> ...
<h1>Electrical Engineering</h1> ...
</body>

Each context is made up of one or more extents. An extent is a sequence of
text that appears within a single begin/end tag pair of the same type as the con-
text. For this example, in the<h1> context, there are extents<h1>Agriculture</h1>,
<h1>Chemistry<h1>, etc. Both the title and body contexts contain only a single ex-
tent because there is only a single pair of <title> and <body> tags, respectively.The
number of extents for a given tag type is determined by the number of tag pairs
of that type that occur within the document.

In addition to the structure defined when a document is created, contexts are
also used to represent structure added by feature extraction tools. For example,
dates, people’s names, and addresses can be identified in text and tagged by a fea-
ture extraction tool. As long as this information is represented using tag pairs, it
can be referred to in the query language in the sameway as other document struc-
tures.

Terms are the basic building blocks of the query language, and correspond to
representation nodes in the inference network model. A variety of types of terms
can be defined, such as simple terms, ordered and unordered phrases, synonyms,
and others. In addition, there are a number of options that can be used to specify
that a term should appear within a certain context, or that it should be scored
using a language model that is estimated using a given context.

Simple terms:
term – term that will be normalized and stemmed.
”term” – term is not normalized or stemmed.
Examples:
presidents
”NASA”

Proximity terms:
#od:N( ... ) – ordered window – terms must appear ordered, with at most
N-1 terms between each.
#od( ... ) – unlimited ordered window – all terms must appear ordered
anywhere within current context.
#uw:N( ... )– unorderedwindow– all termsmust appear within a window
of length N in any order.



276 7 Retrieval Models

#uw( ... ) – unlimited unordered window – all terms must appear within
current context in any order.
Examples:
#od:1(white house) – matches “white house” as an exact phrase.
#od:2(white house)–matches “white * house” (where * is anywordornull).
#uw:2(white house) – matches “white house” and “house white”.

Synonyms:
#syn( ... )
#wsyn( ... )
The first two expressions are equivalent. They each treat all of the terms
listed as synonyms. The #wsyn operator treats the terms as synonyms, and
allows weights to be assigned to each term. The arguments given to these
operators can only be simple terms or proximity terms.
Examples:
#syn(dog canine) – simple synonym based on two terms.
#syn( #od:1(united states) #od:1(united states of america) ) – creates a syn-
onym from two proximity terms.
#wsyn( 1.0 donald 0.8 don 0.5 donnie ) – weighted synonym indicating
relative importance of terms.

Anonymous terms:
#any:.() – used to match extent types
Examples:
#any:person() – matches any occurrence of a person extent.
#od:1(lincoln died in #any:date())–matches exact phrases of the form:“lincoln
died in<date>…</date>”.

Context restriction and evaluation:
expression.C1„...,CN – matches when the expression appears in all con-
texts C1 through CN.
expression.(C1,...,CN) – evaluates the expression using the languagemodel
defined by the concatenation of contexts C1...CN within the document.
Examples:
dog.title – matches the term “dog” appearing in a title extent.
#uw(smith jones).author–matcheswhen the twonames “smith” and “jones”
appear in an author extent.
dog.(title) – evaluates the term based on the title language model for the



7.4 Complex Queries and Combining Evidence 277

document. This means that the estimate of the probability of occurrence
for dog for a given documentwill be based on the number of times that the
word occurs in the title field for that document andwill be normalized us-
ing the number of words in the title rather than the document. Similarly,
smoothing is done using the probabilities of occurrence in the title field
over the whole collection.
#od:1(abraham lincoln).person.(header) – builds a language model from all
of the “header” text in the document and evaluates #od:1(abraham lin-
coln).person in that context (i.e., matches only the exact phrase appearing
within a person extent within the header context).

Belief operators are used to combine evidence about terms, phrases, etc.There are
both unweighted and weighted belief operators.With the weighted operator, the
relative importance of the evidence can be specified.This allows control over how
much each expressionwithin the query impacts the final score.The filter operator
is used to screen out documents that do not contain required evidence. All belief
operators can be nested.

Belief operators:
#combine(...) – this operator is a normalized version of the beland(q) op-
erator in the inference network model. See the discussion later for more
details.
#weight(...) – this is a normalized version of the belwand(q) operator.
#filter(...) – this operator is similar to #combine, but with the difference
that the document must contain at least one instance of all terms (simple,
proximity, synonym, etc.).The evaluation of nested belief operators is not
changed.
Examples:
#combine( #syn(dog canine) training ) – rank by two terms, one of which is
a synonym.
#combine( biography #syn(#od:1(president lincoln) #od:1(abraham lincoln)) )
– rank using two terms, one of which is a synonym of “president lincoln”
and “abraham lincoln”.
#weight( 1.0 #od:1(civil war) 3.0 lincoln 2.0 speech )– rankusing three terms,
and weight the term “lincoln” as most important, followed by “speech”,
then “civil war”.
#filter( aquarium #combine(tropical fish) ) – consider only those documents
containing the word “aquarium” and “tropical” or “fish”, and rank them



278 7 Retrieval Models

according to the query #combine(aquarium #combine(tropical fish)).
#filter( #od:1(john smith).author) #weight( 2.0 europe 1.0 travel ) – rank
documents about “europe” or “travel” that have “John Smith” in the au-
thor context.

As we just described, the #combine and #weight operators are normalized ver-
sions of the beland and belwand operators, respectively. The beliefs of these oper-
ators are computed as follows:

belcombine =
n?
i

p
1/n
i

belweight =
n?
i

p
wti/

?n
i? wti?

i

This normalization is done in order to make the operators behave more like the
original belsum and belwsum operators, which are both normalized. One advan-
tage of the normalization is that it allows us to describe the belief computa-
tion of these operators in terms of various types of means (averages). For exam-
ple, belsum computes the arithmetic mean over the beliefs of the parent nodes,
whereas belwsum computes a weighted arithmeticmean. Similarly, belcombine and
belwand compute a geometric mean and weighted geometric mean, respectively.

The filter operator also could be used with numeric and date field operators so
that non-textual evidence can be combined into the score. For example, the query

#filter(news.doctype #dateafter(12/31/1999).docdate
#uw:20( brown.person #any:company() #syn( money cash payment ) )

ranks documents that are news stories, that appeared after 1999, and that con-
tained at least one text segment of length 20 that mentioned a person named
“brown”, a company name, and at least one of the threewords dealingwithmoney.
The inference networkmodel can easily deal with the combination of this type of
evidence, but for simplicity, we have not implemented these operators in Galago.

Another part of the inferencenetworkmodel thatwedo support in theGalago
query language is document priors. Document priors allow the specification of
a prior probability over the documents in a collection. These prior probabilities
influence the rankings by preferring documents with certain characteristics, such
as those that were written recently or are short.



7.5 Web Search 279

Prior:
#prior:name() – uses the document prior specified by the name given. Pri-
ors are files or functions that provide prior probabilities for each docu-
ment.
Example:
#combine(#prior:recent() global warming) – uses a prior named recent to
give greater weight to documents that were published more recently.

As a more detailed example of the use of this query language, in the next sec-
tion we discuss web search and the types of evidence that have to be combined
for effective ranking. The use of the #feature operator to define arbitrary features
(new evidence) is discussed in Chapter 11.

7.5 Web Search

Measured in terms of popularity, web search is clearly the most important search
application. Millions of people use web search engines every day to carry out an
enormous variety of tasks, from shopping to research. Given its importance, web
search is the obvious example to use for explaining how the retrieval models we
have discussed are applied in practice.

There are some major differences between web search and an application that
provides search for a collection of news stories, for example.The primary ones are
the size of the collection (billions of documents), the connections between doc-
uments (i.e., links), the range of document types, the volume of queries (tens of
millions per day), and the types of queries. Some of these issues we have discussed
in previous chapters, and others, such as the impact of spam, will be discussed
later. In this section, we will focus on the features of the queries and documents
that are most important for the ranking algorithm.

There are a number of different types of search in a web environment. One
popular way of describing searches was suggested by Broder (2002). In this tax-
onomy, searches are either informational , navigational , or transactional . An in-
formational search has the goal of finding information about some topic thatmay
be on one or more web pages. Since every search is looking for some type of in-
formation, we call these topical searches in this book. A navigational search has
the goal of finding a particular web page that the user has either seen before or



280 7 Retrieval Models

assumes must exist.20 A transactional search has the goal of finding a site where
a task such as shopping or downloading music can be performed. Each type of
search has an information need associated with it, but a different type of infor-
mation need. Retrieval models based on topical relevance have focused primarily
on the first type of information need (and search). To produce effective rankings
for the other types of searches, a retrievalmodel that can combine evidence related
to user relevance is required.

Commercial web search engines incorporate hundreds of features (types of ev-
idence) in their ranking algorithms,manyderived from thehuge collectionof user
interaction data in the query logs. These can be broadly categorized into features
relating to page content, page metadata, anchor text, links (e.g., PageRank), and
user behavior. Although anchor text is derived from the links in a page, it is used
in a different way than features that come from an analysis of the link structure
of pages, and so is put into a separate category. Page metadata refers to informa-
tion about a page that is not part of the content of the page, such as its “age,” how
often it is updated, the URL of the page, the domain name of its site, and the
amount of text content in the page relative to other material, such as images and
advertisements.

It is interesting to note that understanding the relative importance of these
features and how they can be manipulated to obtain better search rankings for
a web page is the basis of search engine optimization (SEO). A search engine op-
timizer may, for example, improve the text used in the title tag of the web page,
improve the text in heading tags, make sure that the domain name andURL con-
tain important keywords, and try to improve the anchor text and link structure
related to the page. Some of these techniques are not viewed as appropriate by the
web search engine companies, and will be discussed further in section 9.1.5.

In the TREC environment, retrieval models have been compared using test
collections of web pages and amixture of query types.The features related to user
behavior and some of the page metadata features, such as frequency of update,
are not available in the TREC data. Of the other features, themost important for
navigational searches are the text in the title, body, and heading (h1, h2, h3, and h4)
parts of the document; the anchor text of all links pointing to the document; the
PageRank number; and the inlink count (number of links pointing to the page).

20 In the TREC world, navigational searches are called home-page and named-page
searches.Topical searches are called adhoc searches.Navigational searches are similar to
known-item searches, which have been discussed in the information retrieval literature
for many years.



7.5 Web Search 281

Note that we are not saying that other features do not affect the ranking in web
search engines, just that these were the ones that had the most significant impact
in TREC experiments.

Given the size of the Web, many pages will contain all the query terms. Some
ranking algorithms rank only those pages which, in effect, filters the results us-
ing a Boolean AND. This can cause problems if only a subset of the Web is used
(such as in a site search application) and is particularly risky with topical searches.
For example, only about 50% of the pages judged relevant in the TREC topical
web searches contain all the query terms. Instead of filtering, the ranking algo-
rithm should strongly favor pages that contain all query terms. In addition, term
proximitywill be important.The additional evidence of terms occurring near each
other will significantly improve the effectiveness of the ranking. A number of re-
trieval models incorporating term proximity have been developed. The following
approach is designed towork in the inference networkmodel, and produces good
results.21

The dependencemodel is based on the assumption that query terms are likely to
appear in close proximity to each other within relevant documents. For example,
given the query “Green party political views”, relevant documents will likely con-
tain the phrases “green party” and “political views” within relatively close prox-
imity to one another. If the query is treated as a set of terms Q, we can define
SQ as the set of all non-empty subsets ofQ. A Galago query attempts to capture
dependencies between query terms as follows:

1. Every s ? SQ that consists of contiguous query terms is likely to appear as an
exact phrase in a relevant document (i.e., represented using the #od:1 opera-
tor).

2. Every s ? SQ such that |s| > 1 is likely to appear (ordered or unordered)
within a reasonably sized window of text in a relevant document (i.e., in a
window represented as #uw:8 for |s| = 2 and #uw:12 for |s| = 3 ).

As an example, this model produces the Galago query language representation
shown in Figure 7.6 for the TREC query “embryonic stem cells”, where the
weights were determined empirically to produce the best results.

Given the important pieces of evidence for web search ranking, we can now
give an example of a Galago query that combines this evidence into an effective
ranking. For the TREC query “pet therapy”, we would produce the Galago query
shown in Figure 7.7.Thefirst thing to note about this query is that it clearly shows

21 The formal model is described in Metzler and Croft (2005b).



282 7 Retrieval Models

#weight(
0.8 #combine(embryonic stem cells)
0.1 #combine( #od:1(stem cells) #od:1(embryonic stem)

#od:1(embryonic stem cells))
0.1 #combine( #uw:8(stem cells) #uw:8(embryonic cells)

#uw:8(embryonic stem) #uw:12(embryonic stem cells)))

Fig. 7.6. Galago query for the dependence model

how a complex query expression can be generated from a simple user query. A
number of proximity terms have been added, and all terms are evaluated using
contexts based on anchor text, title text, body text, and heading text. From an
efficiency perspective, the proximity terms may be indexed, even though this will
increase the index size substantially.The benefit is that these relatively large query
expressions will be able to be evaluated very efficiently at query time.

#weight(
0.1 #weight( 0.6 #prior(pagerank) 0.4 #prior(inlinks))
1.0 #weight(

0.9 #combine(
#weight( 1.0 pet.(anchor) 1.0 pet.(title)

3.0 pet.(body) 1.0 pet.(heading))
#weight( 1.0 therapy.(anchor) 1.0 therapy.(title)

3.0 therapy.(body) 1.0 therapy.(heading)))
0.1 #weight(

1.0 #od:1(pet therapy).(anchor) 1.0 #od:1(pet therapy).(title)
3.0 #od:1(pet therapy).(body) 1.0 #od:1(pet therapy).(heading))

0.1 #weight(
1.0 #uw:8(pet therapy).(anchor) 1.0 #uw:8(pet therapy).(title)
3.0 #uw:8(pet therapy).(body) 1.0 #uw:8(pet therapy).(heading)))

)

Fig. 7.7. Galago query for web data

The PageRank and inlink evidence is incorporated into this query as prior
probabilities. In other words, this evidence is independent of specific queries and
can be calculated at indexing time. The weights in the query were determined by



7.6 Machine Learning and Information Retrieval 283

experiments with TREC Web page collections, which are based on a crawl of the
.gov domain. The relative importance of the evidence could be different for the
fullWeb or for other collections.The text in themain body of the page was found
to be more important than the other parts of the document and anchor text, and
this is reflected in the weights.

Experiments with the TREC data have also shown that much of the evi-
dence that is crucial for effective navigational search is not important for top-
ical searches. In fact, the only features needed for topical search are the simple
terms and proximity terms for the body part of the document. The other fea-
tures do not improve effectiveness, but they also do not reduce it. Another dif-
ference between topical and navigational searches is that query expansion using
pseudo-relevance feedback was found to help topical searches, but made naviga-
tional searches worse. Navigational searches are looking for a specific page, so it is
not surprising that smoothing the query by adding a number of extra terms may
increase the “noise” in the results. If a search was known to be in the topical cat-
egory, query expansion could be used, but this is difficult to determine reliably,
and since the potential effectiveness benefits of expansion are variable and some-
what unpredictable, this technique is generally not used. Given that the evidence
needed to identify good sites for transaction searches seems to be similar to that
needed for navigational searches, this means that the same ranking algorithm can
be used for the different categories of web search.

Other researchhas shown that user behavior information, such as clickthrough
data (e.g., which documents have been clicked on in the past, which rank posi-
tions were clicked) and browsing data (e.g., dwell time on page, links followed),
can have a significant impact on the effectiveness of the ranking. This type of ev-
idence can be added into the inference network framework using additional op-
erators, but as the number of pieces of evidence grows, the issue of how to deter-
mine the most effective way of combining and weighting the evidence becomes
more important. In the next section, we discuss techniques for learning both the
weights and the ranking algorithm using explicit and implicit feedback data from
the users.

7.6 Machine Learning and Information Retrieval

There has been considerable overlap between the fields of information retrieval
and machine learning. In the 1960s, relevance feedback was introduced as a tech-
nique to improve ranking based on user feedback about the relevance of docu-



284 7 Retrieval Models

ments in an initial ranking. This was an example of a simple machine-learning
algorithm that built a classifier to separate relevant from non-relevant documents
based on training data. In the 1980s and 1990s, information retrieval researchers
usedmachine learning approaches to learn ranking algorithms based onuser feed-
back. In the last 10 years, there has been a lot of research onmachine-learning ap-
proaches to text categorization. Many of the applications of machine learning to
information retrieval, however, have been limited by the amount of training data
available. If the system is trying to build a separate classifier for every query, there
is very little data about relevant documents available, whereas other machine-
learning applications may have hundreds or even thousands of training examples.
Even the approaches that tried to learn ranking algorithms by using training data
from all the queries were limited by the small number of queries and relevance
judgments in typical information retrieval test collections.

With the advent of web search engines and the huge query logs that are col-
lected from user interactions, the amount of potential training data is enormous.
This has led to the development of new techniques that are having a significant
impact in the field of information retrieval and on the design of search engines.
In the next section, we describe techniques for learning ranking algorithms that
can combine and weight the many pieces of evidence that are important for web
search.

Another very active area of machine learning has been the development of so-
phisticated statistical models of text. In section 7.6.2, we describe how thesemod-
els can be used to improve ranking based on language models.

7.6.1 Learning to Rank

All of the probabilistic retrieval models presented so far fall into the category of
generative models. A generative model for text classification assumes that docu-
ments were generated from some underlying model (in this case, usually a multi-
nomial distribution) and uses training data to estimate the parameters of the
model. The probability of belonging to a class (i.e., the relevant documents for
a query) is then estimated using Bayes’ Rule and the document model. A discrim-
inativemodel, in contrast, estimates the probability of belonging to a class directly
from the observed features of the document based on the training data.22 In gen-
eral classification problems, a generative model performs better with low num-
bers of training examples, but the discriminative model usually has the advantage

22 We revisit the discussion of generative versus discriminative classifiers in Chapter 9.



7.6 Machine Learning and Information Retrieval 285

given enough data. Given the amount of potential training data available to web
search engines, discriminative models may be expected to have some advantages
in this application. It is also easier to incorporate new features into a discrimina-
tive model and, as we have mentioned, there can be hundreds of features that are
considered for web ranking.

Early applications of learning a discriminativemodel (discriminative learning)
in information retrieval used logistic regression to predict whether a document
belonged to the relevant class. The problem was that the amount of training data
and, consequently, the effectiveness of the technique depended on explicit rele-
vance judgments obtained from people. Even given the resources of a commer-
cial web search company, explicit relevance judgments are costly to obtain. On
the other hand, query logs contain a large amount of implicit relevance informa-
tion in the form of clickthroughs and other user interactions. In response to this,
discriminative learning techniques based on this form of training data have been
developed.

The best-known of the approaches used to learn a ranking function for search
is based on the Support Vector Machine (SVM) classifier. This technique will be
discussed in more detail in Chapter 9, so in this section we will just give a brief
description of how a Ranking SVM can learn to rank.23

The input to the Ranking SVM is a training set consisting of partial rank in-
formation for a set of queries

(q1, r1), (q2, r2), . . . , (qn, rn)

where qi is a query and ri is partial information about the desired ranking, or rele-
vance level, of documents for that query. This means that if document da should
be ranked higher than db, then (da, db) ? ri; otherwise, (da, db) /? ri.Where do
these rankings come from? If relevance judgments are available, the desired rank-
ing would put all documents judged to be at a higher relevance level above those
at a lower level. Note that this accommodates multiple levels of relevance, which
are often used in evaluations of web search engines.

If relevance judgments are not available, however, the ranking can be based
on clickthrough and other user data. For example, if a person clicks on the third
document in a ranking for a query and not on the first two, we can assume that
it should be ranked higher in r. If d1, d2, and d3 are the documents in the first,

23 This description is based on Joachims’ paper on learning to rank using clickthrough
data (Joachims, 2002b).



286 7 Retrieval Models

second, and third rank of the search output, the clickthrough data will result in
pairs (d3, d1) and (d3, d2)being in thedesired ranking for this query.This ranking
data will be noisy (because clicks are not relevance judgments) and incomplete,
but there will be a lot of it, and experiments have shown that this type of training
data can be used effectively.

Let’s assume that we are learning a linear ranking function w?.d?a, where w? is a
weight vector that is adjusted by learning, and d?a is the vector representation of
the features of document da. These features are, as we described in the last sec-
tion, based on page content, page metadata, anchor text, links, and user behavior.
Instead of language model probabilities, however, the features used in this model
that depend on the match between the query and the document content are usu-
ally simpler and less formal. For example, there may be a feature for the number
of words in common between the query and the document body, and similar fea-
tures for the title, header, and anchor text.The weights in the w? vector determine
the relative importance of these features, similar to the weights in the inference
network operators. If a document is represented by three features with integer val-
ues d? = (2, 4, 1) and the weights w? = (2, 1, 2), then the score computed by the
ranking function is just:

w?.d? = (2, 1, 2).(2, 4, 1) = 2.2 + 1.4 + 2.1 = 10

Given the training set of queries and rank information, we would like to find a
weight vector w? thatwould satisfy asmanyof the following conditions as possible:

?(di, dj) ? r1 : w?.d?i > w?.d?j
. . .

?(di, dj) ? rn : w?.d?i > w?.d?j

This simply means that for all document pairs in the rank data, we would like the
score for the document with the higher relevance rating (or rank) to be greater
than the score for the document with the lower relevance rating. Unfortunately,
there is no efficient algorithm to find the exact solution for w?. We can, however,
reformulate this problem as a standard SVM optimization as follows:



7.6 Machine Learning and Information Retrieval 287

minimize: 1
2
w?.w? + C

?
?i,j,k

subject to:
?(di, dj) ? r1 : w?.d?i > w?.d?j + 1? ?i,j,1

. . .

?(di, dj) ? rn : w?.d?i > w?.d?j + 1? ?i,j,n
?i?j?k : ?i, j, k ? 0

where ?, known as a slack variable, allows formisclassification of difficult or noisy
training examples, andC is a parameter that is used to prevent overfitting.Overfit-
ting happens when the learning algorithm produces a ranking function that does
very well at ranking the training data, but does not do well at ranking documents
for a new query. Software packages are available24 that do this optimization and
produce a classifier.

Where did this optimization come from? The impatient reader will have to
jump ahead to the explanation for a general SVM classifier in Chapter 9. For the
time being, we can say that the SVMalgorithmwill find a classifier (i.e., the vector
w?) that has the following property. Each pair of documents in our training data
can be represented by the vector (d?i? d?j). If we compute the score for this pair as
w?.(d?i? d?j), the SVM classifier will find a w? thatmakes the smallest score as large
as possible. The same thing is true for negative examples (pairs of documents that
are not in the rank data). This means that the classifier will make the differences
in scores as large as possible for the pairs of documents that are hardest to rank.

Note that thismodel does not specify the features that should be used. It could
even be used to learn the weights for features corresponding to scores from com-
pletely different retrieval models, such as BM25 and language models. Combin-
ingmultiple searches for a given query has been shown to be effective in a number
of experiments, and is discussed further in section 10.5.1. It should also be noted
that the weights learned by Ranking SVM (or some other discriminative tech-
nique) can be used directly in the inference network query language.

Although linear discriminative classifiers such as Ranking SVM may have an
advantage for web search, there are other search applications where there will be
less training data and less features available. For these applications, the generative
models of topical relevance may be more effective, especially as the models con-
tinue to improve through better estimation techniques.Thenext section discusses

24 Such as SVM light; see http://svmlight.joachims.org.



288 7 Retrieval Models

how estimation can be improved by modeling a document as a mixture of topic
models.

7.6.2 Topic Models and Vocabulary Mismatch

One of the important issues in general information retrieval is vocabulary mis-
match. This refers to a situation where relevant documents do not match a query,
because they are using different words to describe the same topic. In the web en-
vironment, many documents will contain all the query words, so this may not ap-
pear to be an issue. In search applications with smaller collections, however, it will
be important, and even in web search, TREC experiments have shown that topi-
cal queries produce better results using query expansion.Query expansion (using,
for example, pseudo-relevance feedback) is the standard technique for reducing
vocabularymismatch, although stemming also addresses this issue to some extent.
A different approach would be to expand the documents by adding related terms.
For documents represented as language models, this is equivalent to smoothing
the probabilities in the language model so that words that did not occur in the
text have non-zero probabilities. Note that this is different from smoothing us-
ing the collection probabilities, which are the same for all documents. Instead, we
need some way of increasing the probabilities of words that are associated with
the topic of the document.

A number of techniques have been proposed to do this. If a document is
known to belong to a category or cluster of documents, then the probabilities of
words in that cluster can be used to smooth the document language model. We
describe the details of this in Chapter 9. A technique known as Latent Seman-
tic Indexing, or LSI,25 maps documents and terms into a reduced dimensionality
space, so that documents that were previously indexed using a vocabulary of hun-
dreds of thousands of words are now represented using just a few hundred fea-
tures. Each feature in this new space is a mixture or cluster of many words, and it
is this mixing that in effect smooths the document representation.

TheLatentDirichlet Allocation (LDA)model, which comes from themachine
learning community, models documents as a mixture of topics. A topic is a lan-
guagemodel, just as we defined previously. In a retrieval model such as query like-
lihood, each document is assumed to be associated with a single topic. There are,

25 This technique is also called Latent Semantic Analysis or LSA (Deerwester et al.,
1990). Note that “latent” is being used in the sense of “hidden.”



7.6 Machine Learning and Information Retrieval 289

in effect, as many topics as there are documents in the collection. In the LDA ap-
proach, in contrast, the assumption is that there is a fixed number of underlying
(or latent) topics that can be used to describe the contents of documents. Each
document is represented as a mixture of these topics, which achieves a smoothing
effect that is similar to LSI. In the LDA model, a document is generated by first
picking a distribution over topics, and then, for the next word in the document,
we choose a topic and generate a word from that topic.

Using our “bucket” analogy for language models, we would need multiple
buckets to describe this process. For each document, wewould have one bucket of
topics, with the number of instances of each topic depending on the distribution
of topicswe had picked. For each topic, therewould be another bucket containing
words, with the number of instances of the words depending on the probabilities
in the topic language model. Then, to generate a document, we first select a topic
from the topic bucket (still without looking), then go to the bucket of words for
the topic that had been selected and pick out a word.The process is then repeated
for the next word.

More formally, the LDA process for generating a document is:

1. For each document D, pick a multinomial distribution ?D from a Dirichlet
distribution with parameter ?.

2. For each word position in documentD:
a) Pick a topic z from the multinomial distribution ?D.
b) Choose a word w from P (w|z, ?), a multinomial probability condi-

tioned on the topic z with parameter ?.

A variety of techniques are available for learning the topic models and the ?
distributions using the collection of documents as the training data, but all of
these methods tend to be quite slow. Once we have these distributions, we can
produce language model probabilities for the words in documents:

Plda(w|D) = P (w|?D, ?) =
?
z

P (w|z, ?)P (z|?D)

These probabilities can then be used to smooth the document representation by
mixing them with the query likelihood probability as follows:

P (w|D) = ?

(
fw,D + µ

cw
|C|

|D|+ µ

)
+ (1? ?)Plda(w|D)



290 7 Retrieval Models

So the final languagemodel probabilities are, in effect, a mixture of themaximum
likelihood probabilities, collection probabilities, and the LDA probabilities.

If the LDA probabilities are used directly as the document representation, the
effectiveness of the ranking will be significantly reduced because the features are
too smoothed. In TREC experiments, K (the number of topics) has a value of
around 400. This means that all documents in the collection are represented as
mixtures of just 400 topics. Given that there can be millions of words in a col-
lection vocabulary, matching on topics alone will lose some of the precision of
matching individualwords.Whenused to smooth thedocument languagemodel,
however, the LDA probabilities can significantly improve the effectiveness of
query likelihood ranking. Table 7.7 shows the high-probability words from four
LDA topics (out of 100) generated from a sample of TREC news stories.26 Note
that the names of the topics were not automatically generated.

Arts Budgets Children Education
new million children school
film tax women students
show program people schools
music budget child education
movie billion years teachers
play federal families high

musical year work public
best spending parents teacher
actor new says bennett
first state family manigat
york plan welfare namphy
opera money men state
theater programs percent president
actress government care elementary
love congress life haiti

Table 7.7. Highest-probability terms from four topics in LDA model

The main problem with using LDA for search applications is that estimating
the probabilities in the model is expensive. Until faster methods are developed,

26 This table is from Blei et al. (2003).



7.7 Application-Based Models 291

this technique will be limited to smaller collections (hundreds of thousands of
documents, but not millions).

7.7 Application-Based Models

In this chapter we have described a wide variety of retrieval models and ranking
algorithms. From the point of view of someone involved in designing and imple-
menting a search application, the question is which of these techniques should be
used and when? The answer depends on the application and the tools available.
Most search applications involvemuch smaller collections than theWeb and a lot
less connectivity in terms of links and anchor text. Ranking algorithms that work
well in web search engines often do not produce the best rankings in other appli-
cations. Customizing a ranking algorithm for the application will nearly always
produce the best results.

The first step in doing this is to construct a test collection of queries, docu-
ments, and relevance judgments so that different versions of the ranking algo-
rithm can be compared quantitatively. Evaluation is discussed in detail inChapter
8, and it is the key to an effective search engine.

The next step is to identify what evidence or features might be used to rep-
resent documents. Simple terms and proximity terms are almost always useful.
Significant document structure—such as titles, authors, and date fields—are also
nearly always important for search. In some applications, numeric fields may be
important. Text processing techniques such as stemming and stopwords alsomust
be considered.

Another important source of information that can be used for query expan-
sion is an application-specific thesaurus. These are surprisingly common since of-
ten an attempt will have been made to build them either manually or automati-
cally for a previous information system. Although they are often very incomplete,
the synonyms and related words they contain canmake a significant difference to
ranking effectiveness.

Having identified the various document features and other evidence, the next
task is to decide how to combine it to calculate a document score. An open source
search engine such as Galagomakes this relatively easy since the combination and
weighting of evidence can be expressed in the query language andmany variations
can be tested quickly. Other search engines do not have this degree of flexibility.
If a search engine based on a simple retrieval model is being used for the search
application, the descriptions of how scores are calculated in the BM25 or query



292 7 Retrieval Models

likelihood models and how they are combined in the inference network model
can be used as a guide to achieve similar effects by appropriate query transforma-
tions and additional code for scoring. For example, the synonym and relatedword
information in a thesaurus should not be used to simply addwords to a query.Un-
less some version of the #syn operator is used, the effectiveness of the ranking will
be reduced. The implementation of #syn in Galago can be used as an example of
how to add this operator to a search engine.

Much of the time spent in developing a search application will be spent on
tuning the retrieval effectiveness of the ranking algorithm. Doing this without
some concept of the underlying retrieval model can be very unrewarding. The re-
trieval models described in this chapter (namely BM25, query likelihood, rele-
vance models, inference network, and Ranking SVM) provide the best possible
blueprints for a successful ranking algorithm. For these models, good parame-
ter values and weights are already known from extensive published experiments.
These values can be used as a starting point for the process of determiningwhether
modifications are needed for an application. If enough training data is available,
a discriminative technique such as Ranking SVM will learn the best weights di-
rectly.

References and Further Reading

Since retrieval models are one of the most important topics in information re-
trieval, there aremanypapers describing research in this area, starting in the1950s.
One of the most valuable aspects of van Rijsbergen’s book (van Rijsbergen, 1979)
is the coverage of the older research in this area. In this book, we will focus on
some of themajor papers, rather than attempting to be comprehensive.These ref-
erences will be discussed in the order of the topics presented in this chapter.

The discussion of the nature of relevance has, understandably, been going on
in information retrieval for a long time. One of the earlier papers that is often
cited is Saracevic (1975). A more recent article gives a review of work in this area
(Mizzaro, 1997).

On the topic of Boolean versus ranked search, Turtle (1994) carried out an
experiment comparing the performance of professional searchers using the best
Boolean queries they could generate against keyword searches using ranked out-
put and foundnoadvantage for theBoolean search.When simpleBooleanqueries
are compared against ranking, as in Turtle and Croft (1991), the effectiveness of
ranking is much higher.



7.7 Application-Based Models 293

The vector space model was first mentioned in Salton et al. (1975), and is de-
scribed in detail in Salton and McGill (1983). The most comprehensive paper in
weighting experiments with this model is Salton and Buckley (1988), although
the term-weighting techniques described in section 7.1.2 are a later improvement
on those described in the paper.

The description of information retrieval as a classification problem appears in
van Rijsbergen (1979). The best paper on the application of the binary indepen-
dencemodel and its development into theBM25 ranking function is Sparck Jones
et al. (2000).

The use of language models in information retrieval started with Ponte and
Croft (1998), who described a retrieval model based on multiple-Bernoulli lan-
guage models. This was quickly followed by a number of papers that developed
themultinomial version of the retrieval model (Hiemstra, 1998; F. Song&Croft,
1999). Miller et al. (1999) described the same approach using a Hidden Markov
Model. Berger andLafferty (1999) showedhowtranslationprobabilities forwords
could be incorporated into the language model approach. We will refer to this
translation model again in section 10.3. The use of non-uniform prior probabili-
ties was studied by Kraaij et al. (2002). A collection of papers relating to language
models and information retrieval appears in Croft and Lafferty (2003).

Zhai and Lafferty (2004) give an excellent description of smoothing tech-
niques for language modeling in information retrieval. Smoothing using clusters
and nearest neighbors is described in Liu and Croft (2004) and Kurland and Lee
(2004).

An early term-dependency model was described in van Rijsbergen (1979). A
bigram language model for information retrieval was described in F. Song and
Croft (1999), but the more general models in Gao et al. (2004) and Metzler and
Croft (2005b) produced significantly better retrieval results, especiallywith larger
collections.

The relevance model approach to query expansion appeared in Lavrenko and
Croft (2001). Lafferty and Zhai (2001) proposed a related approach that built a
query model and compared it to document models.

There have beenmany experiments reported in the information retrieval liter-
ature showing that the combination of evidence significantly improves the rank-
ing effectiveness. Croft (2000) reviews these results and shows that this is not
surprising, given that information retrieval can be viewed as a classification prob-
lem with a huge choice of features. Turtle and Croft (1991) describe the infer-
ence network model. This model was used as the basis for the Inquery search en-



294 7 Retrieval Models

gine (Callan et al., 1992) and the WIN version of the commercial search engine
WESTLAW (Pritchard-Schoch, 1993). The extension of this model to include
language model probabilities is described in Metzler and Croft (2004). This ex-
tension was implemented as the Indri search engine (Strohman et al., 2005; Met-
zler, Strohman, et al., 2004). The Galago query language is based on the query
language for Indri.

The approach to web search described in section 7.5, which scores documents
based on a combination or mixture of language models representing different
parts of the document structure, is based on Ogilvie and Callan (2003). The
BM25F ranking function (Robertson et al., 2004) is an extension of BM25 that is
also designed to effectively combine information from different document fields.

Spam is of such importance in web search that an entire subfield, called ad-
versarial information retrieval , has developed to deal with search techniques for
document collections that are being manipulated by parties with different inter-
ests (such as spammers and search engine optimizers). We discuss the topic of
spam in Chapter 9.

The early work on learning ranking functions includes the use of logistic re-
gression (Cooper et al., 1992). Fuhr and Buckley (1991) were the first to de-
scribe clearly how using features that are independent of the actual query words
(e.g., using a feature like the number of matching terms rather than which terms
matched) enable the learning of ranking functions across queries. The use of
Ranking SVM for information retrieval was described by Joachims (2002b). Cao
et al. (2006) describe modifications of this approach that improve ranking effec-
tiveness. RankNet (C. Burges et al., 2005) is a neural network approach to learn-
ing a ranking function that is used in theMicrosoftweb search engine. Agichtein,
Brill, andDumais (2006) describe howuser behavior features can be incorporated
effectively into ranking based on RankNet. Both Ranking SVMs and RankNet
learn using partial rank information (i.e., pairwise preferences). Another class of
learningmodels, called listwise models, use the entire ranked list for learning. Ex-
amples of these models include the linear discriminative model proposed by Gao
et al. (2005), which learns weights for features that are based on languagemodels.
This approach has some similarities to the inference network model being used
to combine language model and other features. Another listwise approach is the
term dependence model proposed by Metzler and Croft (2005b), which is also
based on a linear combination of features. Both theGao andMetzler models pro-
vide a learning technique that maximizes average precision (an important infor-



7.7 Application-Based Models 295

mation retrieval metric) directly. More information about listwise learning mod-
els can be found in Xia et al. (2008).

Hofmann (1999) described a probabilistic version of LSI (pLSI) that intro-
duced the modeling of documents as a mixture of topics. The LDA model was
described by Blei et al. (2003). A number of extensions of this model have been
proposed since then, but they have not been applied to information retrieval.
The application of LDA to information retrieval was described in Wei and Croft
(2006).

Exercises

7.1. Use the “advanced search” feature of a web search engine to come up with
three examples of searches using the Boolean operators AND,OR, and NOT that
work better than using the same query in the regular search box.Do you think the
search engine is using a strict Boolean model of retrieval for the advanced search?

7.2. Can you think of anothermeasure of similarity that could be used in the vec-
tor space model? Compare your measure with the cosine correlation using some
example documents and queries with made-up weights. Browse the IR literature
on the Web and see whether your measure has been studied (start with van Rijs-
bergen’s book).

7.3. If each term represents a dimension in a t-dimensional space, the vector space
model is making an assumption that the terms are orthogonal. Explain this as-
sumption and discuss whether you think it is reasonable.

7.4. Derive Bayes’ Rule from the definition of a conditional probability:

P (A|B) = P (A ?B)
P (B)

Give an example of a conditional and a joint probability using the occurrence of
words in documents as the events.

7.5. Implement a BM25 module for Galago. Show that it works and document
it.

7.6. Show the effect of changingparameter values in yourBM25 implementation.



296 7 Retrieval Models

7.7. What is the “bucket” analogy for a bigram language model? Give examples.

7.8. Using the Galago implementation of query likelihood, study the impact of
short queries and long queries on effectiveness. Do the parameter settings make a
difference?

7.9. Implement the relevance model approach to pseudo-relevance feedback in
Galago. Show it works by generating some expansion terms for queries and doc-
ument it.

7.10. Show that the belwand operator computes the query likelihood score with
simple terms. What does the belwsum operator compute?

7.11. Implement a #not operator for the inference network query language in
Galago. Show some examples of how it works.

7.12. Do a detailed design for numeric operators for the inference network query
language in Galago.

7.13. Write an interface program that will take a user’s query as text and trans-
form it into an inference network query. Make sure you use proximity operators.
Compare the performance of the simple queries and the transformed queries.



8
Evaluating Search Engines

“Evaluation, Mr. Spock.”

Captain Kirk, Star Trek:TheMotion Picture

8.1 Why Evaluate?

Evaluation is the key to making progress in building better search engines. It is
also essential to understanding whether a search engine is being used effectively
in a specific application. Engineers don’t make decisions about a new design for a
commercial aircraft based on whether it feels better than another design. Instead,
they test the performance of the design with simulations and experiments, eval-
uate everything again when a prototype is built, and then continue to monitor
and tune the performance of the aircraft after it goes into service. Experience has
shownus that ideas thatwe intuitively feelmust improve search quality, ormodels
that have appealing formal properties often have little or no impact when tested
using quantitative experiments.

One of the primary distinctions made in the evaluation of search engines is
between effectiveness and efficiency. Effectiveness, loosely speaking, measures the
ability of the search engine to find the right information, and efficiency measures
how quickly this is done. For a given query, and a specific definition of relevance,
we can more precisely define effectiveness as a measure of how well the ranking
produced by the search engine corresponds to a ranking based on user relevance
judgments. Efficiency is defined in terms of the time and space requirements for
the algorithm that produces the ranking. Viewedmore generally, however, search
is an interactive process involving different types of users with different informa-
tion problems. In this environment, effectiveness and efficiency will be affected
by many factors, such as the interface used to display search results and query re-
finement techniques, such as query suggestion and relevance feedback. Carrying
out this type of holistic evaluation of effectiveness and efficiency, while impor-



298 8 Evaluating Search Engines

tant, is very difficult because of the many factors that must be controlled. For this
reason, evaluation is more typically done in tightly defined experimental settings,
and this is the type of evaluation we focus on here.

Effectiveness and efficiency are related in that techniques that give a small
boost to effectiveness may not be included in a search engine implementation
if they have a significant adverse effect on an efficiency measure such as query
throughput. Generally speaking, however, information retrieval research focuses
on improving the effectiveness of search, and when a technique has been estab-
lished as being potentially useful, the focus shifts to finding efficient implemen-
tations. This is not to say that research on system architecture and efficiency is
not important. The techniques described in Chapter 5 are a critical part of build-
ing a scalable and usable search engine and were primarily developed by research
groups. The focus on effectiveness is based on the underlying goal of a search en-
gine, which is to find the relevant information. A search engine that is extremely
fast is of no use unless it produces good results.

So is there a trade-off between efficiency and effectiveness? Some search en-
gine designers discuss having “knobs,” or parameters, on their system that can be
turned to favor either high-quality results or improved efficiency.The current sit-
uation, however, is that there is no reliable technique that significantly improves
effectiveness that cannot be incorporated into a search engine due to efficiency
considerations. This may change in the future.

In addition to efficiency and effectiveness, the other significant consideration
in search engine design is cost. We may know how to implement a particular
search technique efficiently, but to do so may require a huge investment in pro-
cessors, memory, disk space, and networking. In general, if we pick targets for any
two of these three factors, the third will be determined. For example, if we want a
particular level of effectiveness and efficiency, this will determine the cost of the
system configuration. Alternatively, if we decide on efficiency and cost targets, it
may have an impact on effectiveness. Two extreme cases of choices for these fac-
tors are searching using a pattern-matching utility such as grep, or searching using
an organization such as the Library of Congress. Searching a large text collection
using grepwill have poor effectiveness and poor efficiency, but will be very cheap.
Searching using the staff analysts at the Library of Congress will produce excel-
lent results (high effectiveness) due to themanual effort involved, will be efficient
in terms of the user’s time (although it will involve a delay waiting for a response
from the analysts), andwill be very expensive. Searching directly using an effective
search engine is designed to be a reasonable compromise between these extremes.



8.2 The Evaluation Corpus 299

An important point about terminology is the meaning of “optimization” as
it is discussed in the context of evaluation. The retrieval and indexing techniques
in a search engine have many parameters that can be adjusted to optimize perfor-
mance, both in terms of effectiveness and efficiency. Typically the best values for
these parameters are determined using training data and a cost function. Training
data is a sample of the real data, and the cost function is the quantity based on
the data that is being maximized (or minimized). For example, the training data
could be samples of queries with relevance judgments, and the cost function for a
ranking algorithm would be a particular effectiveness measure. The optimization
process would use the training data to learn parameter settings for the ranking
algorithm that maximized the effectiveness measure. This use of optimization is
very different from “search engine optimization”, which is the process of tailoring
web pages to ensure high rankings from search engines.

In the remainder of this chapter, we will discuss the most important evalu-
ation measures, both for effectiveness and efficiency. We will also describe how
experiments are carried out in controlled environments to ensure that the results
are meaningful.

8.2 The Evaluation Corpus

One of the basic requirements for evaluation is that the results from different
techniques can be compared. To do this comparison fairly and to ensure that ex-
periments are repeatable, the experimental settings and data used must be fixed.
Starting with the earliest large-scale evaluations of search performance in the
1960s, generally referred to as the Cranfield1 experiments (Cleverdon, 1970), re-
searchers assembled test collections consisting of documents, queries, and relevance
judgments to address this requirement. In other language-related research fields,
such as linguistics, machine translation, or speech recognition, a text corpus is a
large amount of text, usually in the form of many documents, that is used for sta-
tistical analysis of various kinds. The test collection, or evaluation corpus, in in-
formation retrieval is unique in that the queries and relevance judgments for a
particular search task are gathered in addition to the documents.

Test collections have changed over the years to reflect the changes in data and
user communities for typical search applications. As an example of these changes,

1 Named after the place in the United Kingdom where the experiments were done.



300 8 Evaluating Search Engines

the following three test collections were created at intervals of about 10 years,
starting in the 1980s:

• CACM: Titles and abstracts from the Communications of the ACM from
1958–1979. Queries and relevance judgments generated by computer scien-
tists.

• AP: Associated Press newswire documents from 1988–1990 (from TREC
disks 1–3). Queries are the title fields from TREC topics 51–150. Topics and
relevance judgments generated by government information analysts.

• GOV2: Web pages crawled from websites in the .gov domain during early
2004. Queries are the title fields from TREC topics 701–850. Topics and rel-
evance judgments generated by government analysts.

TheCACMcollectionwas createdwhenmost search applications focusedon bib-
liographic records containing titles and abstracts, rather than the full text of doc-
uments. Table 8.1 shows that the number of documents in the collection (3,204)
and the average number of words per document (64) are both quite small. The
total size of the document collection is only 2.2 megabytes, which is considerably
less than the size of a single typical music file for an MP3 player. The queries for
this collection of abstracts of computer science papers were generated by students
and faculty of a computer science department, and are supposed to represent ac-
tual information needs. An example of a CACM query is:

Security considerations in local networks, network operating systems, and dis-
tributed systems.

Relevance judgments for each query were done by the same people, and were rel-
atively exhaustive in the sense that most relevant documents were identified. This
was possible since the collection is small and the people who generated the ques-
tions were very familiar with the documents. Table 8.2 shows that the CACM
queries are quite long (13 words on average) and that there are an average of 16
relevant documents per query.

The AP and GOV2 collections were created as part of the TREC conference
series sponsored by the National Institute of Standards and Technology (NIST).
The AP collection is typical of the full-text collections that were first used in the
early 1990s. The availability of cheap magnetic disk technology and online text
entry led to a number of search applications for full-text documents such as news



8.2 The Evaluation Corpus 301

Collection Number of Size Average number
documents of words/doc.

CACM 3,204 2.2 MB 64
AP 242,918 0.7 GB 474

GOV2 25,205,179 426 GB 1073

Table 8.1. Statistics for three example text collections. The average number of words per
document is calculated without stemming.

stories, legal documents, and encyclopedia articles.TheAPcollection ismuchbig-
ger (by twoorders ofmagnitude) than theCACMcollection, both in terms of the
number of documents and the total size. The average document is also consider-
ably longer (474 versus 64 words) since they contain the full text of a news story.
The GOV2 collection, which is another two orders of magnitude larger, was de-
signed to be a testbed for web search applications and was created by a crawl of
the .gov domain.Many of these government web pages contain lengthy policy de-
scriptions or tables, and consequently the average document length is the largest
of the three collections.

Collection Number of Average number of Average number of
queries words/query relevant docs/query

CACM 64 13.0 16
AP 100 4.3 220

GOV2 150 3.1 180

Table 8.2. Statistics for queries from example text collections

Thequeries for the AP andGOV2 collections are based onTREC topics.The
topics were created by government information analysts employed by NIST. The
early TREC topics were designed to reflect the needs of professional analysts in
government and industry and were quite complex. Later TREC topics were sup-
posed to represent more general information needs, but they retained the TREC
topic format.Anexample is shown inFigure 8.1.TRECtopics contain threefields
indicated by the tags. The title field is supposed to be a short query, more typical
of a web application. The description field is a longer version of the query, which
as this example shows, can sometimes be more precise than the short query. The
narrative field describes the criteria for relevance, which is used by the people do-



302 8 Evaluating Search Engines

ing relevance judgments to increase consistency, and should not be considered as
a query. Most recent TREC evaluations have focused on using the title field of
the topic as the query, and our statistics in Table 8.2 are based on that field.

<top> 

<num> Number: 794 

 

<title> pet therapy 

 

<desc> Description: 

How are pets or animals used in therapy for humans and what are the 

benefits? 

 

<narr> Narrative: 

Relevant documents must include details of how pet! or animal!assisted 

therapy is or has been used.  Relevant details include information 

about pet therapy programs, descriptions of the circumstances in which 

pet therapy is used, the benefits of this type of therapy, the degree 

of success of this therapy, and any laws or regulations governing it. 

 

</top> 

 

Fig. 8.1. Example of a TREC topic

The relevance judgments in TREC depend on the task that is being evalu-
ated. For the queries in these tables, the task emphasized high recall, where it is
important not to miss information. Given the context of that task, TREC an-
alysts judged a document as relevant if it contained information that could be
used to help write a report on the query topic. In Chapter 7, we discussed the
difference between user relevance and topical relevance. Although the TREC rel-
evance definition does refer to the usefulness of the information found, analysts
are instructed to judge all documents containing the same useful information as
relevant. This is not something a real user is likely to do, and shows that TREC
is primarily focused on topical relevance. Relevance judgments for the CACM
collections are binary, meaning that a document is either relevant or it is not.
This is also true of most of the TREC collections. For some tasks, multiple lev-
els of relevance may be appropriate. Some TREC collections, including GOV2,
were judged using three levels of relevance (not relevant, relevant, and highly rel-
evant). We discuss effectiveness measures for both binary and graded relevance



8.2 The Evaluation Corpus 303

in section 8.4. Different retrieval tasks can affect the number of relevance judg-
ments required, as well as the type of judgments and the effectiveness measure.
For example, in Chapter 7 we described navigational searches, where the user is
looking for a particular page. In this case, there is only one relevant document for
the query.

Creating a new test collection can be a time-consuming task. Relevance judg-
ments in particular require a considerable investment of manual effort for the
high-recall search task.When collections were very small, most of the documents
in a collection could be evaluated for relevance. In a collection such as GOV2,
however, this would clearly be impossible. Instead, a technique called pooling is
used. In this technique, the top k results (for TREC, k varied between 50 and
200) from the rankings obtained by different search engines (or retrieval algo-
rithms) are merged into a pool, duplicates are removed, and the documents are
presented in some random order to the people doing the relevance judgments.
Pooling produces a large number of relevance judgments for each query, as shown
in Table 8.2. However, this list is incomplete and, for a new retrieval algorithm
that had not contributed documents to the original pool, this could potentially be
a problem. Specifically, if a new algorithm found many relevant documents that
were not part of the pool, they would be treated as being not relevant, and conse-
quently the effectiveness of that algorithm could be significantly underestimated.
Studies with the TREC data, however, have shown that the relevance judgments
are complete enough to produce accurate comparisons for new search techniques.

TREC corpora have been extremely useful for evaluating new search tech-
niques, but they have limitations. A high-recall search task and collections of
news articles are clearly not appropriate for evaluating product search on an e-
commerce site, for example. New TREC “tracks” can be created to address im-
portant new applications, but this process can takemonths or years. On the other
hand, new search applications and new data types such as blogs, forums, and an-
notated videos are constantly being developed. Fortunately, it is not that difficult
to develop an evaluation corpus for any given application using the following ba-
sic guidelines:

• Use a document collection that is representative for the application in terms of
the number, size, and type of documents. In some cases, this may be the actual
collection for the application; in others it will be a sample of the actual collec-
tion, or even a similar collection. If the target application is very general, then
more than one collection should be used to ensure that results are not corpus-



304 8 Evaluating Search Engines

specific. For example, in the case of the high-recall TREC task, a number of
different news and government collections were used for evaluation.

• Thequeries that are used for the test collection should also be representative of
the queries submitted by users of the target application.Thesemay be acquired
either from a query log from a similar application or by asking potential users
for examples of queries. Although it may be possible to gather tens of thou-
sands of queries in some applications, the need for relevance judgments is a
major constraint. The number of queries must be sufficient to establish that
a new technique makes a significant difference. An analysis of TREC experi-
ments has shown thatwith 25 queries, a difference in the effectivenessmeasure
MAP (section 8.4.2) of 0.05 will result in the wrong conclusion about which
system is better in about 13% of the comparisons. With 50 queries, this error
rate falls below 4%. A difference of 0.05 in MAP is quite large. If a significance
test, such as those discussed in section 8.6.1, is used in the evaluation, a relative
difference of 10% in MAP is sufficient to guarantee a low error rate with 50
queries. If resources or the application make more relevance judgments possi-
ble, in terms of generating reliable results it will be more productive to judge
more queries rather than to judge more documents from existing queries (i.e.,
increasing k). Strategies such as judging a small number (e.g., 10) of the top-
ranked documents from many queries or selecting documents to judge that
will make themost difference in the comparison (Carterette et al., 2006) have
been shown to be effective. If a small number of queries are used, the results
should be considered indicative, not conclusive. In that case, it is important
that the queries should be at least representative and have good coverage in
terms of the goals of the application. For example, if algorithms for local search
were being tested, the queries in the test collection should include many dif-
ferent types of location information.

• Relevance judgments should be done either by the people who asked the ques-
tions or by independent judges who have been instructed in how to determine
relevance for the application being evaluated. Relevancemay seem to be a very
subjective concept, and it is known that relevance judgments can vary depend-
ing on the person making the judgments, or even vary for the same person
at different times. Despite this variation, analysis of TREC experiments has
shown that conclusions about the relative performance of systems are very
stable. In other words, differences in relevance judgments do not have a sig-
nificant effect on the error rate for comparisons. The number of documents
that are evaluated for each query and the type of relevance judgments will de-



8.3 Logging 305

pend on the effectiveness measures that are chosen. For most applications, it
is generally easier for people to decide between at least three levels of rele-
vance: definitely relevant, definitely not relevant, and possibly relevant. These
can be converted into binary judgments by assigning the “possibly relevant”
level to either one of the other levels, if that is required for an effectiveness
measure. Some applications and effectivenessmeasures, however, may support
more than three levels of relevance.

As a final point, it is worth emphasizing that many user actions can be consid-
ered implicit relevance judgments, and that if these can be exploited, this can sub-
stantially reduce the effort of constructing a test collection. For example, actions
such as clicking on a document in a result list, moving it to a folder, or sending it
to a printermay indicate that it is relevant. In previous chapters, we have described
how query logs and clickthrough can be used to support operations such as query
expansion and spelling correction. In the next section, we discuss the role of query
logs in search engine evaluation.

8.3 Logging

Query logs that capture user interactions with a search engine have become an
extremely important resource for web search engine development. From an eval-
uation perspective, these logs provide large amounts of data showing how users
browse the results that a search engine provides for a query. In a generalweb search
application, the number of users and queries represented can number in the tens
of millions. Compared to the hundreds of queries used in typical TREC collec-
tions, query log data can potentially support a much more extensive and realistic
evaluation. The main drawback with this data is that it is not as precise as explicit
relevance judgments.

An additional concern is maintaining the privacy of the users. This is par-
ticularly an issue when query logs are shared, distributed for research, or used
to construct user profiles (see section 6.2.5). Various techniques can be used to
anonymize the logged data, such as removing identifying information or queries
that may contain personal data, although this can reduce the utility of the log for
some purposes.

A typical query log will contain the following data for each query:

• User identifier or user session identifier. This can be obtained in a number of
ways. If a user logs onto a service, uses a search toolbar, or even allows cookies,



306 8 Evaluating Search Engines

this information allows the search engine to identify the user. A session is a
series of queries submitted to a search engine over a limited amount of time.
In some circumstances, it may be possible to identify a user only in the context
of a session.

• Query terms. The query is stored exactly as the user entered it.
• List of URLs of results, their ranks on the result list, and whether they were

clicked on.2

• Timestamp(s). The timestamp records the time that the query was submit-
ted. Additional timestampsmay also record the times that specific results were
clicked on.

The clickthrough data in the log (the third item) has been shown to be highly
correlated with explicit judgments of relevance when interpreted appropriately,
and has been used for both training and evaluating search engines. More detailed
information about user interaction can be obtained through a client-side applica-
tion, such as a search toolbar in a web browser. Although this information is not
always available, some user actions other than clickthroughs have been shown to
be goodpredictors of relevance.Twoof the best predictors are pagedwell time and
search exit action. The page dwell time is the amount of time the user spends on
a clicked result, measured from the initial click to the time when the user comes
back to the results page or exits the search application. The search exit action is
the way the user exits the search application, such as entering another URL, clos-
ing the browser window, or timing out. Other actions, such as printing a page, are
very predictive but much less frequent.

Although clicks on result pages are highly correlated with relevance, they can-
not be used directly in place of explicit relevance judgments, because they are very
biased toward pages that are highly ranked or have other features such as being
popular or having a good snippet on the result page. This means, for example,
that pages at the top rank are clicked onmuchmore frequently than lower-ranked
pages, even when the relevant pages are at the lower ranks. One approach to re-
moving this bias is to use clickthrough data to predict user preferences between
pairs of documents rather than relevance judgments. User preferences were first
mentioned in section 7.6, where they were used to train a ranking function. A
preference for document d1 compared to document d2 means that d1 is more rel-

2 In some logs, only the clicked-on URLs are recorded. Logging all the results enables
the generation of preferences and provides a source of “negative” examples for various
tasks.



8.3 Logging 307

evant or, equivalently, that it should be ranked higher. Preferences are most ap-
propriate for search tasks where documents can have multiple levels of relevance,
and are focused more on user relevance than purely topical relevance. Relevance
judgments (either multi-level or binary) can be used to generate preferences, but
preferences do not imply specific relevance levels.

The bias in clickthrough data is addressed by “strategies,” or policies that gen-
erate preferences. These strategies are based on observations of user behavior and
verified by experiments. One strategy that is similar to that described in section
7.6 is known as Skip Above and Skip Next (Agichtein, Brill, Dumais, & Ragno,
2006). This strategy assumes that given a set of results for a query and a clicked
result at rank position p, all unclicked results ranked above p are predicted to be
less relevant than the result at p. In addition, unclicked results immediately fol-
lowing a clicked result are less relevant than the clicked result. For example, given
a result list of ranked documents together with click data as follows:

d1
d2
d3 (clicked)
d4,

this strategy will generate the following preferences:

d3 > d2
d3 > d1
d3 > d4

Since preferences are generated only when higher-ranked documents are ignored,
a major source of bias is removed.

The “Skip” strategy uses the clickthrough patterns of individual users to gener-
ate preferences. This data can be noisy and inconsistent because of the variability
in users’ behavior. Since query logs typically contain many instances of the same
query submitted by different users, clickthroughdata can be aggregated to remove
potential noise from individual differences. Specifically, click distribution infor-
mation can be used to identify clicks that have a higher frequency than would be
expected based on typical click patterns. These clicks have been shown to corre-
late well with relevance judgments. For a given query, we can use all the instances
of that query in the log to compute the observed click frequencyO(d, p) for the
result d in rank position p. We can also compute the expected click frequency
E(p) at rank p by averaging across all queries. The click deviationCD(d, p) for a
result d in position p is computed as:



308 8 Evaluating Search Engines

CD(d, p) = O(d, p)? E(p).

We can then use the value ofCD(d, p) to “filter” clicks and providemore reliable
click information to the Skip strategy.

A typical evaluation scenario involves the comparison of the result lists for two
or more systems for a given set of queries. Preferences are an alternate method of
specifyingwhichdocuments shouldbe retrieved for a givenquery (relevance judg-
ments being the typical method). The quality of the result lists for each system is
then summarized using an effectiveness measure that is based on either prefer-
ences or relevance judgments. The following section describes the measures that
are most commonly used in research and system development.

8.4 Effectiveness Metrics

8.4.1 Recall and Precision

The two most common effectiveness measures, recall and precision, were intro-
duced in the Cranfield studies to summarize and compare search results. Intu-
itively, recall measures how well the search engine is doing at finding all the rele-
vant documents for a query, and precision measures how well it is doing at reject-
ing non-relevant documents.

The definition of these measures assumes that, for a given query, there is a set
of documents that is retrieved and a set that is not retrieved (the rest of the doc-
uments). This obviously applies to the results of a Boolean search, but the same
definition can also be usedwith a ranked search, as wewill see later. If, in addition,
relevance is assumed to be binary, then the results for a query can be summarized
as shown in Table 8.3. In this table, A is the relevant set of documents for the
query,A is the non-relevant set,B is the set of retrieved documents, andB is the
set of documents that are not retrieved. The operator ? gives the intersection of
two sets. For example, A ? B is the set of documents that are both relevant and
retrieved.

A number of effectiveness measures can be defined using this table. The two
we are particularly interested in are:

Recall =
|A ?B|
|A|

Precision =
|A ?B|
|B|



8.4 Effectiveness Metrics 309

Relevant Non-Relevant
Retrieved A ?B A ?B

Not Retrieved A ?B A ?B

Table 8.3. Sets of documents defined by a simple search with binary relevance

where |.| gives the size of the set. In other words, recall is the proportion of rel-
evant documents that are retrieved, and precision is the proportion of retrieved
documents that are relevant. There is an implicit assumption in using these mea-
sures that the task involves retrieving as many of the relevant documents as pos-
sible and minimizing the number of non-relevant documents retrieved. In other
words, even if there are 500 relevant documents for a query, the user is interested
in finding them all.

We can also view the search results summarized in Table 8.3 as the output of a
binary classifier, aswasmentioned in section 7.2.1.When a document is retrieved,
it is the same asmaking a prediction that the document is relevant. From this per-
spective, there are two types of errors that can bemade in prediction (or retrieval).
These errors are called false positives (a non-relevant document is retrieved) and
false negatives (a relevant document is not retrieved). Recall is related to one type
of error (the false negatives), but precision is not related directly to the other type
of error. Instead, another measure known as fallout,3 which is the proportion of
non-relevant documents that are retrieved, is related to the false positive errors:

Fallout =
|A ?B|
|A|

3 In the classification and signal detection literature, the errors are known as Type I and
Type II errors. Recall is often called the true positive rate, or sensitivity. Fallout is called
the false positive rate, or the false alarm rate. Anothermeasure, specificity, is 1 – fallout.
Precision is known as the positive predictive value, and is often used in medical diag-
nostic testswhere the probability that a positive test is correct is particularly important.
The true positive rate and the false positive rate are used to draw ROC (receiver op-
erating characteristic) curves that show the trade-off between these two quantities as
the discrimination threshold varies. This threshold is the value at which the classifier
makes a positive prediction. In the case of search, the threshold would correspond to a
position in the document ranking. In information retrieval, recall-precision graphs are
generally used instead of ROC curves.



310 8 Evaluating Search Engines

Given that fallout and recall together characterize the effectiveness of a search
as a classifier, why dowe use precision instead?The answer is simply that precision
is more meaningful to the user of a search engine. If 20 documents were retrieved
for a query, a precision value of 0.7 means that 14 out of the 20 retrieved doc-
uments would be relevant. Fallout, on the other hand, will always be very small
because there are so many non-relevant documents. If there were 1,000,000 non-
relevant documents for the query used in the precision example, fallout would be
6/1000000 = 0.000006. If precision fell to 0.5, which would be noticeable to the
user, fallout would be 0.00001. The skewed nature of the search task, where most
of the corpus is not relevant to any given query, alsomeans that evaluating a search
engine as a classifier can lead to counterintuitive results. A search engine trained
to minimize classification errors would tend to retrieve nothing, since classifying
a document as non-relevant is always a good decision!

The F measure is an effectiveness measure based on recall and precision that
is used for evaluating classification performance and also in some search applica-
tions. It has the advantage of summarizing effectiveness in a single number. It is
defined as the harmonic mean of recall and precision, which is:

F =
1

1
2
( 1
R
+ 1

P
)
=

2RP

(R + P )

Why use the harmonic mean instead of the usual arithmetic mean or average?
Theharmonicmean emphasizes the importance of small values, whereas the arith-
metic mean is affected more by values that are unusually large (outliers). A search
result that returned nearly the entire document collection, for example, would
have a recall of 1.0 and a precision near 0. The arithmetic mean of these values
is 0.5, but the harmonic mean will be close to 0. The harmonic mean is clearly a
better summary of the effectiveness of this retrieved set.4

Most of the retrieval models we have discussed produce ranked output. To use
recall and precision measures, retrieved sets of documents must be defined based
on the ranking. One possibility is to calculate recall and precision values at every
4 The more general form of theF measure is theweighted harmonic mean, which allows
weights reflecting the relative importance of recall and precision to be used. This mea-
sure is F = RP/(?R + (1 ? ?)P ), where ? is a weight. This is often transformed
using? = 1/(?2+1), which givesF? = (?2+1)RP/(R+?2P ).The commonF
measure is in fact F1, where recall and precision have equal importance. In some eval-
uations, precision or recall is emphasized by varying the value of ?. Values of ? > 1
emphasize recall.



8.4 Effectiveness Metrics 311

rank position. Figure 8.2 shows the top ten documents of two possible rankings,
together with the recall and precision values calculated at every rank position for
a query that has six relevant documents. These rankings might correspond to, for
example, the output of different retrieval algorithms or search engines.

At rank position 10 (i.e., when ten documents are retrieved), the two rankings
have the same effectiveness as measured by recall and precision. Recall is 1.0 be-
cause all the relevant documents have been retrieved, and precision is 0.6 because
both rankings contain six relevant documents in the retrieved set of ten docu-
ments. At higher rank positions, however, the first ranking is clearly better. For
example, at rank position 4 (four documents retrieved), the first ranking has a re-
call of 0.5 (three out of six relevant documents retrieved) and a precision of 0.75
(three out of four retrieved documents are relevant). The second ranking has a
recall of 0.17 (1/6) and a precision of 0.25 (1/4).

Recall    0.17  0.17   0.33   0.5   0.67  0.83  0.83  0.83  0.83   1.0

Precision     1.0  0.5    0.67  0.75   0.8   0.83  0.71  0.63  0.56   0.6

Recall    0.0   0.17   0.17  0.17  0.33   0.5   0.67   0.67  0.83   1.0

Precision     0.0    0.5    0.33  0.25  0.4    0.5   0.57    0.5    0.56   0.6

= the relevant documents

Ranking #1

Ranking #2

Fig. 8.2. Recall and precision values for two rankings of six relevant documents

If there are a large number of relevant documents for a query, or if the relevant
documents are widely distributed in the ranking, a list of recall-precision values
for every rank positionwill be long and unwieldy. Instead, a number of techniques
have been developed to summarize the effectiveness of a ranking.Thefirst of these
is simply to calculate recall-precision values at a small number of predefined rank
positions. In fact, to compare two or more rankings for a given query, only the



312 8 Evaluating Search Engines

precision at the predefined rank positions needs to be calculated. If the precision
for a ranking at rank position p is higher than the precision for another ranking,
the recall will be higher as well. This can be seen by comparing the corresponding
recall-precision values in Figure 8.2. This effectiveness measure is known as pre-
cision at rank p. There are many possible values for the rank position p, but this
measure is typically used to compare search output at the top of the ranking, since
that is what many users care about. Consequently, the most common versions are
precision at 10 and precision at 20. Note that if these measures are used, the im-
plicit search task has changed to finding the most relevant documents at a given
rank, rather than finding as many relevant documents as possible. Differences in
search output further down the ranking than position 20 will not be considered.
This measure also does not distinguish between differences in the rankings at po-
sitions 1 to p, which may be considered important for some tasks. For example,
the two rankings in Figure 8.2 will be the same when measured using precision at
10.

Another method of summarizing the effectiveness of a ranking is to calculate
precision at fixed or standard recall levels from 0.0 to 1.0 in increments of 0.1.
Each ranking is then represented using 11 numbers. This method has the advan-
tage of summarizing the effectiveness of the ranking of all relevant documents,
rather than just those in the top ranks. Using the recall-precision values in Figure
8.2 as an example, however, it is clear that values of precision at these standard re-
call levels are often not available. In this example, only the precision values at the
standard recall levels of 0.5 and 1.0 have been calculated. To obtain the precision
values at all of the standard recall levels will require interpolation.5 Since standard
recall levels are used as the basis for averaging effectiveness across queries and gen-
erating recall-precision graphs, we will discuss interpolation in the next section.

The third method, and the most popular, is to summarize the ranking by av-
eraging the precision values from the rank positions where a relevant document
was retrieved (i.e., when recall increases). If a relevant document is not retrieved
for some reason,6 the contribution of this document to the average is 0.0. For the
first ranking in Figure 8.2, the average precision is calculated as:

(1.0 + 0.67 + 0.75 + 0.8 + 0.83 + 0.6)/6 = 0.78

5 Interpolation refers to any technique for calculating a new point between two existing
data points.

6 One common reason is that only a limited number of the top-ranked documents (e.g.,
1,000) are considered.



8.4 Effectiveness Metrics 313

For the second ranking, it is:

(0.5 + 0.4 + 0.5 + 0.57 + 0.56 + 0.6)/6 = 0.52

Average precision has a number of advantages. It is a single number that is based
on the ranking of all the relevant documents, but the value depends heavily on the
highly ranked relevant documents. This means it is an appropriate measure for
evaluating the task of finding as many relevant documents as possible while still
reflecting the intuition that the top-ranked documents are the most important.

All three of thesemethods summarize the effectiveness of a ranking for a single
query.Toprovide a realistic assessment of the effectiveness of a retrieval algorithm,
it must be tested on a number of queries. Given the potentially large set of results
from these queries, we will need a method of summarizing the performance of
the retrieval algorithm by calculating the average effectiveness for the entire set of
queries. In the next section, we discuss the averaging techniques that are used in
most evaluations.

8.4.2 Averaging and Interpolation

In the following discussion of averaging techniques, the two rankings shown in
Figure 8.3 are used as a running example. These rankings come from using the
same ranking algorithm on two different queries. The aim of an averaging tech-
nique is to summarize the effectiveness of a specific ranking algorithm across a
collection of queries. Different queries will often have different numbers of rel-
evant documents, as is the case in this example. Figure 8.3 also gives the recall-
precision values calculated for the top 10 rank positions.

Given that the average precision provides a number for each ranking, the sim-
plest way to summarize the effectiveness of rankings frommultiple queries would
be to average these numbers. This effectiveness measure,mean average precision,7
or MAP, is used in most research papers and some system evaluations.8 Since
7 This sounds a lot better than average average precision!
8 In some evaluations the geometric mean of the average precision (GMAP) is used in-
stead of the arithmetic mean.This measure, because it multiplies average precision val-
ues, emphasizes the impact of queries with low performance. It is defined as

GMAP = exp 1
n

n?
i=1

logAPi

where n is the number of queries, andAPi is the average precision for query i.



314 8 Evaluating Search Engines

Recall   0.2    0.2   0.4    0.4    0.4    0.6    0.6    0.6    0.8    1.0

Precision    1.0    0.5    0.67  0.5    0.4    0.5   0.43  0.38  0.44   0.5

Recall   0.0   0.33   0.33  0.33  0.67  0.67  1.0    1.0    1.0    1.0

Precision    0.0    0.5    0.33 0.25  0.4   0.33   0.43  0.38  0.33  0.3

= relevant documents for query 1

Ranking #1

Ranking #2

= relevant documents for query 2

Fig. 8.3. Recall and precision values for rankings from two different queries

it is based on average precision, it assumes that the user is interested in finding
many relevant documents for each query. Consequently, using this measure for
comparison of retrieval algorithms or systems can require a considerable effort to
acquire the relevance judgments, although methods for reducing the number of
judgments required have been suggested (e.g., Carterette et al., 2006).

For the example in Figure 8.3, the mean average precision is calculated as fol-
lows:

average precision query 1= (1.0 + 0.67 + 0.5 + 0.44 + 0.5)/5 = 0.62
average precision query 2= (0.5 + 0.4 + 0.43)/3 = 0.44
mean average precision= (0.62 + 0.44)/2 = 0.53
The MAP measure provides a very succinct summary of the effectiveness of

a ranking algorithm over many queries. Although this is often useful, sometimes
too much information is lost in this process. Recall-precision graphs, and the ta-
bles of recall-precision values they are based on, give more detail on the effective-
ness of the ranking algorithm at different recall levels. Figure 8.4 shows the recall-
precision graph for the two queries in the example from Figure 8.3. Graphs for
individual queries have very different shapes and are difficult to compare. To gen-



8.4 Effectiveness Metrics 315

0

0.2

0.4

0.6

0.8

1

0 0.2 0.4 0.6 0.8 1

P
re
c
is
io
n

Recall

Fig. 8.4. Recall-precision graphs for two queries

erate a recall-precision graph that summarizes effectiveness over all the queries,
the recall-precision values in Figure 8.3 should be averaged. To simplify the aver-
aging process, the recall-precision values for each query are converted to precision
values at standard recall levels, as mentioned in the last section.The precision val-
ues for all queries at each standard recall level can then be averaged.9

The standard recall levels are 0.0 to 1.0 in increments of 0.1. To obtain pre-
cision values for each query at these recall levels, the recall-precision data points,
such as those in Figure 8.3, must be interpolated.That is, we have to define a func-
tion based on those data points that has a value at each standard recall level.There
are many ways of doing interpolation, but only one method has been used in in-

9 This is called a macroaverage in the literature. A macroaverage computes the measure
of interest for each query and then averages these measures. Amicroaverage combines
all the applicable data points from every query and computes the measure from the
combined data. For example, a microaverage precision at rank 5 would be calculated
as
?n

i=1 ri/5n, where ri is the number of relevant documents retrieved in the top five
documents by query i, and n is the number of queries. Macroaveraging is used in most
retrieval evaluations.



316 8 Evaluating Search Engines

formation retrieval evaluations since the 1970s. In thismethod, we define the pre-
cision P at any standard recall levelR as

P (R) = max{P ? : R? ? R ? (R?, P ?) ? S}

where S is the set of observed (R,P ) points. This interpolation, which defines
the precision at any recall level as the maximum precision observed in any recall-
precisionpoint at ahigher recall level, produces a step function, as shown inFigure
8.5.

0

0.2

0.4

0.6

0.8

1

0 0.2 0.4 0.6 0.8 1

P
re
c
is
io
n

Recall

Fig. 8.5. Interpolated recall-precision graphs for two queries

Because search engines are imperfect and nearly always retrieve some non-
relevant documents, precision tends to decrease with increasing recall (although
this is not always true, as is shown in Figure 8.4). This interpolation method is
consistent with this observation in that it produces a function that is monoton-
ically decreasing. This means that precision values always go down (or stay the
same) with increasing recall. The interpolation also defines a precision value for
the recall level of 0.0, which would not be obvious otherwise! The general intu-
ition behind this interpolation is that the recall-precision values are defined by the



8.4 Effectiveness Metrics 317

sets of documents in the ranking with the best possible precision values. In query
1, for example, there are three sets of documents that would be the best possi-
ble for the user to look at in terms of finding the highest proportion of relevant
documents.

The average precision values at the standard recall levels are calculated by sim-
ply averaging the precision values for each query. Table 8.4 shows the interpolated
precision values for the two example queries, alongwith the average precision val-
ues. The resulting average recall-precision graph is shown in Figure 8.6.

Recall 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Ranking 1 1.0 1.0 1.0 0.67 0.67 0.5 0.5 0.5 0.5 0.5 0.5
Ranking 2 0.5 0.5 0.5 0.5 0.43 0.43 0.43 0.43 0.43 0.43 0.43
Average 0.75 0.75 0.75 0.59 0.55 0.47 0.47 0.47 0.47 0.47 0.47

Table 8.4. Precision values at standard recall levels calculated using interpolation

Fig. 8.6. Average recall-precision graph using standard recall levels



318 8 Evaluating Search Engines

Theaverage recall-precision graph is plotted by simply joining the average pre-
cision points at the standard recall levels, rather than using another step function.
Although this is somewhat inconsistent with the interpolationmethod, the inter-
mediate recall levels are never used in evaluation. When graphs are averaged over
many queries, they tend to become smoother. Figure 8.7 shows a typical recall-
precision graph from a TREC evaluation using 50 queries.

0

0.2

0.4

0.6

0.8

1

0 0.2 0.4 0.6 0.8 1

P
re
c
is
io
n

Recall

Fig. 8.7. Typical recall-precision graph for 50 queries from TREC

8.4.3 Focusing on the Top Documents

In many search applications, users tend to look at only the top part of the ranked
result list to find relevant documents. In the case of web search, this means that
many users look at just the first page or two of results. In addition, tasks such
as navigational search (Chapter 7) or question answering (Chapter 1) have just a
single relevant document. In these situations, recall is not an appropriatemeasure.
Instead, the focus of an effectiveness measure should be on how well the search
engine does at retrieving relevant documents at very high ranks (i.e., close to the
top of the ranking).



8.4 Effectiveness Metrics 319

One measure with this property that has already been mentioned is precision
at rank p, where p in this case will typically be 10.Thismeasure is easy to compute,
can be averaged over queries to produce a single summary number, and is readily
understandable. The major disadvantage is that it does not distinguish between
different rankings of a given number of relevant documents. For example, if only
one relevant document was retrieved in the top 10, according to the precision
measure a ranking where that document is in the top position would be the same
as one where it was at rank 10. Other measures have been proposed that are more
sensitive to the rank position.

The reciprocal rankmeasure has been used for applications where there is typ-
ically a single relevant document. It is defined as the reciprocal of the rank at
which the first relevant document is retrieved. The mean reciprocal rank (MRR)
is the average of the reciprocal ranks over a set of queries. For example, if the top
five documents retrieved for a query were dn, dr, dn, dn, dn, where dn is a non-
relevant document and dr is a relevant document, the reciprocal rank would be
1/2 = 0.5. Even if more relevant documents had been retrieved, as in the rank-
ing dn, dr, dn, dr, dn, the reciprocal rank would still be 0.5. The reciprocal rank
is very sensitive to the rank position. It falls from 1.0 to 0.5 from rank 1 to 2, and
the ranking dn, dn, dn, dn, dr would have a reciprocal rank of 1/5 = 0.2. The
MRR for these two rankings would be (0.5 + 0.2)/2 = 0.35.

The discounted cumulative gain (DCG)has become a popularmeasure for eval-
uating web search and related applications (Järvelin & Kekäläinen, 2002). It is
based on two assumptions:

• Highly relevant documents are more useful than marginally relevant docu-
ments.

• The lower the ranked position of a relevant document (i.e., further down the
ranked list), the less useful it is for the user, since it is less likely to be examined.

These two assumptions lead to an evaluation that uses graded relevance as a
measure of the usefulness, or gain, from examining a document. The gain is accu-
mulated starting at the top of the ranking and may be reduced, or discounted, at
lower ranks.TheDCG is the total gain accumulated at a particular rank p. Specif-
ically, it is defined as:

DCGp = rel1 +

p?
i=2

reli
log2 i



320 8 Evaluating Search Engines

where reli is the graded relevance level of the document retrieved at rank i. For
example, web search evaluations have been reported that used manual relevance
judgments on a six-point scale ranging from “Bad” to “Perfect” (i.e., 0 ? reli ?
5). Binary relevance judgments can alsobeused, inwhich case reli wouldbe either
0 or 1.

The denominator log2 i is the discount or reduction factor that is applied to
the gain.There is no theoretical justification for using this particular discount fac-
tor, although it does provide a relatively smooth (gradual) reduction.10 By varying
the base of the logarithm, the discount can be made sharper or smoother. With
base 2, the discount at rank 4 is 1/2, and at rank 8 it is 1/3. As an example, con-
sider the following ranking where each number is a relevance level on the scale
0–3 (not relevant–highly relevant):

3, 2, 3, 0, 0, 1, 2, 2, 3, 0

These numbers represent the gain at each rank. The discounted gain would be:

3, 2/1, 3/1.59, 0, 0, 1/2.59, 2/2.81, 2/3, 3/3.17, 0 =
3, 2, 1.89, 0, 0, 0.39, 0.71, 0.67, 0.95, 0

The DCG at each rank is formed by accumulating these numbers, giving:

3, 5, 6.89, 6.89, 6.89, 7.28, 7.99, 8.66, 9.61, 9.61

Similar to precision at rank p, specific values of p are chosen for the evaluation,
and the DCG numbers are averaged across a set of queries. Since the focus of this
measure is on the top ranks, these values are typically small, such as 5 and 10. For
this example, DCG at rank 5 is 6.89 and at rank 10 is 9.61. To facilitate averaging
across queries with different numbers of relevant documents, these numbers can
be normalized by comparing the DCG at each rank with the DCG value for the
perfect ranking for that query. For example, if the previous ranking contained all
10 In some publications, DCG is defined as:

DCGp =

p?
i=1

(2reli ? 1)/log(1 + i)

For binary relevance judgments, the two definitions are the same, but for graded rele-
vance this definition puts a strong emphasis on retrieving highly relevant documents.
This version of the measure is used by some search engine companies and, because of
this, may become the standard.



8.4 Effectiveness Metrics 321

the relevant documents for that query, the perfect ranking would have gain values
at each rank of:

3, 3, 3, 2, 2, 2, 1, 0, 0, 0

which would give ideal DCG values of:
3, 6, 7.89, 8.89, 9.75, 10.52, 10.88, 10.88, 10.88, 10.88

Normalizing the actual DCG values by dividing by the ideal values gives us the
normalized discounted cumulative gain (NDCG) values:

1, 0.83, 0.87, 0.76, 0.71, 0.69, 0.73, 0.8, 0.88, 0.88

Note that the NDCG measure is ? 1 at any rank position. To summarize, the
NDCG for a given query can be defined as:

NDCGp =
DCGp
IDCGp

where IDCG is the ideal DCG value for that query.

8.4.4 Using Preferences

In section 8.3, we discussed how user preferences can be inferred from query logs.
Preferences have been used for training ranking algorithms, and have been sug-
gested as an alternative to relevance judgments for evaluation. Currently, how-
ever, there is no standard effectiveness measure based on preferences.

In general, two rankings described using preferences can be compared using
theKendall tau coefficient (? ). IfP is the number of preferences that agree andQ
is the number that disagree, Kendall’s ? is defined as:

? =
P ?Q
P +Q

Thismeasure varies between 1 (when all preferences agree) and –1 (when they all
disagree). If preferences are derived from clickthrough data, however, only a par-
tial ranking is available. Experimental evidence shows that this partial informa-
tion can be used to learn effective ranking algorithms, which suggests that effec-
tiveness can bemeasured this way. Instead of using the complete set of preferences
to calculate P and Q, a new ranking would be evaluated by comparing it to the
known set of preferences. For example, if there were 15 preferences learned from



322 8 Evaluating Search Engines

clickthrough data, and a ranking agreed with 10 of these, the ? measure would be
(10 ? 5)/15 = 0.33. Although this seems reasonable, no studies are available
that show that this effectiveness measure is useful for comparing systems.

For preferences derived from binary relevance judgments, the BPREF11 mea-
sure has been shown to be robust with partial information and to give similar re-
sults (in terms of system comparisons) to recall-precision measures such as MAP.
In this measure, the number of relevant and non-relevant documents is balanced
to facilitate averaging across queries. For a query withR relevant documents, only
the first R non-relevant documents are considered. This is equivalent to using
R×R preferences (all relevant documents are preferred to all non-relevant doc-
uments). Given this, the measure is defined as:

BPREF =
1

R

?
dr

(1? Ndr
R

)

where dr is a relevant document and Ndr gives the number of non-relevant doc-
uments (from the set ofR non-relevant documents that are considered) that are
ranked higher than dr . If this is expressed in terms of preferences,Ndr is actually
a method for counting the number of preferences that disagree (for binary rele-
vance judgments). Since R × R is the number of preferences being considered,
an alternative definition of BPREF is:

BPREF =
P

P +Q

which means it is very similar to Kendall’s ? . The main difference is that BPREF
varies between 0 and 1. Given that BPREF is a useful effectiveness measure, this
suggests that the same measure or ? could be used with preferences associated
with graded relevance.

8.5 Efficiency Metrics

Compared to effectiveness, the efficiency of a search system seems like it should be
easier to quantify.Most ofwhatwe care about canbemeasured automaticallywith
a timer instead of with costly relevance judgments. However, like effectiveness, it
is important to determine exactly what aspects of efficiency we want to measure.
Table 8.5 shows some of the measures that are used.
11 Binary Preference



8.5 Efficiency Metrics 323

Metric name Description
Elapsed indexing time Measures the amount of time necessary to build a docu-

ment index on a particular system.
Indexing processor time Measures theCPU seconds used in building a document

index.This is similar to elapsed time, but does not count
time waiting for I/O or speed gains from parallelism.

Query throughput Number of queries processed per second.
Query latency The amount of time a usermustwait after issuing a query

before receiving a response, measured in milliseconds.
This can be measured using the mean, but is often more
instructive when used with the median or a percentile
bound.

Indexing temporary space Amount of temporary disk space used while creating an
index.

Index size Amount of storage necessary to store the index files.

Table 8.5. Definitions of some important efficiency metrics

The most commonly quoted efficiency metric is query throughput, measured
in queries processed per second. Throughput numbers are comparable only for
the same collection and queries processed on the same hardware, although rough
comparisons can be made between runs on similar hardware. As a single-number
metric of efficiency, throughput is good because it is intuitive and mirrors the
common problems we want to solve with efficiency numbers. A real system user
will want to use throughput numbers for capacity planning, to help determine
whether more hardware is necessary to handle a particular query load. Since it is
simple to measure the number of queries per second currently being issued to a
service, it is easy to determine whether a system’s query throughput is adequate to
handle the needs of an existing service.

The trouble with using throughput alone is that it does not capture latency.
Latency measures the elapsed time the system takes between when the user issues
a query and when the system delivers its response. Psychology research suggests
that users consider any operation that takes less than about 150 milliseconds to
be instantaneous. Above that level, users react very negatively to the delay they
perceive.

This brings us back to throughput, because latency and throughput are not
orthogonal: generally we can improve throughput by increasing latency, and re-



324 8 Evaluating Search Engines

ducing latency leads to poorer throughput. To see why this is so, think of the dif-
ference between having a personal chef and ordering food at a restaurant.The per-
sonal chef prepares your food with the lowest possible latency, since she has no
other demands on her time and focuses completely on preparing your food. Un-
fortunately, the personal chef has low throughput, since her focus on you leads to
idle time when she is not completely occupied. The restaurant is a high through-
put operationwith lots of chefs working onmany different orders simultaneously.
Having many orders and many chefs leads to certain economies of scale—for in-
stance, when a single chef prepares many identical orders at the same time. Note
that the chef is able to process these orders simultaneously precisely because some
latency has been added to some orders: instead of starting to cook immediately
upon receiving an order, the chef may decide to wait a few minutes to see if any-
one else orders the same thing. The result is that the chefs are able to cook food
with high throughput but at some cost in latency.

Query processing works the sameway. It is possible to build a system that han-
dles just one query at a time, devoting all resources to the current query, just like
the personal chef devotes all her time to a single customer. This kind of system is
low throughput, because only one query is processed at a time, which leads to idle
resources.The radical opposite approach is to process queries in large batches.The
system can then reorder the incoming queries so that queries that use common
subexpressions are evaluated at the same time, saving valuable execution time.
However, interactive users will hate waiting for their query batch to complete.

Like recall and precision in effectiveness, low latency and high throughput
are both desirable properties of a retrieval system, but they are in conflict with
each other and cannot be maximized at the same time. In a real system, query
throughput is not a variable but a requirement: the system needs to handle every
query the users submit. The two remaining variables are latency (how long the
users will have to wait for a response) and hardware cost (how many processors
will be applied to the search problem). A common way to talk about latency is
with percentile bounds, such as “99% of all queries will complete in under 100
milliseconds.” System designers can then add hardware until this requirement is
met.

Query throughput and latency are the most visible system efficiency metrics,
butwe should also consider the costs of indexing. For instance, given enough time
and space, it is possible to cache every possible query of a particular length. A
system that did this would have excellent query throughput and query latency,
but at the cost of enormous storage and indexing costs. Therefore, we also need



8.6 Training, Testing, and Statistics 325

to measure the size of the index structures and the time necessary to create them.
Because indexing is often a distributed process, we need to know both the total
amount of processor time used during indexing and the elapsed time. Since the
process of inversion often requires temporary storage, it is interesting to measure
the amount of temporary storage used.

8.6 Training, Testing, and Statistics

8.6.1 Significance Tests

Retrieval experiments generate data, such as average precision values or NDCG
values. In order to decide whether this data shows that there is a meaningful dif-
ference between two retrieval algorithms or search engines, significance tests are
needed. Every significance test is based on a null hypothesis. In the case of a typical
retrieval experiment, we are comparing the value of an effectiveness measure for
rankings produced by two retrieval algorithms. The null hypothesis is that there
is no difference in effectiveness between the two retrieval algorithms. The alter-
native hypothesis is that there is a difference. In fact, given two retrieval algorithms
A andB, whereA is a baseline algorithm andB is a new algorithm, we are usually
trying to show that the effectiveness ofB is better thanA, rather than simply find-
ing a difference. Since the rankings that are compared are based on the same set of
queries for both retrieval algorithms, this is known as amatched pair experiment.

We obviously cannot conclude that B is better than A on the basis of the re-
sults of a single query, sinceAmay be better thanB on all other queries. So how
many queries do we have to look at to make a decision about which is better? If,
for example, B is better than A for 90% of 200 queries in a test collection, we
should be more confident thatB is better for that effectiveness measure, but how
confident? Significance tests allow us to quantify the confidence we have in any
judgment about effectiveness.

More formally, a significance test enables us to reject the null hypothesis in fa-
vor of the alternative hypothesis (i.e., show thatB is better thanA) on the basis of
the data from the retrieval experiments. Otherwise, we say that the null hypoth-
esis cannot be rejected (i.e., B might not be better than A). As with any binary
decision process, a significance test can make two types of error. A Type I error
is when the null hypothesis is rejected when it is in fact true. A Type II error is
when the null hypothesis is accepted when it is in fact false.12 Significance tests
12 Compare to the discussion of errors in section 8.4.1.



326 8 Evaluating Search Engines

are often described by their power, which is the probability that the test will reject
the null hypothesis correctly (i.e., decide thatB is better thanA). In other words,
a test with high power will reduce the chance of a Type II error. The power of a
test can also be increased by increasing the sample size, which in this case is the
number of queries in the experiment. Increasing the number of queries will also
reduce the chance of a Type I error.

The procedure for comparing two retrieval algorithms using a particular set of
queries and a significance test is as follows:

1. Compute the effectiveness measure for every query for both rankings.
2. Compute a test statistic based on a comparison of the effectiveness measures

for each query.The test statistic depends on the significance test, and is simply
a quantity calculated from the sample data that is used to decide whether or
not the null hypothesis should be rejected.

3. The test statistic is used to compute a P-value, which is the probability that a
test statistic value at least that extreme could be observed if the null hypothesis
were true. Small P-values suggest that the null hypothesis may be false.

4. Thenull hypothesis (nodifference) is rejected in favor of the alternate hypoth-
esis (i.e.,B ismore effective thanA) if the P-value is? ?, the significance level.
Values for? are small, typically 0.05 and 0.1, to reduce the chance of a Type I
error.

In other words, if the probability of getting a specific test statistic value is very
small assuming the null hypothesis is true, we reject that hypothesis and conclude
that ranking algorithmB is more effective than the baseline algorithmA.

The computation of the test statistic and the corresponding P-value is usually
done using tables or standard statistical software. The significance tests discussed
here are also provided in Galago.

The procedure just described is known as a one-sided or one-tailed test since
we want to establish that B is better than A. If we were just trying to establish
that there is a difference between B and A, it would be a two-sided or two-tailed
test, and the P-value would be doubled. The “side” or “tail” referred to is the tail
of a probability distribution. For example, Figure 8.8 shows a distribution for the
possible values of a test statistic assuming the null hypothesis. The shaded part of
the distribution is the region of rejection for a one-sided test. If a test yielded the
test statistic value x, the null hypothesis would be rejected since the probability
of getting that value or higher (the P-value) is less than the significance level of
0.05.



8.6 Training, Testing, and Statistics 327

p = 0.05

Test statistic value x

Fig. 8.8.Probability distribution for test statistic values assuming the null hypothesis.The
shaded area is the region of rejection for a one-sided test.

The significance testsmost commonly used in the evaluation of search engines
are the t-test,13 the Wilcoxon signed-rank test, and the sign test. To explain these
tests, we will use the data shown in Table 8.6, which shows the effectiveness val-
ues of the rankings producedby two retrieval algorithms for 10queries.Thevalues
in the table are artificial and could be average precision or NDCG, for example,
on a scale of 0–100 (instead of 0–1).The table also shows the difference in the ef-
fectivenessmeasure between algorithmB and the baseline algorithmA.The small
number of queries in this example data is not typical of a retrieval experiment.

In general, the t-test assumes that data values are sampled from normal dis-
tributions. In the case of a matched pair experiment, the assumption is that the
difference between the effectiveness values is a sample from a normal distribution.
The null hypothesis in this case is that the mean of the distribution of differences
is zero. The test statistic for the paired t-test is:

t =
B ? A
?B?A

.
?
N

where B ? A is the mean of the differences, ?B?A is the standard deviation14
of the differences, and N is the size of the sample (the number of queries). For
13 Also known as Student’s t-test, where “student” was the pen name of the inventor,

William Gosset, not the type of person who should use it.
14 For a set of data values xi, the standard deviation can be calculated by ? =??N

i=1(xi ? x)2/N , where x is the mean.



328 8 Evaluating Search Engines

Query A B B – A
1 25 35 10
2 43 84 41
3 39 15 -24
4 75 75 0
5 43 68 25
6 15 85 70
7 20 80 60
8 52 50 -2
9 49 58 9
10 50 75 25

Table 8.6. Artificial effectiveness data for two retrieval algorithms (A and B) over 10
queries. The column B – A gives the difference in effectiveness.

the data in Table 8.6, B ? A = 21.4, ?B?A = 29.1, and t = 2.33. For a one-
tailed test, this gives a P-value of 0.02, whichwould be significant at a level of? =
0.05.Therefore, for this data, the t-test enables us to reject the null hypothesis and
conclude that ranking algorithm B is more effective than A.

There are two objections that could be made to using the t-test in search eval-
uations. The first is that the assumption that the data is sampled from normal
distributions is generally not appropriate for effectiveness measures, although the
distribution of differences can resemble a normal distribution for largeN . Recent
experimental results have supported the validity of the t-test by showing that it
produces very similar results to the randomization test on TREC data (Smucker
et al., 2007).The randomization test does not assume the data comes fromnormal
distributions, and is themost powerful of the nonparametric tests.15 The random-
ization test, however, is much more expensive to compute than the t-test.

The second objection that could be made is concerned with the level of mea-
surement associated with effectiveness measures. The t-test (and the randomiza-
tion test) assume the the evaluation data is measured on an interval scale. This
means that the values can be ordered (e.g., an effectiveness of 54 is greater than an
effectiveness of 53), and that differences between values are meaningful (e.g., the
difference between 80 and 70 is the same as the difference between 20 and 10).
Some people have argued that effectiveness measures are an ordinal scale, which
15 Anonparametric test makes less assumptions about the data and the underlying distri-

bution than parametric tests.



8.6 Training, Testing, and Statistics 329

means that the magnitude of the differences are not significant. The Wilcoxon
signed-rank test and the sign test, which are both nonparametric, make less as-
sumptions about the effectiveness measure. As a consequence, they do not use all
the information in the data, and it can be more difficult to show a significant dif-
ference. In other words, if the effectiveness measure did satisfy the conditions for
using the t-test, the Wilcoxon and sign tests have less power.

The Wilcoxon signed-rank test assumes that the differences between the ef-
fectiveness values for algorithms A and B can be ranked, but the magnitude is
not important. This means, for example, that the difference for query 8 in Table
8.6 will be ranked first because it is the smallest non-zero absolute value, but the
magnitude of 2 is not used directly in the test. The test statistic is:

w =
N?
i=1

Ri

where Ri is a signed-rank, and N is the number of differences ?= 0. To compute
the signed-ranks, the differences are ordered by their absolute values (increasing),
and then assigned rank values (ties are assigned the average rank).The rank values
are then given the sign of the original difference. The null hypothesis for this test
is that the sum of the positive ranks will be the same as the sum of the negative
ranks.

For example, the nine non-zero differences from Table 8.6, in rank order of
absolute value, are:

2, 9, 10, 24, 25, 25, 41, 60, 70

The corresponding signed-ranks are:

–1, +2, +3, –4, +5.5, +5.5, +7, +8, +9

Summing these signed-ranks gives a value of w = 35. For a one-tailed test, this
gives a P-value of approximately 0.025, which means the null hypothesis can be
rejected at a significance level of ? = 0.05.

The sign test goes further than theWilcoxon signed-ranks test, and completely
ignores the magnitude of the differences. The null hypothesis for this test is that
P (B > A) = P (A > B) = 1

2
. In other words, over a large sample wewould ex-

pect that the number of pairs where B is “better” thanAwould be the same as the
number of pairs where A is “better” than B. The test statistic is simply the num-
ber of pairs where B > A. The issue for a search evaluation is deciding what dif-
ference in the effectiveness measure is “better.” We could assume that even small



330 8 Evaluating Search Engines

differences in average precision or NDCG—such as 0.51 compared to 0.5—are
significant. This has the risk of leading to a decision that algorithm B is more ef-
fective than A when the difference is, in fact, not noticeable to the users. Instead,
an appropriate threshold for the effectiveness measure should be chosen. For ex-
ample, an old rule of thumb in information retrieval is that there has to be at least
5% difference in average precision to be noticeable (10% for a more conserva-
tive threshold). This would mean that a difference of 0.51 ? 0.5 = 0.01 would
be considered a tie for the sign test. If the effectiveness measure was precision at
rank 10, on the other hand, any difference might be considered significant since
it would correspond directly to additional relevant documents in the top 10.

For the data in Table 8.6, we will consider any difference to be significant.This
means there are seven pairs out of tenwhere B is better thanA.The corresponding
P-value is 0.17, which is the chance of observing seven “successes” in ten trials
where the probability of success is 0.5 (just like flipping a coin). Using the sign
test, we cannot reject the null hypothesis. Because so much information from the
effectiveness measure is discarded in the sign test, it is more difficult to show a
difference, and more queries are needed to increase the power of the test. On the
other hand, it can be used in addition to the t-test to provide a more user-focused
perspective. An algorithm that is significantly more effective according to both
the t-test and the sign test, perhaps using different effectiveness measures, is more
likely to be noticeably better.

8.6.2 Setting Parameter Values

Nearly every ranking algorithm has parameters that can be tuned to improve the
effectiveness of the results. For example, BM25 has the parameters k1, k2, and b
used in term weighting, and query likelihood with Dirichlet smoothing has the
parameterµ. Ranking algorithms forweb search can have hundreds of parameters
that give the weights for the associated features. The values of these parameters
can have amajor impact on retrieval effectiveness, and values that give the best ef-
fectiveness for one applicationmay not be appropriate for another application, or
even for a different document collection.Not only is choosing the right parameter
values important for the performance of a search engine when it is deployed, it is
an important part of comparing the effectiveness of two retrieval algorithms. An
algorithm that has had its parameters tuned for optimal performance for the test
collection may appear to be much more effective than it really is when compared
to a baseline algorithm with poor parameter values.



8.6 Training, Testing, and Statistics 331

The appropriate method of setting parameters for both maximizing effective-
ness andmaking fair comparisons of algorithms is to use a training set and a test set
of data. The training set is used to learn the best parameter values, and the test set
is used for validating these parameter values and comparing ranking algorithms.
The training and test sets are two separate test collections of documents, queries,
and relevance judgments, although they may be created by splitting a single col-
lection. InTREC experiments, for example, the training set is usually documents,
queries, and relevance judgments from previous years. When there is not a large
amount of data available, cross-validation canbedonebypartitioning the data into
K subsets. One subset is used for testing, andK ? 1 are used for training. This is
repeated using each of the subsets as a test set, and the best parameter values are
averaged across theK runs.

Using training and test sets helps to avoid the problem of overfitting (men-
tioned in Chapter 7), which occurs when the parameter values are tuned to fit a
particular set of data too well. If this was the only data that needed to be searched
in an application, that would be appropriate, but a much more common situa-
tion is that the training data is only a sample of the data that will be encountered
when the search engine is deployed. Overfitting will result in a choice of parame-
ter values that do not generalize well to this other data. A symptom of overfitting
is that effectiveness on the training set improves but effectiveness on the test set
gets worse.

A fair comparison of two retrieval algorithms would involve getting the best
parameter values for both algorithms using the training set, and then using those
values with the test set.The effectiveness measures are used to tune the parameter
values inmultiple retrieval runs on the training data, and for the final comparison,
which is a single retrieval run, on the test data.The “cardinal sin” of retrieval exper-
iments, which should be avoided in nearly all situations, is testing on the training
data. This typically will artificially boost the measured effectiveness of a retrieval
algorithm. It is particularly problematic when one algorithm has been trained in
some way using the testing data and the other has not. Although it sounds like
an easy problem to avoid, it can sometimes occur in subtle ways in more complex
experiments.

Given a training set of data, there a number of techniques for finding the
best parameter settings for a particular effectiveness measure. The most common
method is simply to explore the space of possible parameter values by brute force.
This requires a large number of retrieval runs with small variations in parameter
values (a parameter sweep). Although this could be computationally infeasible for



332 8 Evaluating Search Engines

large numbers of parameters, it is guaranteed to find the parameter settings that
give the best effectiveness for any given effectiveness measure. The Ranking SVM
method described in section 7.6 is an example of a more sophisticated procedure
for learning good parameter values efficiently with large numbers of parameters.
This method, as well as similar optimization techniques, will find the best possi-
ble parameter values if the function being optimized meets certain conditions.16

Because many of the effectiveness measures we have described do not meet these
conditions, different functions are used for the optimization, and the parame-
ter values are not guaranteed to be optimal. This is, however, a very active area
of research, and new methods for learning parameters are constantly becoming
available.

8.6.3 Online Testing

All of the evaluation strategies described thus far have assumed that training and
testing are done offline. That is, we have assumed that all of the training and test
data are fixed ahead of time. However, with real search engines, it may be possible
to test (or even train) using live traffic. This is often called online testing. For ex-
ample, suppose that you just developed a new sponsored-search advertising algo-
rithm. Rather than evaluating your system using human relevance judgments, it is
possible to deploy the new ranking algorithm and observe the amount of revenue
generated using the new algorithm versus some baseline algorithm. This makes
it possible to test various search engine components, such as ranking algorithms,
query suggestion algorithms, and snippet generation algorithms, using live traffic
and real users. Notice that this is similar to logging, which was discussed earlier
in this chapter. With logging, evaluations are typically done retrospectively on
“stale” data, whereas online testing uses live data.

There are several benefits to online testing. First, it allows real users to inter-
act with the system. These interactions provide information, such as click data,
that can be used for various kinds of evaluation. Second, online testing is less bi-
ased, since the evaluation is being done over a real sample of users and traffic.This

16 Specifically, the function should be convex (or concave; a function f(x) is concave if
and only if?f(x) is convex). A convex function is a continuous function that satisfies
the following constraint for all ? in [0,1]:

f(?x1 + (1? ?)x2) ? ?f(x1) + (1? ?)f(x2)



8.7 The Bottom Line 333

is valuable because it is often difficult to build test collections that accurately re-
flect real search engine users and traffic. Finally, online testing can produce a large
amount of data very cheaply, since it does not require paying any humans to do
relevance judgments.

Unfortunately, online testing also has its fair share of drawbacks. The primary
drawback is that the data collected is typically very noisy.There aremany different
reasons why users behave the way they do in an online environment. For example,
if a user does not click on a search result, it does not necessarily mean the result is
bad. The user may have clicked on an advertisement instead, lost interest, or sim-
ply gone to eat dinner. Therefore, typically a very large amount of online testing
data is required to eliminate noise and producemeaningful conclusions. Another
drawback to online testing is that it requires live traffic to be altered in poten-
tially harmful ways. If the algorithm being tested is highly experimental, then it
may significantly degrade retrieval effectiveness and drive users away. For this rea-
son, online testing must be done very carefully, so as not to negatively affect the
user experience. Oneway ofminimizing the effect of an online test on the general
user population is to use the experimental algorithm only for a small percentage,
such as 1% to 5%, of the live traffic. Finally, online tests typically provide only
a very specific type of data—click data. As we described earlier in this section,
click data is not always ideal for evaluating search engines, since the data is noisy
and highly biased. However, for certain search engine evaluation metrics, such as
clickthrough rate17 and revenue, online testing can be very useful.

Therefore, online testing can be a useful, inexpensive way of training or testing
new algorithms, especially those that can be evaluated using click data. Special
care must be taken to ensure that the data collected is analyzed properly and that
the overall user experience is not degraded.

8.7 The Bottom Line

In this chapter, we have presented a number of effectiveness and efficiency mea-
sures. At this point, it would be reasonable to ask which of them is the right mea-
sure to use. The answer, especially with regard to effectiveness, is that no single
measure is the correct one for any search application. Instead, a search engine
should be evaluated through a combination of measures that show different as-

17 The percentage of times that some item is clicked on.



334 8 Evaluating Search Engines

pects of the system’s performance. In many settings, all of the following measures
and tests could be carried out with little additional effort:

• Mean average precision - single number summary, popular measure, pooled
relevance judgments.

• AverageNDCG - single number summary for each rank level, emphasizes top
ranked documents, relevance judgments needed only to a specific rank depth
(typically to 10).

• Recall-precision graph - conveysmore information than a single numbermea-
sure, pooled relevance judgments.

• Average precision at rank 10 - emphasizes top ranked documents, easy to un-
derstand, relevance judgments limited to top 10.

Using MAP and a recall-precision graph could require more effort in relevance
judgments, but this analysis could also be limited to the relevant documents found
in the top 10 for the NDCG and precision at 10 measures.

All these evaluations should be done relative to one or more baseline searches.
It generally does not make sense to do an effectiveness evaluation without a good
baseline, since the effectiveness numbers depend strongly on the particular mix
of queries and documents in the test collection. The t-test can be used as the sig-
nificance test for the average precision, NDCG, and precision at 10 measures.

All of the standard evaluation measures and significance tests are available us-
ing the evaluation program provided as part of Galago.

In addition to these evaluations, it is also very useful to present a summary of
the number of queries that were improved and the number that were degraded,
relative to a baseline. Figure 8.9 gives an example of this summary for a TREC
run, where the query numbers are shown as a distribution over various percentage
levels of improvement for a specific evaluation measure (usually MAP). Each bar
represents the number of queries that were better (or worse) than the baseline by
the given percentage. This provides a simple visual summary showing that many
more querieswere improved thanwere degraded, and that the improvementswere
sometimes quite substantial. By setting a threshold on the level of improvement
that constitutes “noticeable,” the sign test can be used with this data to establish
significance.

Given this range of measures, both developers and users will get a better pic-
ture ofwhere the search engine is performingwell andwhere itmayneed improve-
ment. It is often necessary to look at individual queries to get a better understand-



8.7 The Bottom Line 335

15

20

25

Q i

0

5

10

< !100%[!100%,

!75%]

[!75%,

!50%]

[!50%,

!25%]

[!25%,

0%]

[0%,

25%]

[25%,

50%]

[50%,

75%]

[75%,

100%]

> 100%

Queries

Percentage Gain or Loss

Fig. 8.9. Example distribution of query effectiveness improvements

ing of what is causing the ranking behavior of a particular algorithm. Query data
such as Figure 8.9 can be helpful in identifying interesting queries.

References and Further Reading

Despite being discussed for more than 40 years, the measurement of effectiveness
in search engines is still a hot topic, with many papers being published in the ma-
jor conferences every year. The chapter on evaluation in van Rijsbergen (1979)
gives a good historical perspective on effectiveness measurement in information
retrieval. Another useful general source is the TRECbook (Voorhees&Harman,
2005), which describes the test collections and evaluation procedures used and
how they evolved.

Saracevic (1975) and Mizzaro (1997) are the best papers for general reviews
of the critical topic of relevance. The process of obtaining relevance judgments
and the reliability of retrieval experiments are discussed in the TREC book.
Zobel (1998) shows that some incompleteness of relevance judgments does not
affect experiments, although Buckley and Voorhees (2004) suggest that substan-
tial incompleteness can be a problem. Voorhees and Buckley (2002) discuss the



336 8 Evaluating Search Engines

error rates associated with different numbers of queries. Sanderson and Zobel
(2005) show how using a significance test can affect the reliability of compar-
isons and also compare shallow versus in-depth relevance judgments. Carterette
et al. (2006) describe a technique for reducing the number of relevance judgments
required for reliable comparisons of search engines. Kelly and Teevan (2003) re-
view approaches to acquiring and using implicit relevance information. Fox et
al. (2005) studied implicit measures of relevance in the context of web search,
and Joachims et al. (2005) introduced strategies for deriving preferences based
on clickthrough data. Agichtein, Brill, Dumais, and Ragno (2006) extended this
approach and carried out more experiments introducing click distributions and
deviation, and showing that a number of features related to user behavior are use-
ful for predicting relevance.

The F measure was originally proposed by van Rijsbergen (1979) in the form
ofE = 1?F . He also provided a justification for theE measure in terms ofmea-
surement theory, raised the issue of whether effectiveness measures were interval
or ordinal measures, and suggested that the sign and Wilcoxon tests would be
appropriate for significance. Cooper (1968) wrote an important early paper that
introduced the expected search length (ESL) measure, which was the expected
number of documents that a user would have to look at to find a specified num-
ber of relevant documents.Although thismeasure has not beenwidely used, itwas
the ancestor of measures such as NDCG (Järvelin & Kekäläinen, 2002) that fo-
cus on the top-ranked documents. Another measure of this type that has recently
been introduced is rank-biased precision (Moffat et al., 2007).

Yao (1995) provides one of the first discussions of preferences and how they
could be used to evaluate a search engine. The paper by Joachims (2002b) that
showed how to train a linear feature-based retrieval model using preferences also
used Kendall’s ? as the effectiveness measure for defining the best ranking. The
recent paper by Carterette and Jones (2007) shows how search engines can be
evaluated using relevance information directly derived from clickthrough data,
rather than converting clickthrough to preferences.

A number of recent studies have focused on interactive information retrieval.
These studies involve a different style of evaluation than themethods described in
this chapter, but are more formal than online testing. Belkin (2008) describes the
challenges of evaluating interactive experiments and points to some interesting
papers on this topic.

Another area related to effectiveness evaluation is the prediction of query effec-
tiveness. Cronen-Townsend et al. (2006) describe the Clarity measure, which is



8.7 The Bottom Line 337

used to predict whether a ranked list for a query has good or bad precision. Other
measures have been suggested that have even better correlations with average pre-
cision.

There are very few papers that discuss guidelines for efficiency evaluations of
search engines. Zobel et al. (1996) is an example from the database literature.

Exercises

8.1. Find three other examples of test collections in the information retrieval lit-
erature. Describe them and compare their statistics in a table.

8.2. Imagine that you were going to study the effectiveness of a search engine for
blogs. Specify the retrieval task(s) for this application, and then describe the test
collection you would construct and how you would evaluate your ranking algo-
rithms.

8.3. For one query in the CACMcollection (provided at the book website), gen-
erate a ranking using Galago, and then calculate average precision, NDCG at 5
and 10, precision at 10, and the reciprocal rank by hand.

8.4. For twoqueries in theCACMcollection, generate twouninterpolated recall-
precision graphs, a table of interpolated precision values at standard recall levels,
and the average interpolated recall-precision graph.

8.5. Generate themean average precision, recall-precision graph, averageNDCG
at 5 and 10, and precision at 10 for the entire CACM query set.

8.6. Compare the MAP value calculated in the previous problem to the GMAP
value. Which queries have the most impact on this value?

8.7. Anothermeasure that has been used in a number of evaluations isR-precision.
This is defined as the precision at R documents, where R is the number of relevant
documents for a query. It is used in situations where there is a large variation in
the number of relevant documents per query. Calculate the average R-precision
for the CACM query set and compare it to the other measures.

8.8. Generate another set of rankings for 10 CACM queries by adding structure
to the queries manually. Compare the effectiveness of these queries to the simple
queries usingMAP,NDCG, and precision at 10. Check for significance using the
t-test, Wilcoxon test, and the sign test.



338 8 Evaluating Search Engines

8.9. For one query in the CACM collection, generate a ranking and calculate
BPREF. Show that the two formulations of BPREF give the same value.

8.10. Consider a test collection that contains judgments for a large number of
time-sensitive queries, such as “olympics” and “miss universe”. Suppose that the
judgments for these queries were made in 2002. Why is this a problem? How can
online testing be used to alleviate the problem?



9
Classification and Clustering

“What kind of thing? I need a clear definition.”

Ripley, Alien

We now take a slight detour from search to look at classification and clustering.
Classification and clustering have many things in common with document re-
trieval. In fact, many of the techniques that proved to be useful for ranking doc-
uments can also be used for these tasks. Classification and clustering algorithms
are heavily used in most modern search engines, and thus it is important to have
a basic understanding of how these techniques work and how they can be applied
to real-world problems. We focus here on providing general background knowl-
edge and a broad overview of these tasks. In addition, we provide examples of
how they can be applied in practice. It is not our goal to dive too deeply into the
details or the theory, since there are many other excellent references devoted en-
tirely to these subjects, some of which are described in the “References and Future
Reading” section at the end of this chapter. Instead, at the end of this chapter, you
should knowwhat classification and clustering are, themost commonly used algo-
rithms, examples of how they are applied in practice, and how they are evaluated.
On that note, we begin with a brief description of classification and clustering.

Classification, also referred to as categorization, is the task of automatically ap-
plying labels to data, such as emails, web pages, or images. People classify items
throughout their daily lives. It would be infeasible, however, tomanually label ev-
ery page on the Web according to some criteria, such as “spam” or “not spam.”
Therefore, there is a need for automatic classification and categorization tech-
niques. In this chapter, we describe several classification algorithms that are ap-
plicable to a wide range of tasks, including spam detection, sentiment analysis,
and applying semantic labels to web advertisements.

Clustering, the other topic covered in this chapter, can be broadly defined as
the task of grouping related items together. In classification, each item is assigned a



340 9 Classification and Clustering

label, such as “spam”or “not spam.” In clustering, however, each item is assigned to
one ormore clusters, where the cluster does not necessarily correspond to amean-
ingful concept, such as “spam” or “not spam.” Instead, as we will describe later
in this chapter, items are grouped together according to their similarity. There-
fore, rather than mapping items onto a predefined set of labels, clustering allows
the data to “speak for itself ” by uncovering the implicit structure that relates the
items.

Both classification and clustering have been studied for many years by infor-
mation retrieval researchers, with the aim of improving the effectiveness, or in
some cases the efficiency, of search applications. From another perspective, these
two tasks are classicmachine learning problems. Inmachine learning, the learning
algorithms are typically characterized as supervised or unsupervised. In supervised
learning, a model is learned using a set of fully labeled items, which is often called
the training set. Once a model is learned, it can be applied to a set of unlabeled
items, called the test set, in order to automatically apply labels. Classification is
often cast as a supervised learning problem. For example, given a set of emails
that have been labeled as “spam” or “not spam” (the training set), a classification
model can be learned.Themodel then can be applied to incoming emails in order
to classify them as “spam” or “not spam”.

Unsupervised learning algorithms, on the other hand, learn entirely based on
unlabeled data. Unsupervised learning tasks are often posed differently than su-
pervised learning tasks, since the input data is not mapped to a predefined set of
labels. Clustering is the most common example of unsupervised learning. As we
will show, clustering algorithms take a set of unlabeled data as input and then
group the items using some notion of similarity.

There are many other types of learning paradigms beyond supervised and un-
supervised, such as semi-supervised learning, active learning, and online learning.
However, these subjects are well beyond the scope of this book. Instead, in this
chapter, we provide an overview of basic yet effective classification and clustering
algorithms and methods for evaluating them.

9.1 Classification and Categorization

Applying labels to observations is a very natural task, and something that most of
us do, often without much thought, in our everyday lives. For example, consider
a trip to the local grocery store. We often implicitly assign labels such as “ripe” or
“not ripe,” “healthy” or “not healthy,” and “cheap” or “expensive” to the groceries



9.1 Classification and Categorization 341

that we see. These are examples of binary labels, since there are only two options
for each. It is also possible to apply multivalued labels to foods, such as “starch,”
“meat,” “vegetable,” or “fruit.” Another possible labeling scheme would arrange
categories into a hierarchy, in which the “vegetable” category would be split by
color into subcategories, such as “green,” “red,” and “yellow.” Under this scheme,
foods would be labeled according to their position within the hierarchy. These
different labeling or categorization schemes, which include binary, multivalued,
and hierarchical, are called ontologies (see Chapter 6).

It is important to choose an ontology that is appropriate for the underlying
task. For example, for detecting whether or not an email is spam, it is perfectly
reasonable to choose a label set that consists of “spam” and “not spam”. However,
if one were to design a classifier to automatically detect what language a web page
is written in, then the set of all possible languages would be a more reasonable
ontology. Typically, the correct choice of ontology is dictated by the problem,
but in cases when it is not, it is important to choose a set of labels that is expres-
sive enough to be useful for the underlying task. However, since classification is
a supervised learning task, it is important not to construct an overly complex on-
tology, since most learning algorithms will fail (i.e., not generalize well to unseen
data) when there is little or no data associated with one or more of the labels. In
the web page language classifier example, if we had only one example page for
each of the Asian languages, then, rather than having separate labels for each of
the languages, such as “Chinese”, “Korean”, etc., it would be better to combine
all of the languages into a single label called “Asian languages”. The classifier will
then be more likely to classify things as “Asian languages” correctly, since it has
more training examples.

In order to understand how machine learning algorithms work, we must first
take a look at how people classify items. Returning to the grocery store example,
consider how we would classify a food as “healthy” or “not healthy.” In order to
make this classification, we would probably look at the amount of saturated fat,
cholesterol, sugar, and sodium in the food. If these values, either separately or in
combination, are above some threshold, then we would label the food “healthy”
or “unhealthy.” To summarize, as humans we classify items by first identifying a
number of important features that will help us distinguish between the possible
labels. We then extract these features from each item. We then combine evidence
from the extracted features in some way. Finally, we classify the item using some
decision mechanism based on the combined evidence.



342 9 Classification and Clustering

In our example, the features are things such as the amount of saturated fat and
the amount of cholesterol. The features are extracted by reading the nutritional
information printed on the packaging or by performing laboratory tests. There
are various ways to combine the evidence in order to quantify the “healthiness”
(denotedH) of the food, but one simple way is to weight the importance of each
feature and then add the weighted feature values together, such as:

H(food) ? wfatfat(food) + wcholchol(food) +
wsugarsugar(food) + wsodiumsodium(food)

wherewfat,wchol, etc., are the weights associated with each feature. Of course, in
this case, it is likely that each of the weights would be negative.

Once we have a healthiness score, H , for a given food, we must apply some
decision mechanism in order to apply a “healthy” or “not healthy” label to the
food. Again, there are various ways of doing this, but one of the most simple is
to apply a simple threshold rule that says “a food is healthy ifH(food) ? t” for
some threshold value t.

Although this is an idealized model of how people classify items, it provides
valuable insights into how a computer can be used to automatically classify items.
Indeed, the two classification algorithms that we will now describe follow the
same steps as we outlined earlier.The only difference between the two algorithms
is in the details of how each step is actually implemented.

9.1.1 Naïve Bayes

Wearenowready todescribehow items canbe automatically classified.Oneof the
most straightforward yet effective classification techniques is called Naïve Bayes.
We introduced the Bayes classifier in Chapter 7 as a framework for a probabilistic
retrieval model. In that case, there were just two classes of interest, the relevant
class and the non-relevant class. In general, classification tasks can involve more
than two labels or classes. In that situation, Bayes’ Rule, which is the basis of a
Bayes classifier, states that:

P (C|D) = P (D|C)P (C)
P (D)

=
P (D|C)P (C)?

c?C P (D|C = c)P (C = c)



9.1 Classification and Categorization 343

whereC andD are randomvariables. Randomvariables are commonly usedwhen
modeling uncertainty. Such variables do not have a fixed (deterministic) value.
Instead, the value of the variable is random. Every random variable has a set of
possible outcomes associated with it, as well as a probability distribution over the
outcomes. As an example, the outcome of a coin toss can bemodeled as a random
variable X . The possible outcomes of the random variable are “heads” (h) and
“tails” (t). Given a fair coin, the probability associated with both the heads out-
come and the tails outcome is 0.5. Therefore, P (X = h) = P (X = t) = 0.5.

Consider another example, where you have the algebraic expression Y =
10 + 2X . If X was a deterministic variable, then Y would be deterministic as
well. That is, for a fixed X , Y would always evaluate to the same value. How-
ever, ifX is a random variable, then Y is also a random variable. Suppose thatX
had possible outcomes –1 (with probability 0.1), 0 (with probability 0.25), and
1 (with probability 0.65). The possible outcomes for Y would then be 8, 10, and
12, with P (Y = 8) = 0.1, P (Y = 10) = 0.25, and P (Y = 12) = 0.65.

In this chapter, we denote random variables with capital letters (e.g., C , D)
and outcomes of randomvariables as lowercase letters (e.g., c,d). Furthermore, we
denote the entire set of outcomes with caligraphic letters (e.g., C,D). Finally, for
notational convenience, instead of writing P (X = x), we write P (x). Similarly
for conditional probabilities, rather than writing P (X = x|Y = y), we write
P (x|y).

Bayes’ Rule is important because it allows us to write a conditional probability
(such as P (C|D)) in terms of the “reverse” conditional (P (D|C)). This is a very
powerful theorem, because it is often easy to estimate or compute the conditional
probability in onedirectionbutnot the other. For example, consider spamclassifi-
cation, whereD represents a document’s text andC represents the class label (e.g.,
“spam” or “not spam”). It is not immediately clear how to write a program that
detects whether a document is spam; that program is represented by P (C|D).
However, it is easy to find examples of documents that are and are not spam. It is
possible to come up with estimates for P (D|C) given examples or training data.
The magic of Bayes’ Rule is that it tells us how to get what we want (P (C|D)),
but may not immediately know how to estimate, from something we do know
how to estimate (P (D|C)).

It is straightforward to use this rule to classify items if we let C be the ran-
dom variable associated with observing a class label and let D be the random
variable associated with observing a document, as in our spam example. Given



344 9 Classification and Clustering

a document1 d (an outcome of random variable D) and a set of classes C =
c1, . . . , cN (outcomes of the random variableC), we can use Bayes’ Rule to com-
pute P (c1|d), . . . , P (cN |d), which computes the likelihood of observing class
label ci given that document d was observed. Document d can then be labeled
with the class with the highest probability of being observed given the document.
That is, Naïve Bayes classifies a document d as follows:

Class(d) = arg max
c?C

P (c|d)

= arg max
c?C

P (d|c)P (c)?
c?C P (d|c)P (c)

where arg maxc?C P (c|d)means “return the class c, out of the set of all possible
classes C, that maximizes P (c|d).” This is a mathematical way of saying that we
are trying to find the most likely class c given the document d.

Instead of computing P (c|d) directly, we can compute P (d|c) and P (c) in-
stead and then apply Bayes’ Rule to obtain P (c|d). As we explained before, one
reason for using Bayes’ Rule is when it is easier to estimate the probabilities of
one conditional, but not the other.We now explain how these values are typically
estimated in practice.

We first describe how to estimate the class prior, P (c). The estimation is
straightforward. It is estimated according to:

P (c) =
Nc
N

whereNc is the number of training instances that have label c, andN is the total
number of training instances.Therefore,P (c) is simply the proportion of training
instances that have label c.

Estimating P (d|c) is a little more complicated because the same “counting”
estimate that wewere able to use for estimatingP (c)would not work. (Why? See
exercise 9.3.) In order to make the estimation feasible, we must impose the sim-
plifying assumption that d can be represented as d = w1, . . . , wn and that wi
is independent of wj for every i ?= j. Simply stated, this says that document d
1 Throughout most of this chapter, we assume that the items being classified are textual
documents. However, it is important to note that the techniques described here can
be used in a more general setting and applied to non-textual items such as images and
videos.



9.1 Classification and Categorization 345

can be factored into a set of elements (terms) and that the elements (terms) are
independent of each other.2 This assumption is the reason for calling the classi-
fier naïve, because it requires documents to be represented in an overly simpli-
fied way. In reality, terms are not independent of each other. However, as we will
show in Chapter 11, properly modeling term dependencies is possible, but typi-
cally more difficult. Despite the independence assumption, the Naïve Bayes clas-
sifier has been shown to be robust and highly effective for various classification
tasks.

This naïve independence assumption allows us to invoke a classic result from
probability that states that the joint probability of a set of (conditionally) inde-
pendent random variables can be written as the product of the individual condi-
tional probabilities. That means that P (d|c) can be written as:

P (d|c) =
n?

i=1

P (wi|c)

Therefore, we must estimate P (w|c) for every possible termw in the vocabulary
V and class c in the ontology C. It turns out that this is a much easier task than
estimating P (d|c) since there is a finite number of terms in the vocabulary and a
finite number of classes, but an infinite number of possible documents. The inde-
pendence assumption allows us to write the probability P (c|d) as:

P (c|d) = P (d|c)P (c)?
c?C P (d|c)P (c)

=

?V
i=1 P (wi|c)P (c)?

c?C
?V

i=1 P (wi|c)P (c)

The only thing left to describe is how to estimate P (w|c). Before we can esti-
mate the probability, wemust first decide onwhat the probability actuallymeans.
For example, P (w|c) could be interpreted as “the probability that term w is re-
lated to class c,” “the probability that w has nothing to do with class c,” or any
number of other things. In order to make the meaning concrete, we must explic-
itly define the event space that the probability is defined over. An event space is the
2 This is the same assumption that lies at the heart of most of the retrieval models de-
scribed in Chapter 7. It is also equivalent to the bag of words assumption discussed in
Chapter 11.



346 9 Classification and Clustering

set of possible events (or outcomes) from some process. A probability is assigned
to each event in the event space, and the sum of the probabilities over all of the
events in the event space must equal one.

The probability estimates and the resulting classification will vary depending
on the choice of event space.Wewill nowbriefly describe twoof themore popular
event spaces and show how P (w|c) is estimated in each.

Multiple-Bernoulli model

The first event space that we describe is very simple. Given a class c, we define a
binary random variablewi for every term in the vocabulary. The outcome for the
binary event is either 0 or 1.TheprobabilityP (wi = 1|c) can then be interpreted
as “the probability that termwi is generated by class c.” Conversely,P (wi = 0|c)
canbe interpreted as “the probability that termwi is not generated by class c.”This
is exactly the event space used by the binary independencemodel (seeChapter 7),
and is known as themultiple-Bernoulli event space.

Under this event space, for each term in some class c, we estimate the prob-
ability that the term is generated by the class. For example, in a spam classifier,
P (cheap = 1|spam) is likely to have a high probability, whereas P (dinner =
1|spam) is going to have a much lower probability.

document id cheap buy banking dinner the class
1 0 0 0 0 1 not spam
2 1 0 1 0 1 spam
3 0 0 0 0 1 not spam
4 1 0 1 0 1 spam
5 1 1 0 0 1 spam
6 0 0 1 0 1 not spam
7 0 1 1 0 1 not spam
8 0 0 0 0 1 not spam
9 0 0 0 0 1 not spam
10 1 1 0 1 1 not spam

Fig. 9.1. Illustration of how documents are represented in the multiple-Bernoulli event
space. In this example, there are 10 documents (each with a unique id), two classes (spam
and not spam), and a vocabulary that consists of the terms “cheap”, “buy”, “banking”, “din-
ner”, and “the”.



9.1 Classification and Categorization 347

Figure 9.1 shows how a set of training documents can be represented in this
event space. In the example, there are 10 documents, two classes (spam and not
spam), and a vocabulary that consists of the terms “cheap”, “buy”, “banking”, “din-
ner”, and “the”. In this example, P (spam) = 3

10
and P (not spam) = 7

10
. Next,

we must estimate P (w|c) for every pair of terms and classes. The most straight-
forward way is to estimate the probabilities using what is called the maximum
likelihood estimate, which is:

P (w|c) = dfw,c
Nc

where dfw,c is the number of training documents with class label c in which term
w occurs, and Nc is the total number of training documents with class label c.
As we see, the maximum likelihood estimate is nothing more than the propor-
tion of documents in class c that contain termw. Using the maximum likelihood
estimate, we can easily compute P (the|spam) = 1, P (the|not spam) = 1,
P (dinner|spam) = 0, P (dinner|not spam) = 1

7
, and so on.

Using themultiple-Bernoulli model, the document likelihood,P (d|c), can be
written as:

P (d|c) =
?
w?V

P (w|c)?(w,d) (1? P (w|c))1??(w,d)

where ?(w,D) is 1 if and only if termw occurs in document d.
In practice, it is not possible to use the maximum likelihood estimate because

of the zero probability problem. In order to illustrate the zero probability problem,
let us return to the spam classification example from Figure 9.1. Suppose that we
receive a spam email that happens to contain the term “dinner”. No matter what
other terms the email does or does not contain, the probabilityP (d|c)will always
be zero because P (dinner|spam) = 0 and the term occurs in the document
(i.e., ?dinner,d = 1). Therefore, any document that contains the term “dinner”
will automatically have zero probability of being spam.This problem is more gen-
eral, since a zero probability will result whenever a document contains a term that
never occurs in one ormore classes.The problem here is that themaximum likeli-
hood estimate is based on counting occurrences in the training set. However, the
training set is finite, so not every possible event is observed. This is known as data
sparseness. Sparseness is often a problem with small training sets, but it can also
happen with relatively large data sets. Therefore, we must alter the estimates in
such a way that all terms, including those that have not been observed for a given



348 9 Classification and Clustering

class, are given some probabilitymass.That is, wemust ensure thatP (w|c) is non-
zero for all terms in V . By doing so, we will avoid all of the problems associated
with the zero probability problem.

Aswas described inChapter 7, smoothing is a useful technique for overcoming
the zero probability problem. One popular smoothing technique is often called
Bayesian smoothing, which assumes some prior probability overmodels and uses a
maximuma posteriori estimate.The resulting smoothed estimate for themultiple-
Bernoulli model has the form:

P (w|c) = dfw,c + ?w
Nc + ?w + ?w

where ?w and ?w are parameters that depend on w. Different settings of these
parameters result in different estimates. One popular choice is to set?w = 1 and
?w = 0 for allw, which results in the following estimate:

P (w|c) = dfw,c + 1
Nc + 1

Another choice is to set?w = µNwN and ?w = µ(1?
Nw
N
) for allw, whereNw is

the total number of training documents in which termw occurs, and µ is a single
tunable parameter. This results in the following estimate:

P (w|c) =
dfw,c + µ

Nw
N

Nc + µ

This event space only captures whether or not the term is generated; it fails
to capture how many times the term occurs, which can be an important piece of
information. We will now describe an event space that takes term frequency into
account.

Multinomial model

The binary event space of the multiple-Bernoulli model is overly simplistic, as it
does not model the number of times that a term occurs in a document. Term fre-
quency has been shown to be an important feature for retrieval and classifica-
tion, especially when used on long documents. When documents are very short,
it is unlikely that many terms will occur more than one time, and therefore the
multiple-Bernoulli model will be an accurate model. However, more often than



9.1 Classification and Categorization 349

not, real collections contain documents that are both short and long, and there-
fore it is important to take term frequency and, subsequently, document length
into account.

The multinomial event space is very similar to the multiple-Bernoulli event
space, except rather than assuming that term occurrences are binary (“term oc-
curs” or “term does not occur”), it assumes that terms occur zero or more times
(“term occurs zero times”, “term occurs one time”, etc.).

document id cheap buy banking dinner the class
1 0 0 0 0 2 not spam
2 3 0 1 0 1 spam
3 0 0 0 0 1 not spam
4 2 0 3 0 2 spam
5 5 2 0 0 1 spam
6 0 0 1 0 1 not spam
7 0 1 1 0 1 not spam
8 0 0 0 0 1 not spam
9 0 0 0 0 1 not spam
10 1 1 0 1 2 not spam

Fig. 9.2. Illustration of how documents are represented in the multinomial event space.
In this example, there are 10 documents (each with a unique id), two classes (spam and
not spam), and a vocabulary that consists of the terms “cheap”, “buy”, “banking”, “dinner”,
and “the”.

Figure 9.2 shows how the documents from our spam classification example
are represented in the multinomial event space. The only difference between this
representation and themultiple-Bernoulli representation is that the events are no
longer binary. The maximum likelihood estimate for the multinomial model is
very similar to the multiple-Bernoulli model. It is computed as:

P (w|c) = tfw,c
|c|

where tfw,c is the number of times that termw occurs in class c in the training set,
and |c| is the total number of terms that occur in training documents with class la-
bel c. In the spamclassification example,P (the|spam) = 4

20
,P (the|not spam) =

9
15

, P (dinner|spam) = 0, and P (dinner|not spam) = 1
15

.



350 9 Classification and Clustering

Since terms are now distributed according to a multinomial distribution, the
likelihood of a document d given a class c is computed according to:

P (d|c) = P (|d|)
(
tfw1,d, tfw2,d, . . . , tfwV,d

)
!
?
w?V

P (w|c)tfw,d

?
?
w?V

P (w|c)tfw,d

where tfw,d is the number of times that term w occurs in document d, |d| is the
total number of terms that occur in d, P (|d|) is the probability of generating
a document of length |d|, and

(
tfw1,d, tfw2,d, . . . , tfwV,d

)
! is the multinomial

coefficient.3 Notice that P (|d|) and the multinomial coefficient are document-
dependent and, for the purposes of classification, can be ignored.

The Bayesian smoothed estimates of the term likelihoods are computed ac-
cording to:

P (w|c) = tfw,c + ?w
|c|+

?
w?V ?w

where ?w is a parameter that depends on w. As with the multiple-Bernoulli
model, different settings of the smoothing parameters result in different types
of estimates. Setting ?w = 1 for all w is one possible option. This results in the
following estimate:

P (w|c) = tfw,c + 1
|c|+ |V|

Another popular choice is to set ?w = µ cfw|C| , where cfw is the total number of
times that term w occurs in any training document, |C| is the total number of
terms in all training documents, and µ, as before, is a tunable parameter. Under
this setting, we obtain the following estimate:

P (w|c) =
tfw,c + µ

cfw
|C|

|c|+ µ

This estimate may look familiar, as it is exactly the Dirichlet smoothed language
modeling estimate that was described in Chapter 7.

3 The multinomial coefficient is a generalization of the binomial coefficient. It is com-
puted as (N1, N2, . . . , Nk)! = N !N1!N2!···Nk! . It counts the total number of unique
ways that

?
iNi items (terms) can be arranged given that item i occursNi times.



9.1 Classification and Categorization 351

In practice, the multinomial model has been shown to consistently outper-
form the multiple-Bernoulli model. Implementing a classifier based on either of
these models is straightforward. Training consists of computing simple term oc-
currence statistics. In most cases, these statistics can be stored in memory, which
means that classification can be done efficiently.The simplicity of themodel, com-
bined with good accuracy, makes the Naïve Bayes classifier a popular and attrac-
tive choice as a general-purpose classification algorithm.

9.1.2 Support Vector Machines

Unlike the Naïve Bayes classifier, which is based purely on probabilistic princi-
ples, the next classifier we describe is based on geometric principles. Support Vec-
torMachines, often called SVMs, treat inputs such as documents as points in some
geometric space. For simplicity, we first describe how SVMs are applied to classi-
fication problems with binary class labels, which we will refer to as the “positive”
and “negative” classes. In this setting, the goal of SVMs is to find a hyperplane4
that separates the positive examples from the negative examples.

In the Naïve Bayes model, documents were treated as binary vectors in the
multiple-Bernoulli model and as term frequency vectors in the multinomial case.
SVMs provide more flexibility in terms of how documents can be represented.
With SVMs, rather than defining some underlying event space, we must instead
define a set of feature functionsf1(·), . . . , fN(·) that take a document as input and
produce what is known as a feature value. Given a document d, the document is
represented in an N -dimensional space by the vector xd = [f1(d), . . . , fN(d)].
Given a set of training data, we can use the feature functions to embed the training
documents in this N -dimensional space. Notice that different feature functions
will result in different embeddings. Since SVMs find a hyperplane that separates
the data according to classes, it is important to choose feature functions that will
help discriminate between the different classes.

Two common feature functions are fw(d) = ?(w, d) and fw(d) = tfw,d.The
first feature function is 1 if termw occurs ind, which is analogous to themultiple-
Bernoulli model. The second feature function counts the number of times thatw
occurs in d, which is analogous to the multinomial model. Notice that these fea-
ture functions are indexed byw, whichmeans that there is a total of |V| such func-
tions. This results in documents being embedded in a |V|-dimensional space. It is
also possible to define similar feature functions over bigrams or trigrams, which

4 A hyperplane generalizes the notion of a plane toN -dimensional space.



352 9 Classification and Clustering

would cause the dimensionality of the feature space to explode. Furthermore,
other information can be encoded in the feature functions, such as the document
length, the number of sentences in the document, the last time the document was
updated, and so on.

Fig. 9.3.Data set that consists of two classes (pluses andminuses).The data set on the left
is linearly separable, whereas the one on the right is not.

Now that we have a mechanism for representing documents in an N -dimen-
sional space, we describe how SVMs actually classify the points in this space. As
described before, the goal of SVMs is to find a hyperplane that separates the neg-
ative and positive examples. The hyperplane is learned from the training data. An
unseen test point is classified according to which side of the hyperplane the point
falls on. For example, if the point falls on the negative side, then we classify it as
negative. Similarly, if it falls on the positive side, then it is classified as positive. It
is not always possible to draw a hyperplane that perfectly separates the negative
training data from the positive training data, however, since no such hyperplane
may exist for some embedding of the training data. For example, in Figure 9.3, it
is possible to draw a line (hyperplane) that separates the positive class (denoted
by “+”) from the negative class (denoted by “–”) in the left panel. However, it is
impossible to do so in the right panel. The points in the left panel are said to be
linearly separable, since we can draw a linear hyperplane that separates the points.

It is much easier to define and find a good hyperplane when the data is linearly
separable. Therefore, we begin our explanation of how SVMs work by focusing
on this special case. We will then extend our discussion to the more general and
common case where the data points are not linearly separable.



9.1 Classification and Categorization 353

Case 1: Linearly separable data

Suppose that you were given a linearly separable training set, such as the one in
Figure 9.3, and were asked to find the optimal hyperplane that separates the data
points. How would you proceed? You would very likely first ask what exactly is
meant by optimal. One might first postulate that optimal means any hyperplane
that separates the positive training data from the negative training data.However,
we must also consider the ultimate goal of any classification algorithm, which is
to generalize well to unseen data. If a classifier can perfectly classify the training
data but completely fails at classifying the test set data, then it is of little value.
This scenario is known as overfitting.

+

+

+

+

+

+

+

+

–

–

–

–

–

–

–

–

–

+

–

+

w ¢ x > 0

w ¢ x < 0

w
¢
x
=
0

w
¢
x
=
1

w
¢
x
=
¡
1

Fig. 9.4.Graphical illustration of SupportVectorMachines for the linearly separable case.
Here, the hyperplane defined by w is shown, as well as the margin, the decision regions,
and the support vectors, which are indicated by circles.

In order to avoid overfitting, SVMs choose the hyperplane thatmaximizes the
separation between the positive and negative data points. This selection criteria
makes sense intuitively, and is backed up by strong theoretical results as well. As-
suming that our hyperplane is defined by the vectorw, we want to find thew that
separates the positive and negative training data andmaximizes the separation be-



354 9 Classification and Clustering

tween the data points.Themaximal separation is defined as follows. Suppose that
x? is the closest negative training point to the hyperplane and that x+ is the clos-
est positive training point to the hyperplane.5 Then, we define the margin as the
distance from x? to the hyperplane plus the distance from x+ to the hyperplane.
Figure 9.4 shows a graphical illustration of the margin, with respect to the hy-
perplane and the support vectors (i.e., x+ and x?). The margin can be computed
using simple vector mathematics as follows:

Margin(w) =
|w · x?|+ |w · x+|

||w||

where · is the dot product (inner product) between two vectors, and ||w|| =
(w · w)1/2 is the length of the vectorw. The SVM algorithm’s notion of an opti-
mal hyperplane, therefore, is the hyperplane w that maximizes the margin while
still separating the data. In order to simplify things, it is typically assumed that
w · x? = ?1 and w · x+ = 1. These assumptions, which do not change the
solution to the problem, result in the margin being equal to 2||w|| . An alternative
yet equivalent formulation is to find the hyperplane w that solves the following
optimization problem:

minimize: 1
2
||w||2

subject to:
w · xi ? 1 ?i s.t. Class(i) = +
w · xi ? ?1 ?i s.t. Class(i) = ?

This formulation is oftenusedbecause it is easier to solve. In fact, this optimization
problem can be solved using a technique called quadratic programming, the details
of which are beyond the scope of this book. However, there many excellent open
source SVM packages available. In the “References and Further Reading” section
at the end of this chapter we provide pointers to several such software packages.

Once the bestw has been found, an unseen document d can be classified using
the following rule:

Class(d) =
{
+ ifw · xd > 0
? otherwise

5 The vectors x? and x+ are known as support vectors. The optimal hyperplane w is a
linear combinationof these vectors.Therefore, theyprovide the support for thedecision
boundary. This is the origin of the name “Support Vector Machine.”



9.1 Classification and Categorization 355

Therefore, the rule classifies documents based onwhich side of the hyperplane the
document’s feature vector is on. Referring back to Figure 9.4, we see that in this
example, those points to the left of the hyperplane are classified as positive exam-
ples and those to the right of the hyperplane are classified as negative examples.

Case 2: Non-linearly separable data

Very few real-world data sets are actually linearly separable. Therefore, the SVM
formulation just describedmust bemodified in order to account for this.This can
be achieved by adding a penalty factor to the problem that accounts for training
instances that do not satisfy the constraints of the linearly separable formulation.

Suppose that, for some training point x in the positive class, w · x = ?0.5.
This violates the constraint w · x ? 1. In fact, x falls on the entirely wrong side
of the hyperplane. Since the target for w · x is (at least) 1, we can apply a linear
penalty based on the difference between the target and actual value. That is, the
penalty given to x is 1? (?0.5) = 1.5. Ifw · x = 1.25, then no penalty would
be assigned, since the constraint would not be violated. This type of penalty is
known as the hinge loss function. It is formally defined as:

L(x) =

{
max(1? w · x, 0) if Class(i) = +
max(1 + w · x, 0) if Class(i) = ?

This loss function is incorporated into the SVM optimization as follows:

minimize: 1
2
||w||2 + C

?N
i=1 ?i

subject to:
w · xi ? 1? ?i ?i s.t. Class(i) = +
w · xi ? ?1 + ?i ?i s.t. Class(i) = ?

?i ? 0 ?i

where ?i is known as a slack variable that allows the target values to be violated.
The slack variables enforce the hinge loss function. Notice that if all of the con-
straints are satisfied, all of the slack variables would be equal to 0, and therefore
the loss function would reduce to the linearly separable case. In addition, if any
constraint is violated, then the amount by which it is violated is added into the
objective function and multiplied by C , which is a free parameter that controls
howmuch to penalize constraint violations. It is standard to setC equal to 1.This



356 9 Classification and Clustering

optimization problem finds a hyperplane that maximizes themargin while allow-
ing for some slack. As in the linearly separable case, this optimization problem can
be solved using quadratic programming. In addition, classification is performed
in the same way as the linearly separable case.

The kernel trick

Theexample in Figure 9.3 illustrates the fact that certain embeddings of the train-
ing data are not linearly separable. It may be possible, however, that a transforma-
tion or mapping of the data into a higher dimensional space results in a set of
linearly separable points. This may result in improved classification effectiveness,
although it is not guaranteed.

There are many ways to map an N -dimensional vector into a higher dimen-
sional space. For example, given the vector [f1(d), . . . , fN(d)], one could aug-
ment the vector by including squared feature values.That is, the data items would
now be represented by the 2N -dimensional vector:[

f1(d), . . . , fN(d), f1(d)
2, . . . , fN(d)

2
]

Thehigher the dimensionality of the feature vectors, however, the less efficient the
algorithm becomes, both in terms of space requirements and computation time.

One important thing tonotice is that the keymathematical operation involved
in training and testing SVMs is the dot product. If there was an efficient way to
compute the dot product between two very high-dimensional vectors without
having to store them, then it would be feasible to perform such a mapping. In
fact, this is possible for certain classes of high-dimensional mappings. This can be
achieved by using a kernel function. A kernel function takes two N -dimensional
vectors and computes a dot product between them in a higher dimensional space.
This higher dimensional space is implicit, in that the higher dimensional vectors
are never actually constructed.

Let us now consider an example. Suppose thatwe have two 2-dimensional vec-
torsw = [w1w2] and x = [x1x2]. Furthermore, we define?(·) as follows:

?(x) =

?? x21?2x1x2
x22

??
Here, ?(·) maps 2-dimensional vectors into 3-dimensional vectors. As we de-
scribed before, this may be useful because the original inputs may actually be lin-
early separable in the3-dimensional space towhich?(·)maps thepoints.One can



9.1 Classification and Categorization 357

imaginemany,manyways ofmapping the original inputs into higher dimensional
spaces. However, as we will now show, certainmappings have very nice properties
that allow us to efficiently compute dot products in the higher dimensional space.

Given this mapping, the naïve way to compute?(w) ·?(x)would be to first
explicitly construct ?(w) and ?(x) and then perform the dot product in the 3-
dimensional space. However, surprisingly, it turns out that this is not necessary,
since:

?(w) · ?(x) = w21x21 + 2w1w2x1x2 + w22x22
= (w · x)2

where w · x is computed in the original, 2-dimensional space. Therefore, rather
than explicitly computing the dot product in the higher 3-dimensional space, we
only need to compute the dot product in the original 2-dimensional space and
then square the value. This “trick,” which is often referred to as the kernel trick,
allows us to efficiently compute dot products in some higher dimensional space.

Of course, the example given here is rather trivial. The true power of the ker-
nel trick becomes more apparent when dealing with mappings that project into
much higher dimensional spaces. In fact, some kernels perform a dot product in
an infinite dimensional space!

Kernel Type Value Implicit Dimension
Linear K(x1, x2) = x1 · x2 N

Polynomial K(x1, x2) = (x1 · x2)p
(
N + p? 1

N

)
Gaussian K(x1, x2) = exp?||x1 ? x2||2/2?2 Infinite

Table 9.1. A list of kernels that are typically used with SVMs. For each kernel, the name,
value, and implicit dimensionality are given.

A list of themost widely used kernels is given inTable 9.1.Note that theGaus-
sian kernel is also often called a radial basis function (RBF) kernel.Thebest choice
of kernel depends on the geometry of the embedded data. Each of these kernels
has been shown to be effective on textual features, although the Gaussian kernel
tends to work well across a wide range of data sets, as long as the variance (?2) is
properly set.Most standard SVM software packages have these kernels built in, so
using them is typically as easy as specifying a command-line argument.Therefore,



358 9 Classification and Clustering

given their potential power and their ease of use, it is often valuable to experiment
with each of the kernels to determine the best one to use for a specific data set and
task.

The availability of these software packages, together with the SVM’s flexibil-
ity in representation and, most importantly, their demonstrated effectiveness in
many applications, has resulted in SVMs being very widely used in classification
applications.

Non-binary classification

Up until this point, our discussion has focused solely on how support vector ma-
chines can be used for binary classification tasks.We will now describe two of the
most popular ways to turn a binary classifier, such as a support vector machine,
into a multi-class classifier. These approaches are relatively simple to implement
and have been shown to be work effectively.

The first technique is called the one versus all (OVA) approach. Suppose that
we have aK ? 2 class classification problem.TheOVA approach works by train-
ing K classifiers. When training the kth classifier, the kth class is treated as the
positive class and all of the other classes are treated as the negative class. That is,
each classifier treats the instances of a single class as the positive class, and the
remaining instances are the negative class. Given a test instance x, it is classified
using all K classifiers. The class for x is the (positive) class associated with the
classifier that yields the largest value of w · x. That is, if wc is the “class c versus
not class c” classifier, then items are classified according to:

Class(x) = arg max
c

wc · x

Theother technique is called the one versus one (OVO) approach. In theOVO
approach, a binary classifier is trained for every uniquepair of classes. For example,
for a ternary classification problem with the labels “excellent”, “fair”, and “bad”, it
would be necessary to train the following classifiers: “excellent versus fair”, “ex-
cellent versus bad”, and “fair versus bad”. In general, the OVO approach requires
K(K?1)

2
classifiers to be trained, which can be computationally expensive for large

data sets and large values ofK . To classify a test instance x, it is run through each
of the classifiers. Each time x is classified as c, a vote for c is recorded. The class
that has the most votes at the end is then assigned to x.

Both the OVA and OVO approaches work well in practice. There is no con-
crete evidence that suggests that either should be preferred over the other. Instead,



9.1 Classification and Categorization 359

the effectiveness of the approaches largely depends on the underlying character-
istics of the data set.

9.1.3 Evaluation

Most classification tasks are evaluated using standard information retrieval met-
rics, such as accuracy,6 precision, recall, the F measure, and ROC curve analysis.
Each of these metrics were described in detail in Chapter 8. Of these metrics, the
most commonly used are accuracy and the F measure.

There are two major differences between evaluating classification tasks and
other retrieval tasks.The first difference is that the notion of “relevant” is replaced
with “is classified correctly.” The other major difference is that microaveraging,
which is not commonly used to evaluate retrieval tasks, is widely used in classi-
fication evaluations. Macroaveraging for classification tasks involves computing
some metric for each class and then computing the average of the per-class met-
rics. On the other hand, microaveraging computes ametric for every test instance
(document) and then averages over all such instances. It is often valuable to com-
pute and analyze both the microaverage and the macroaverage, especially when
the class distribution P (c) is highly skewed.

9.1.4 Classifier and Feature Selection

Up until this point we have covered the basics of two popular classifiers. We have
described the principles the classifiers are built upon, their underlying assump-
tions, the pros and cons, and how they can be used in practice. As classification is
a deeply complex and rich subject, we cover advanced classification topics in this
section thatmay be of interest to those whowould like a deeper ormore complete
understanding of the topic.

Generative, discriminative, and non-parametric models

The Naïve Bayes classifier was based on probabilistic modeling. The model re-
quires us to assume that documents are generated from class labels according to a
probabilistic model that corresponds to some underlying event space. The Naïve
Bayes classifier is an example of a wider class of probabilistic models called gener-
ative models. These models assume that some underlying probability distribution
6 Accuracy is another name for precision at rank 1.



360 9 Classification and Clustering

generates both documents and classes. In the Naïve Bayes case, the classes and
documents are generated as follows. First, a class is generated according to P (c).
Then, a document is generated according to P (d|c). This process is summarized
in Figure 9.5. Generative models tend to appeal to intuition by mimicking how
people may actually generate (write) documents.

Class 1 Class 2 Class 3

Class 2

Generate class 

according to P(c)

Generate document 

according to P(d|c)

Fig. 9.5.Generative process used by theNaïve Bayesmodel. First, a class is chosen accord-
ing to P (c), and then a document is chosen according to P (d|c).

Of course, the accuracy of generative models largely depends on how accu-
rately the probabilistic model captures this generation process. If the model is a
reasonable reflection of the actual generation process, then generativemodels can
be very powerful, especially when there are very few training examples.

As the number of training examples grows, however, the power of the gener-
ative model can be limited by simplifying distributional assumptions, such as the
independence assumption in the Naïve Bayes classifier. In such cases, discrimina-
tive models often outperform generative models. Discriminative models are those
that do not model the generative process of documents and classes. Instead, they
directly model the class assignment problem given a document as input. In this
way, they discriminate between class labels. Since these models do not need to
model the generation of documents, they often have fewer distributional assump-
tions, which is one reasonwhy they are often preferred to generativemodels when



9.1 Classification and Categorization 361

there are many training examples. Support vector machines are an example of a
discriminative model. Notice that no assumptions about the document genera-
tion process are made anywhere in the SVM formulation. Instead, SVMs directly
learn a hyperplane that effectively discriminates between the classes.

–

+

+ +

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–

–
–

–

–

––

–

–

–

–

+

–

Fig. 9.6. Example data set where non-parametric learning algorithms, such as a nearest
neighbor classifier, may outperform parametric algorithms. The pluses and minuses indi-
cate positive and negative training examples, respectively. The solid gray line shows the
actual decision boundary, which is highly non-linear.

Non-parametric classifiers are another option when there is a large number
of training examples. Non-parametric classifiers let the data “speak for itself ”
by eliminating all distributional assumptions. One simple example of a non-
parametric classifier is the nearest neighbor classifier. Given an unseen example,
the nearest neighbor classifier finds the training example that is nearest (accord-
ing to some distance metric) to it. The unseen example is then assigned the label
of this nearest neighbor. Figure 9.6 shows an example output of a nearest neigh-
bor classifier. Notice the irregular, highly non-linear decision boundary induced
by the classifier. Generative and discriminative models, even SVMs with a non-



362 9 Classification and Clustering

linear kernel, would have a difficult time fitting a model to this data. For this rea-
son, the nearest neighbor classifier is optimal as the number of training examples
approaches infinity. However, the classifier tends to have a very high variance for
smaller data sets, which often limits its applicability.

Feature selection

The SVM classifier embeds inputs, such as documents, into some feature space
that is defined by a set of feature functions. As we described, it is common to de-
fine one (or more) feature functions for every word in the vocabulary. This |V|-
dimensional feature space can be extremely large, especially for very large vocabu-
laries. Since the feature set size affects both the efficiency and effectiveness of the
classifier, researchers have devised techniques for pruning the feature space.These
are known as feature selection techniques.

The goal of feature selection is to find a small subset of the original features
that can be used in place of the original feature set with the aim of significantly
improving efficiency (in terms of storage and time) while not hurting effective-
nessmuch. In practice, it turns out that feature selection techniques often improve
effectiveness instead of reducing it.The reason for this is that some of the features
eliminated during feature selectionmay be noisy or inaccurate, and therefore hin-
der the ability of the classification model to learn a good model.

Information gain is one of the most widely used feature selection criteria for
text classification applications. Information gain is based on information theory
principles. As its name implies, it measures how much information about the
class labels is gained when we observe the value of some feature. Let us return
to the spam classification example in Figure 9.1. Observing the value of the fea-
ture “cheap” provides us quite a bit of information with regard to the class labels.
If “cheap” occurs, then it is very likely that the label is “spam”, and if “cheap” does
not occur, then it is very likely that the label is “not spam”. In information theory,
entropy is the expected information contained in some distribution, such as the
class distribution P (c). Therefore, the information gain of some feature f mea-
sures how the entropy of P (c) changes after we observe f . Assuming a multiple-
Bernoulli event space, it is computed as follows:

IG(w) = H(C)?H(C|w)
= ?

?
c?C

P (c) logP (c) +
?

w?{0,1}

P (w)
?
c?C

P (c|w) logP (c|w)



9.1 Classification and Categorization 363

where H(C) is the entropy of P (c) and H(C|w) is known as the conditional
entropy. As an illustrative example, we compute the information gain for the term
“cheap” from our spam classification example:

IG(cheap) = ?P (spam) logP (spam)? P (spam) logP (spam) +
P (cheap)P (spam|cheap) logP (spam|cheap) +
P (cheap)P (spam|cheap) logP (spam|cheap) +
P (cheap)P (spam|cheap) logP (spam|cheap) +
P (cheap)P (spam|cheap) logP (spam|cheap)

= ? 3
10

log 3
10
? 7

10
log 7

10
+

4

10
· 3
4

log 3
4

+
4

10
· 1
4

log 1
4
+

6

10
· 0
6

log 0
6
+

6

10
· 6
6

log 6
6

= 0.2749

where P (cheap) is shorthand for P (cheap = 0), P (spam) means P (C =
not spam), and it is assumed that 0 log 0 = 0. The corresponding information
gains for “buy”, “banking”, “dinner”, and “the” are 0.0008, 0.0434, 0.3612, and 0.0,
respectively. Therefore, according to the information gain, “dinner” is the most
informative word, since it is a perfect predictor of “not spam” according to the
training set. On the opposite side of the spectrum, “the” is the worst predictor,
since it appears in every document and therefore has no discriminative power.

Similar information gain measures can be derived for other event spaces, such
as the multinomial event space. There are many different ways to use the infor-
mation gain to actually select features. However, the most common thing to do is
to select theK features with the largest information gain and train a model using
only those features. It is also possible to select a percentage of all features or use a
threshold.

Althoughmany other feature selection criteria exist, information gain tends to
be a good general-purpose feature selection criteria, especially for text-based clas-
sification problems. We provide pointers to several other feature selection tech-
niques in the “References and Further Reading” section at the end of this chapter.



364 9 Classification and Clustering

9.1.5 Spam, Sentiment, and Online Advertising

Although ranking functions are a very critical part of any search engine, classifica-
tion and categorization techniques also play an important role in various search-
related tasks. In this section, we describe several real-world text classification ap-
plications. These applications are spam detection, sentiment classification, and on-
line advertisement classification.

Spam, spam, spam

Classification techniques can be used to help detect and eliminate various types of
spam. Spam is broadly defined to be any content that is generated for malevolent
purposes,7 such as unsolicited advertisements, deceptively increasing the ranking
of a web page, or spreading a virus. One important characteristic of spam is that it
tends tohave little, if any, useful content.This definitionof spam is very subjective,
because what may be useful to one person may not be useful to another. For this
reason, it is often difficult to come up with an objective definition of spam.

There aremany types of spam, including email spam, advertisement spam, blog
spam, and web page spam. Spammers use different techniques for different types
of spam.Therefore, there is no one single spam classification technique thatworks
for all types of spam. Instead, very specialized spam classifiers are built for the
different types of spam, each taking into account domain-specific information.
Much has been written about email spam, and filtering programs such as Spam-
Assassin8 are in common use. Figure 9.7 shows the SpamAssassin output for an
example email. SpamAssassin computes a score for the email that is compared to
a threshold (default value 5.0) to determine whether it is spam.The score is based
on a combination of features, one of themost important of which is the output of
a Bayes classifier. In this case, the URL contained in the body of the email was on
a blacklist, the timestamp on the email is later than the time it was received, and
the Bayes classifier gives the email a 40–60% chance of being in the class “spam”
based on the words in themessage.These three features did not, however, give the
email a score over 5, so it was not classified as spam (which is a mistake).
7 The etymology of the word spam, with respect to computer abuse, is quite interesting.
The meaning is believed to have been derived from a 1970 Monty Python skit set in a
restaurant where everything on the menu has spam (the meat product) in it. A chorus
of Vikings begins singing a song that goes, “Spam, spam, spam, spam, ...” on and on,
therefore tying the word spam to repetitive, annoying behavior.

8 http://spamassassin.apache.org/



9.1 Classification and Categorization 365

To:  … 

From:  … 

Subject: non profit debt 

X!Spam!Checked: This message probably not SPAM 

X!Spam!Score: 3.853, Required: 5 

X!Spam!Level: *** (3.853) 

X!Spam!Tests: BAYES_50,DATE_IN_FUTURE_06_12,URIBL_BLACK 

X!Spam!Report!rig: !!!! Start SpamAssassin (v2.6xx!cscf) results 

  2.0 URIBL_BLACK            Contains an URL listed in the URIBL blacklist 

                             [URIs: bad!debtyh.net.cn] 

  1.9 DATE_IN_FUTURE_06_12   Date: is 6 to 12 hours after Received: date 

  0.0 BAYES_50               BODY: Bayesian spam probability is 40 to 60% 

                             [score: 0.4857] 

 

Say good bye to debt 

Acceptable Unsecured Debt includes All Major Credit Cards, No!collateral 

Bank Loans, Personal Loans,  

Medical Bills etc. 

http://www.bad!debtyh.net.cn 

 

Fig. 9.7. Example output of SpamAssassin email spam filter

Since this book focuses on search engines, we will devote our attention to web
page spam, which is one of the most difficult and widespread types of spam. De-
tecting web page spam is a difficult task, because spammers are becoming increas-
ingly sophisticated. It seems sometimes that the spammers themselves have ad-
vanced degrees in information retrieval!There aremany different ways that spam-
mers target web pages. Gyöngyi and Garcia-Molina (2005) proposed a web spam
taxonomy that attempts to categorize the differentwebpage spam techniques that
are often used to artificially increase the ranking of a page. The two top-level cat-
egories of the taxonomy are link spam and term spam.

With link spam, spammers use various techniques to artificially increase the
link-based scores of their web pages. In particular, search engines often use mea-
sures such as inlink count and PageRank, which are based entirely on the link
structure of theWeb, formeasuring the importance of aweb page.However, these
techniques are susceptible to spam. One popular and easy link spam technique
involves posting links to the target web page on blogs or unmoderated message
boards. Another way for a website to artificially increase its link-based score is to
join a link exchange network. Link exchange networks are large networks of web-



366 9 Classification and Clustering

sites that all connect to each other, thereby increasing the number of links coming
into the site. Another link spam technique is called link farming. Link farms are
similar to exchange networks, except the spammer himself buys a large number of
domains, creates a large number of sites, and then links them all together. There
are various other approaches, but these account for a large fraction of link spam.
A number of alternatives to PageRank have been proposed recently that attempt
to dampen the potential effect of link spam, including HostTrust (Gyöngyi et al.,
2004) and SpamRank (Benczúr et al., 2005).

The other top-level category of spam is term spam. Term spam attempts to
modify the textual representation of the document in order tomake itmore likely
to be retrieved for certain queries or keywords. As with link-based scores, term-
based scores are also susceptible to spam. Most of the widely used retrieval mod-
els, including BM25 and language modeling, make use of some formulation that
involves term frequency and document frequency. Therefore, by increasing the
term frequency of target terms, these models can easily be tricked into retrieving
non-relevant documents. Furthermore, most web ranking functions match text
in the incoming anchor text and the URL. Modifying the URL to match a given
term or phrase is easy. However, modifying the incoming anchor text requires
more effort, but can easily be done using link exchanges and link farms. Another
technique, called dumping, fills documents with many unrelated words (often an
entire dictionary). This results in the document being retrieved for just about any
query, since it contains almost every combination of query terms. Therefore, this
acts as a recall enhancingmeasure.This canbe combinedwith theother spamming
techniques, such as repetition, in order to have high precision as well as high re-
call. Phrase stitching (combining words and sentences from various sources) and
weaving (adding spam terms into a valid source such as a news story) are other
techniques for generating artificial content.All of these types of term spam should
be considered when developing a ranking function designed to prevent spam.

Figure 9.8 shows an example of awebpage containing spam.Thepage contains
both term spam with repetition of important words and link spam where related
spam sites are mentioned.

As should be apparent by now, there is an overwhelming number of types of
spam. Here, we simply focused on web page spam and did not even start to con-
sider the other types of spam. Indeed, it would be easy to write an entire book on
subjects related to spam. However, before we end our spam discussion, we will
describe just one of the many different ways that classification has been used to
tackle the problem of detecting web page spam.



9.1 Classification and Categorization 367

pro football sportsbooks nfl football line online nfl sportsbooks nfl football 

gambling odds online pro nfl betting pro nfl gambling online nfl football 

spreads offshore football gambling online nfl gamblibg spreads online 

football gambling line online nfl betting nfl sportsbook online online nfl

betting spreads betting nfl football online online football wagering online 

gambling online gambling football online nfl football betting odds offshore 

football sportsbook online nfl football gambling …

MVP Sportsbook Football Gambling Beverly Hills Football Sportsbook

Players SB Football Wagering Popular Poker Football Odds 

Virtual Bookmaker Football Lines V Wager Football Spreads 

Bogarts Casino Football Point Spreads Gecko Casino Online Football Betting 

Jackpot Hour Online Football Gambling MVP Casino Online Football Wagering 

Toucan Casino NFL Betting Popular Poker NFL Gambling 

All Tracks NFL Wagering Bet Jockey NFL Odds 

Live Horse Betting NFL Lines MVP Racebook NFL Point Spreads

Popular Poker NFL Spreads Bogarts Poker NFL Sportsbook …

Website:

Term spam:

Link spam:

B E T T I N G  N F L  F O O T B A L L  P R O  F O O T B A L L  
S P O R T S B O O K S  N F L  F O O T B A L L  L I N E  

O N L I N E  N F L  S P OR T S B O O K S  N F L   
Players Super Book  

When It Comes To Secure NFL Betting And Finding  
The Best Football Lines Players Super Book Is The 

Best Option! Sign Up And Ask For 30 % In Bonuses.  

MVP Sportsbook  

Football Betting Has Never been so easy and secure! 
MVP Sportsbook has all the NFL odds you are looking for.  

Sign Up Now and ask for up to  

30 % in Cash bonuses.  

Fig. 9.8. Example of web page spam, showing the main page and some of the associated
term and link spam



368 9 Classification and Clustering

Ntoulas et al. (2006) propose a method for detecting web page spam using
content (textual) analysis. The method extracts a large number of features from
each web page and uses these features in a classifier. Some of the features include
the number of words on the page, number of words in the title, average length of
the words, amount of incoming anchor text, and the fraction of visible text.These
features attempt to capture very basic characteristics of a web page’s text. Another
feature used is the compressibility of the page, which measures how much the
page can be reduced in size using a compression algorithm. It turns out that pages
that can be compressed more are much more likely to be spam, since pages that
containmany repeated terms andphrases are easier to compress.Thishas also been
shown to be effective for detecting email spam.The authors also use as features the
fraction of terms drawn from globally popular words9 and the fraction of globally
popular words appearing on the page. These features attempt to capture whether
or not the page has been filled with popular terms that are highly likely to match
a query term. The last two features are based on n-gram likelihoods. Experiments
show that pages that contain very rare and very common n-grams are more likely
to be spam than those pages that contain n-grams of average likelihood. All of
these features were used with a decision tree learning algorithm, which is another
type of supervised classification algorithm, and shown to achieve classification
accuracy well above 90%. The same features could easily be used in a Naïve Bayes
or Support Vector Machine classifier.

Sentiment

As we described in Chapter 6, there are three primary types of web queries. The
models described inChapter 7 focus primarily on informational and navigational
queries. Transactional queries, the third type, present many different challenges.
If a user queries for a product name, then the search engine should display a vari-
ety of information that goes beyond the standard ranked list of topically relevant
results. For example, if the user is interested in purchasing the product, then links
to online shopping sites can be provided to help the user complete her purchase.
It may also be possible that the user already owns the product and is searching for
accessories or enhancements. The search engine could then derive revenue from
the query by displaying advertisements for related accessories and services.

9 The list of “globally popular”words in this experimentwas simply theN most frequent
words in the test corpus.



9.1 Classification and Categorization 369

Another possible scenario, and the one that we focus on in detail here, is that
the user is researching the product in order to determine whether he should pur-
chase it. In this case, it would be valuable to retrieve information such as product
specifications, product reviews, and blog postings about the product. In order to
reduce the amount of information that the user needs to read through, it would be
preferable to have the system automatically aggregate all of the reviews and blog
posts in order to present a condensed, summarized view.

There are a number of steps involved with building such a system, each of
which involves some form of classification. First, when crawling and indexing
sites, the system has to automatically classify whether or not a web page contains
a review or if it is a blog posting expressing an opinion about a product. The task
of identifying opinionated text, as opposed to factual text, is called opinion de-
tection. After a collection of reviews and blog postings has been populated, an-
other classifier must be used to extract product names and their corresponding
reviews. This is the information extraction task. For each review identified for a
given product, yet another classifier must be used to determine the sentiment of
the page. Typically, the sentiment of a page is either “negative” or “positive”, al-
though the classifier may choose to assign a numeric score as well, such as “two
stars” or “four stars”. Finally, all of the data, including the sentiment, must be ag-
gregated and presented to the user in somemeaningful way. Figure 9.9 shows part
of an automatically generated product review from aweb service.This sentiment-
based summary of various aspects of the product, such as “ease of use”, “size”, and
“software”, is generated from individual user reviews.

Rather than go into the details of all of these different classifiers, we will focus
our attention on how sentiment classifiers work. As with our previous examples,
let us consider how a person would identify the sentiment of some piece of text.
For a majority of cases, we use vocabulary clues in order to determine the senti-
ment. For example, a positive digital camera review would likely contain words
such as “great”, “nice”, and “amazing”. On the other hand, negative reviews would
contain words such as “awful”, “terrible”, and “bad”. This suggests one possible so-
lution to the problem, where we build two lists. The first list will contain words
that are indicative of positive sentiment, and another list will contain words in-
dicative of negative sentiment. Then, given a piece of text, we could simply count
the number of positive words and the number of negative words. If there aremore
positive words, then assign the text a positive sentiment label. Otherwise, label it
as having negative sentiment. Even though this approach is perfectly reasonable, it
turns out that people are not very good at creating lists of words that indicate pos-



370 9 Classification and Clustering

All user reviews 

General Comments (148 comments) 

                                                                 82% positive 

Ease of Use (108 comments) 

                                                                78% positive 

Screen (92 comments) 

                                                                97% positive 

Software (78 comments) 

                                                                35% positive 

Sound Quality (59 comments) 

                                                                89% positive 

Size (59 comments) 

                                                               76% positive 

Fig. 9.9. Example product review incorporating sentiment

itive and negative sentiment. This is largely due to the fact that human language
is ambiguous and largely dependent on context. For example, the text “the digital
camera lacks the amazing picture quality promised” would likely be classified as
having positive sentiment because it contains two positive words (“amazing” and
“quality”) and only one negative word (“lacks”).

Pang et al. (2002) proposed using machine learning techniques for sentiment
classification. Various classifiers were explored, including Naïve Bayes, Support
Vector Machines, andmaximum entropy, which is another popular classification
technique. The features used in the classifiers were unigrams, bigrams, part-of-
speech tags, adjectives, and the position of a term within a piece of text. The au-
thors report that an SVMclassifier using only unigram features exhibited the best
performance, resulting inmore accurate results than a classifier trained using all of
the features. In addition, it was observed that the multiple-Bernoulli event space
outperformed the multinomial event space for this particular task. This is likely
caused by the fact that most sentiment-related terms occur only once in any piece
of text, and therefore term frequency adds very little to the model. Interestingly,
the machine learning models were significantly more accurate than the baseline
model that used human-generated word lists. The SVM classifier with unigrams



9.1 Classification and Categorization 371

had an accuracy of over 80%, whereas the baseline model had an accuracy of only
around 60%.

Classifying advertisements

As described in Chapter 6, sponsored search and content match are two differ-
ent advertising models widely used by commercial search engines. The former
matches advertisements to queries, whereas the latter matches advertisements to
web pages. Both sponsored search and content match use a pay per click pricing
model, which means that advertisers must pay the search engine only if a user
clicks on the advertisement. A user may click on an advertisement for a number
of reasons. Clearly, if the advertisement is “topically relevant,” which is the stan-
dard notion of relevance discussed in the rest of this book, then the usermay click
on it. However, this is not the only reason why a user may click. If a user searches
for “tropical fish”, she may click on advertisements for pet stores, local aquariums,
or even scuba diving lessons. It is less likely, however, that she would click on ad-
vertisements for fishing, fish restaurants, or mercury poisoning. The reason for
this is that the concept “tropical fish” has a certain semantic scope that limits the
type of advertisements a user may find interesting.

Although it is possible to use standard information retrieval techniques such
as query expansion or query reformulation analysis to find these semanticmatches
for advertising, it is also possible to use a classifier that maps queries (and web
pages) into semantic classes. Broder et al. (2007) propose a simple yet effective
technique for classifying textual items, such as queries and web pages, into a se-
mantic hierarchy. The hierarchy was manually constructed and consists of over
6,000 nodes, where each node represents a single semantic class. As one moves
deeper down the hierarchy, the classes becomemore specific.Human judgesman-
ually placed thousands of querieswith commercial intent into the hierarchy based
on each query’s intended semantic meaning.

Given such a hierarchy and thousands of labeled instances, there aremany pos-
sible ways to classify unseen queries or web pages. For example, one could learn a
Naïve Bayesmodel or use SVMs. Since there are over 6,000 classes, however, there
could be data sparsity issues, with certain classes having very few labeled instances
associated with them. A bigger problem, however, would be the efficiency of this
approach. BothNaïve Bayes and SVMswould be very slow to classify an item into
one of 6,000 possible classes. Since queries must be classified in real time, this is
not an option. Instead, Broder et al. propose using cosine similarity with tf.idf



372 9 Classification and Clustering

weighting tomatch queries (or web pages) to semantic classes. That is, they frame
the classification problem as a retrieval problem, where the query is the query (or
web page) to be classified and the document set consists of 6,000 “documents”,
one for each semantic class. For example, for the semantic class “Sports”, the “doc-
ument” for it would consists of all of the queries labeled as “Sports”. These “doc-
uments” are stored in an inverted index, which allows for efficient retrieval for
an incoming query (or web page). This can be viewed as an example of a nearest
neighbor classifier.

Rainbow Fish 

Resources

Web Page Ad

Fish

Aquariums

Supplies

Discount Tropical Fish Food

Feed your tropical fish a gourmet diet 

for just pennies a day!

www.cheapfishfood.com

Fig. 9.10.Example semantic classmatchbetween awebpage about rainbowfish (a type of
tropical fish) and an advertisement for tropical fish food. The nodes “Aquariums”, “Fish”,
and “Supplies” are example nodes within a semantic hierarchy. The web page is classified
as “Aquariums - Fish” and the ad is classified as “Supplies - Fish”. Here, “Aquariums” is the
least commonancestor.Although thewebpage and addonot share any terms in common,
they can be matched because of their semantic similarity.



9.2 Clustering 373

To use such a classifier in practice, one would have to preclassify every adver-
tisement in the advertising inventory. Then, when a new query (or web page) ar-
rives, it is classified. There are a number of ways to use the semantic classes to
improve matching. Obviously, if the semantic class of a query exactly matches the
semantic class of an advertisement, it should be given a high score.However, there
are other cases where two things may be very closely related, even though they do
not have exactly the same semantic class.Therefore, Broder et al. propose a way of
measuring the distance between two semantic classes within the hierarchy based
on the inverse of the least common ancestor of the two nodes in the hierarchy. A
common ancestor is a node in the hierarchy that you must pass through in order
to reach both nodes. The least common ancestor is the one with the maximum
depth in the hierarchy. The distance is 0 if the two nodes are the same and very
large if the the least common ancestor is the root node. Figure 9.10 shows an ex-
ample of how a web page can be semantically matched to an advertisement using
the hierarchy. In the figure, the least common ancestor of the web page and ad
classes is “Aquariums”, which is one node up the hierarchy. Therefore, this match
would be given a lower score than if both the web page and ad were classified into
the same node in the hierarchy. The full advertisement score can be computed by
combining this distance based on the hierarchy with the standard cosine similar-
ity score. In this way, advertisements are ranked in terms of both topical relevance
and semantic relevance.

9.2 Clustering

Clustering algorithms provide a different approach to organizing data.Unlike the
classification algorithms covered in this chapter, clustering algorithms are based
on unsupervised learning, whichmeans that they do not require any training data.
Clustering algorithms take a set of unlabeled instances and group (cluster) them
together. One problem with clustering is that it is often an ill-defined problem.
Classification has very clear objectives. However, the notion of a good clustering
is often defined very subjectively.

In order to gain more perspective on the issues involved with clustering, let us
examine how we, as humans, cluster items. Suppose, once again, that you are at a
grocery store and are asked to cluster all of the fresh produce (fruits and vegeta-
bles).Howwould you proceed? Before you began, youwould have to decidewhat
criteria you would use for clustering. For example, you could group the items by
their color, their shape, their vitamin C content, their price, or some meaningful



374 9 Classification and Clustering

combination of these factors. As with classification, the clustering criteria largely
depend on how the items are represented. Input instances are assumed to be a fea-
ture vector that represents some object, such as a document (or a fruit). If you are
interested in clustering according to some property, it is important to make sure
that property is represented in the feature vector.

After the clustering criteria have been determined, you would have to deter-
mine how you would assign items to clusters. Suppose that you decided to cluster
the produce according to color and you have created a red cluster (red grapes, red
apples) and a yellow cluster (bananas, butternut squash). What do you do if you
come across an orange? Do you create a new orange cluster, or do you assign it to
the redor yellowcluster?These are important questions that clustering algorithms
must address as well.These questions come in the form of howmany clusters to use
and how to assign items to clusters.

Finally, after you have assigned all of the produce to clusters, howdo you quan-
tify how well you did? That is, you must evaluate the clustering. This is often very
difficult, although there have been several automatic techniques proposed.

In this example, we have described clusters as being defined by some fixed set
of properties, such as the “red” cluster. This is, in fact, a very specific form of clus-
ter, called monothetic. We discussed monothetic classes or clusters in Chapter 6,
and mentioned that most clustering algorithms instead produce polythetic clus-
ters,wheremembers of a cluster sharemanyproperties, but there is no single defin-
ing property. In other words, membership in a cluster is typically based on the
similarity of the feature vectors that represent the objects. This means that a cru-
cial part of defining the clustering algorithm is specifying the similarity measure
that is used. The classification and clustering literature often refers to a distance
measure, rather than a similarity measure, and we use that terminology in the fol-
lowing discussion. Any similaritymeasure, which typically has a valueS from0 to
1, can be converted into a distance measure by using 1? S. Many similarity and
distance measures have been studied by information retrieval and machine learn-
ing researchers, from very simple measures such as Dice’s coefficient (mentioned
in Chapter 6) to more complex probabilistic measures.

The reader should keep these factors inmindwhile reading this section, as they
will be recurring themes throughout.The remainder of this sectiondescribes three
clustering algorithms based on different approaches, discusses evaluation issues,
and briefly describes clustering applications.



9.2 Clustering 375

9.2.1 Hierarchical andK-Means Clustering

Wewill now describe two different clustering algorithms that start with some ini-
tial clustering of the data and then iteratively try to improve the clustering by op-
timizing some objective function. The main difference between the algorithms is
the objective function. As we will show, different objective functions lead to dif-
ferent types of clusters.Therefore, there is no one “best” clustering algorithm.The
choice of algorithm largely depends on properties of the data set and task.

Throughout the remainder of this section, we assume that our goal is to cluster
some set ofN instances (which could be web pages, for example), represented as
feature vectors, intoK clusters, whereK is a constant that is fixed a priori.

Hierarchical clustering

Hierarchical clustering is a clustering methodology that builds clusters in a hier-
archical fashion. This methodology gives rise to a number of different clustering
algorithms.These algorithms are often “clustered” into two groups, depending on
how the algorithm proceeds.

Divisive clustering algorithms begin with a single cluster that consists of all of
the instances. During each iteration it chooses an existing cluster and divides it
into two (or possiblymore) clusters.This process is repeated until there are a total
of K clusters. The output of the algorithm largely depends on how clusters are
chosen and split.

Divisive clustering is a top-down approach. The other general type of hierar-
chical clustering algorithm is called agglomerative clustering, which is a bottom-up
approach. Figures 9.11 and 9.12 illustrate the difference between the two types
of algorithms. An agglomerative algorithm starts with each input as a separate
cluster. That is, it begins with N clusters, each of which contains a single input.
The algorithm then proceeds by joining two (or possibly more) existing clusters
to form a new cluster.Therefore, the number of clusters decreases after each itera-
tion.The algorithm terminateswhen there areK clusters. Aswith divisive cluster-
ing, the output of the algorithm is largely dependent on how clusters are chosen
and joined.

The hierarchy generated by an agglomerative or divisive clustering algorithm
can be conveniently visualized using a dendrogram.10 A dendrogram graphically
represents how a hierarchical clustering algorithm progresses. Figure 9.13 shows

10 From the Greek word dendron, meaning “tree.”



376 9 Classification and Clustering

F

A

C

E

B
G

D

F

A

C

E

B
G

D

F

A

C

E

B
G

D

F

A

C

E

B
G

D

Fig. 9.11. Example of divisive clustering with K = 4. The clustering proceeds from left
to right and top to bottom, resulting in four clusters.

the dendrogram that corresponds to generating the entire agglomerative cluster-
ing hierarchy for the points in Figure 9.12. In the dendrogram, points D and E
are first combined to form a new cluster calledH.Then, B andC are combined to
form cluster I. This process is continued until a single cluster M is created, which
consists of A, B, C, D, E, and F. In a dendrogram, the height at which instances
combine is significant and represents the similarity (or distance) value at which
the combination occurs. For example, the dendrogram shows that D and E are
the most similar pair.

Algorithm 1 is a simple implementation of hierarchical agglomerative clus-
tering.11 The algorithm takesN vectorsX1, . . . , XN , representing the instances,
and the desired number of clustersK as input. The array (vector)A is the assign-
ment vector. It is used to keep track of which cluster each input is associated with.
If A[i] = j, then it means that input Xi is in cluster j. The algorithm considers
joining every pair of clusters. For each pair of clusters (Ci, Cj), a costC(Ci, Cj)
is computed. The cost is some measure of how expensive it would be to merge

11 Often calledHAC in the literature.



9.2 Clustering 377

F

A

C

E

B

G

D

F

A

C

E

B

G

D

F

A

C

E

B

G

D

F

A

C

E

B

G

D

Fig. 9.12. Example of agglomerative clustering with K = 4. The clustering proceeds
from left to right and top to bottom, resulting in four clusters.

A D EB C F G

H

I

J

K

L

M

Fig. 9.13. Dendrogram that illustrates the agglomerative clustering of the points from
Figure 9.12



378 9 Classification and Clustering

Algorithm 1 Agglomerative Clustering
1: procedure A????????????C??????(X1, . . . , XN ,K)
2: A[1], . . . , A[N ]? 1, . . . , N
3: ids? {1, . . . , N}
4: for c = N toK do
5: bestcost??
6: bestclusterA? undefined
7: bestclusterB ? undefined
8: for i ? ids do
9: for j ? ids? {i} do

10: ci,j ? COST (Ci, Cj)
11: if ci,j < bestcost then
12: bestcost? ci,j
13: bestclusterA? i
14: bestclusterB ? j
15: end if
16: end for
17: end for
18: ids? ids? {bestClusterA}
19: for i = 1 toN do
20: if A[i] is equal to bestClusterA then
21: A[i]? bestClusterB
22: end if
23: end for
24: end for
25: end procedure

clusters Ci and Cj . We will return to how the cost is computed shortly. After all
pairwise costs have been computed, the pair of clusters with the lowest cost are
then merged. The algorithm proceeds until there areK clusters.

As shownbyAlgorithm1, agglomerative clustering largely depends on the cost
function.There aremany different ways to define the cost function, each of which
results in the final clusters having different characteristics. We now describe a few
of the more popular choices and the intuition behind them.

Single linkagemeasures the cost between clustersCi andCj by computing the
distance between every instance in clusterCi and every one inCj .The cost is then
theminimum of these distances, which can be stated mathematically as:



9.2 Clustering 379

COST (Ci, Cj) = min{dist(Xi, Xj)|Xi ? Ci, Xj ? Cj}

where dist is the distance between inputXi andXj . It is typically computed us-
ing the Euclidean distance12 between Xi and Xj , but many other distance mea-
sures have been used. Single linkage relies only on theminimumdistance between
the two clusters. It does not consider how far apart the remainder of the instances
in the clusters are. For this reason, single linkage could result in very “long” or
spread-out clusters, depending on the structure of the two clusters being com-
bined.

Complete linkage is similar to single linkage. It begins by computing the dis-
tance between every instance in cluster Ci and Cj . However, rather than using
theminimum distance as the cost, it uses themaximum distance. That is, the cost
is:

COST (Ci, Cj) = max{dist(Xi, Xj)|Xi ? Ci, Xj ? Cj}
Since themaximum distance is used as the cost, clusters tend to bemore compact
and less spread out than in single linkage.

Cluster A

Cluster B

Cluster C

Fig. 9.14. Examples of clusters in a graph formed by connecting nodes representing in-
stances. A link represents a distance between the two instances that is less than some
threshold value.

To illustrate the difference between single-link and complete-link clusters,
consider the graph shown in Figure 9.14.This graph is formed by representing in-
12 The Euclidean distance between two vectors x and y is computed according to??

i(xi ? yi)2 where the subscript i denotes the ith component of the vector.



380 9 Classification and Clustering

stances (i.e., the Xis) as nodes and connecting nodes where dist(Xi, Xj) < T ,
where T is some threshold value. In this graph, clusters A, B, and C would all
be single-link clusters. The single-link clusters are, in fact, the connected compo-
nents of the graph, where every member of the cluster is connected to at least one
other member. The complete-link clusters would be cluster A, the singleton clus-
ter C, and the upper and lower pairs of instances from cluster B. The complete-
link clusters are the cliques or maximal complete subgraphs of the graph, where
every member of the cluster is connected to every other member.

Average linkage uses a cost that is a compromise between single linkage and
complete linkage. As before, the distance between every pair of instances in Ci
and Cj is computed. As the name implies, average linkage uses the average of all
of the pairwise costs. Therefore, the cost is:

COST (Ci, Cj) =

?
Xi?Ci,Xj?Cj dist(Xi, Xj)

|Ci||Cj|

where |Ci| and |Cj| are the number of instances in clusters Ci and Cj , respec-
tively. The types of the clusters formed using average linkage depends largely on
the structure of the clusters, since the cost is based on the average of the distances
between every pair of instances in the two clusters.

Average group linkage is closely related to average linkage.The cost is computed
according to:

COST (Ci, Cj) = dist(µCi , µCj)

whereµC =
?

X?C X

|C| is the centroid of clusterCi.The centroid of a cluster is sim-
ply the average of all of the instances in the cluster. Notice that the centroid is also
a vector with the same number of dimensions as the input instances. Therefore,
average group linkage represents each cluster according to its centroid and mea-
sures the cost by the distance between the centroids. The clusters formed using
average group linkage are similar to those formed using average linkage.

Figure 9.15 provides a visual summary of the four cost functions described
up to this point. Specifically, it shows which pairs of instances (or centroids) are
involved in computing the cost functions for the set of points used in Figures 9.11
and 9.12.

Ward’s method is the final method that we describe. Unlike the previous costs,
which are based on various notions of the distance between two clusters, Ward’s
method is based on the statistical property of variance. The variance of a set of
numbers measures how spread out the numbers are. Ward’s method attempts to



9.2 Clustering 381

F

A

C

E

B
G

F

A

C

E

B
G

D

F

A

C

E

B
G

D

D

Single Linkage Complete Linkage

Average Linkage Average Group Linkage

?

?

?

?

Fig. 9.15. Illustration of how various clustering cost functions are computed

minimize the sum of the variances of the clusters. This results in compact clusters
with a minimal amount of spread around the cluster centroids. The cost, which
is slightly more complicated to compute than the previous methods, is computed
according to:

COST (Ci, Cj) =
?
k ?=i,j

?
X?Ck

(X ? µCk) · (X ? µCk) +?
X?Ci?Cj

(X ? µCi?Cj) · (X ? µCi?Cj)

whereCi?Cj is the union of the instances in clustersCi andCj , andµCi?Cj is the
centroid of the cluster consisting of the instances inCi ? Cj . This cost measures
what the intracluster variance would be if clusters i and j were joined.

So, which of the five agglomerative clustering techniques is the best? Once
again the answer depends on the data set and task the algorithm is being applied



382 9 Classification and Clustering

to. If the underlying structure of the data is known, then this knowledge may be
used tomake amore informed decision about the best algorithm to use. Typically,
however, determining the best method to use requires experimentation and eval-
uation. In the information retrieval experiments that have involved hierarchical
clustering, for example, average-link clustering has generally had the best effec-
tiveness. Even though clustering is an unsupervised method, in the end there is
still no such thing as a free lunch, and some form of manual evaluation will likely
be required.

Efficiency is a problem with all hierarchical clustering methods. Because the
computation involves the comparison of every instance to all other instances,
even the most efficient implementations areO(N2) for N instances. This limits
the number of instances that can be clustered in an application. The next cluster-
ing algorithm we describe, K-means, is more efficient because it produces a flat
clustering, or partition, of the instances, rather than a hierarchy.

K-means

The K-means algorithm is fundamentally different than the class of hierarchical
clustering algorithms just described. For example, with agglomerative clustering,
the algorithmbeginswithN clusters and iteratively combines two (ormore) clus-
ters together based on how costly it is to do so. As the algorithm proceeds, the
number of clusters decreases. Furthermore, the algorithm has the property that
once instancesXi andXj are in the same cluster as each other, there is no way for
them to end up in different clusters as the algorithm proceeds.

With the K-means algorithm, the number of clusters never changes. The al-
gorithm starts with K clusters and ends with K clusters. During each iteration
of the K-means algorithm, each instance is either kept in the same cluster or as-
signed to a different cluster. This process is repeated until some stopping criteria
is met.

The goal of the K-means algorithm is to find the cluster assignments, repre-
sented by the assignment vector A[1], . . . , A[N ], that minimize the following
cost function:

COST (A[1], . . . , A[N ]) =
K?
k=1

?
i:A[i]=k

dist(Xi, Ck)

where dist(Xi, Ck) is the distance between instanceXi and classCk. As with the
various hierarchical clustering costs, this distance measure can be any reasonable



9.2 Clustering 383

measure, although it is typically assumed to be the following:

dist(Xi, Ck) = ||Xi ? µCk ||2

= (Xi ? µCk) · (Xi ? µCk)

which is theEuclideandistance betweenXi andµCk squared.Here, as before,µCk
is the centroid of clusterCk.Notice that this distancemeasure is very similar to the
cost associated with Ward’s method for agglomerative clustering. Therefore, the
method attempts to find the clustering that minimizes the intracluster variance
of the instances.

Alternatively, the cosine similarity betweenXi andµCk can be used as the dis-
tancemeasure. As described inChapter 7, the cosine similaritymeasures the angle
between two vectors. For some text applications, the cosine similaritymeasure has
been shown to be more effective than the Euclidean distance. This specific form
ofK-means is often called sphericalK-means.

One of the most naïve ways to solve this optimization problem is to try every
possible combination of cluster assignments. However, for large data sets this is
computationally intractable, because it requires computing an exponential num-
ber of costs. Rather than finding the globally optimal solution, the K-means al-
gorithm finds an approximate, heuristic solution that iteratively tries tominimize
the cost.This solution returnedby the algorithm is not guaranteed tobe the global
optimal. In fact, it is not even guaranteed to be locally optimal. Despite its heuris-
tic nature, the algorithm tends to work very well in practice.

Algorithm 2 lists the pseudocode for one possibleK-means implementation.
The algorithm begins by initializing the assignment of instances to clusters. This
can be done either randomly or by using some knowledge of the data to make a
more informed decision. An iteration of the algorithm then proceeds as follows.
Each instance is assigned to the cluster that it is closest to, in terms of the distance
measure dist(Xi, Ck).The variable change keeps track of whether any of the in-
stances changed clusters during the current iteration. If some have changed, then
the algorithm proceeds. If none have changed, then the algorithm ends. Another
reasonable stopping criterion is to run the algorithm for some fixed number of
iterations.

In practice, K-means clustering tends to converge very quickly to a solution.
Even though it is not guaranteed to find the optimal solution, the solutions re-
turned are oftenoptimal or close to optimal.When compared to hierarchical clus-
tering,K-means is more efficient. Specifically, sinceKN distance computations



384 9 Classification and Clustering

Algorithm 2K-Means Clustering
1: procedure KM????C??????(X1, . . . , XN ,K)
2: A[1], . . . , A[N ]? initial cluster assignment
3: repeat
4: change? false
5: for i = 1 toN do
6: k? ? arg mink dist(Xi, Ck)
7: if A[i] is not equal k? then
8: A[i]? k?
9: change? true

10: end if
11: end for
12: until change is equal to false returnA[1], . . . , A[N ]
13: end procedure

are done in every iteration and the number of iterations is small, implementa-
tions of K-means areO(KN) rather than theO(N2) complexity of hierarchi-
cal methods. Although the clusters produced byK-means depend on the starting
points chosen (the initial clusters) and the ordering of the input data, K-means
generally produces clusters of similar quality to hierarchical methods. Therefore,
K-means is a good choice for an all-purpose clustering algorithm for a wide range
of search engine–related tasks, especially for large data sets.

9.2.2 K Nearest Neighbor Clustering

Even though hierarchical andK-means clustering are different from an algorith-
mic point of view, one thing that they have in common is the fact that both algo-
rithms place every input into exactly one cluster, whichmeans that clusters do not
overlap.13 Therefore, these algorithms partition the input instances intoK parti-
tions (clusters). However, for certain tasks, it may be useful to allow clusters to
overlap. One very simple way of producing overlapping clusters is calledK near-
est neighbor clustering. It is important to note that the K here is very different
from theK inK-means clustering, as will soon become very apparent.

13 Note that this is true for hierarchical clusters at a given level of the dendrogram (i.e., at
a given similarity or distance value). Clusters from different levels of the dendrogram
do overlap.



9.2 Clustering 385

B

D

D

B

B

A D

A

C

A

B D

B

D

C

C

C

C

AA

A

D

B
C

Fig. 9.16.Example of overlapping clustering using nearest neighbor clustering withK =
5. The overlapping clusters for the black points (A, B, C, and D) are shown. The five
nearest neighbors for each black point are shaded gray and labeled accordingly.

In K nearest neighbor clustering, a cluster is formed around every input in-
stance. For input instance x, theK points that are nearest to x according to some
distance metric and x itself form a cluster. Figure 9.16 shows several examples of
nearest neighbor clusters withK = 5 formed for the pointsA,B,C , andD. Al-
though the figure only shows clusters around four input instances, in reality there
would be one cluster per input instance, resulting inN clusters.

As Figure 9.16 illustrates, the algorithmoften fails to findmeaningful clusters.
In sparse areas of the input space, such as aroundD, the points assigned to cluster
D are rather far away and probably should not be placed in the same cluster as
D. However, in denser areas of the input space, such as around B, the clusters
are better defined, even though some related inputs may be missed because K is
not large enough. Applications that use K nearest neighbor clustering tend to
emphasize finding a small number of closely related instances in the K nearest
neighbors (i.e., precision) over finding all the closely related instances (recall).

K nearest neighbor clustering can be rather expensive, since it requires com-
puting distances between every pair of input instances. If we assume that com-
puting the distance between two input instances takes constant time with respect



386 9 Classification and Clustering

toK andN , then this computation takesO(N2) time. After all of the distances
have been computed, it takes at mostO(N2) time to find the K nearest neigh-
bors for each point. Therefore, the total time complexity forK nearest neighbor
clustering isO(N2), which is the same as hierarchical clustering.

For certain applications, K nearest neighbor clustering is the best choice of
clustering algorithm. The method is especially useful for tasks with very dense in-
put spaces where it is useful or important to find a number of related items for ev-
ery input. Examples of these tasks include language model smoothing, document
score smoothing, and pseudo-relevance feedback.Wedescribe how clustering can
be applied to smoothing shortly.

9.2.3 Evaluation

Evaluating the output of a clustering algorithm can be challenging. Since cluster-
ing is an unsupervised learning algorithm, there is often little or no labeled data
to use for the purpose of evaluation. When there is no labeled training data, it is
sometimes possible to use an objective function, such as the objective function
being minimized by the clustering algorithm, in order to evaluate the quality of
the clusters produced. This is a chicken and egg problem, however, since the eval-
uation metric is defined by the algorithm and vice versa.

If some labeled data exists, then it is possible to use slightly modified versions
of standard information retrieval metrics, such as precision and recall, to evaluate
the quality of the clustering. Clustering algorithms assign each input instance to
a cluster identifier. The cluster identifiers are arbitrary and have no explicit mean-
ing. For example, if we were to cluster a set of emails into two clusters, some of the
emails would be assigned to cluster identifier 1, while the rest would be assigned
to cluster 2. Not only do the cluster identifiers have no meaning, but the clusters
may not have ameaningful interpretation. For example, one would hope that one
of the clusters would correspond to “spam” emails and the other to “non-spam”
emails, but thiswill not necessarily be the case.Therefore, caremust be takenwhen
defining measures of precision and recall.

One common procedure of measuring precision is as follows. First, the algo-
rithm clusters the input instances intoK = |C| clusters.Then, for each clusterCi,
we define MaxClass(Ci) to be the (human-assigned) class label associated with
the most instances in Ci. Since MaxClass(Ci) is associated with more of the in-
stances in Ci than any other class label, it is assumed that it is the true label for
cluster Ci. Therefore, the precision for cluster Ci is the fraction of instances in



9.2 Clustering 387

the cluster with label MaxClass(Ci). This measure is often microaveraged across
instances, which results in the following measure of precision:

ClusterPrecision =

?K
i=1 |MaxClass(Ci)|

N

where |MaxClass(Ci)| is the total number of instances in clusterCi with the label
MaxClass(Ci). This measure has the intuitive property that if each cluster corre-
sponds to exactly one class label and every member of a cluster has the same label,
then the measure is 1.

In many search applications, clustering is only one of the technologies that are
being used. Typically, the output of a clustering algorithm is used as part of some
complex end-to-end system. In these cases, it is important to analyze and evaluate
how the clustering algorithm affects the entire end-to-end system. For example, if
clustering is used as a subcomponent of a web search engine in order to improve
ranking, then the clustering algorithm can be evaluated and tuned by measuring
the impact on the effectiveness of the ranking.This can be difficult, as end-to-end
systems are often complex and challenging to understand, and many factors will
impact the ranking.

9.2.4 How to ChooseK

Thus far, we have largely ignored how to chooseK . In hierarchical andK-means
clustering,K represents the number of clusters. InK nearest neighbors smooth-
ing, K represents the number of nearest neighbors used. Although these two
things are fundamentally different, it turns out that both are equally challenging
to set properly in a fully automated way.The problem of choosingK is one of the
most challenging issues involved with clustering, since there is really no good so-
lution. Nomagical formula exists that will predict the optimal number of clusters
to use in every possible situation. Instead, the best choice of K largely depends
on the task and data set being considered. Therefore, K is most often chosen ex-
perimentally.

In some cases, the application will dictate the number of clusters to use. This,
however, is rare. Most of the time, the application offers no clues as to the best
choice of K . In fact, even the range of values forK to try might not be obvious.
Should 2 clusters be used? 10? 100? 1,000? There is no better way of getting an
understanding of the best setting for K than running experiments that evaluate
the quality of the resulting clusters for various values ofK .



388 9 Classification and Clustering

Withhierarchical clustering, it is possible to create the entire hierarchy of clus-
ters and then use some decision mechanism to decide what level of the hiearchy
to use for the clustering. In most situations, however, the number of clusters has
to be manually chosen, even with hierarchical clustering.

B

B

B

C

B

B
C

C

C

A

A

D

B
C

Fig. 9.17. Example of overlapping clustering using Parzen windows. The clusters for the
black points (A, B, C, andD) are shown.The shaded circles indicate the windows used to
determine cluster membership. The neighbors for each black point are shaded gray and
labeled accordingly.

When forming K nearest neighbor clusters, it is possible to use an adaptive
value forK .That is, for instances in very dense regions, it may be useful to choose
a largeK , since the neighbors are likely to be related. Similarly, in very sparse ar-
eas, it may be best to choose only a very small number of nearest neighbors, since
moving too far away may result in unrelated neighbors being included. This idea
is closely related to Parzen windows,14 which are a variant ofK nearest neighbors
used for classification. With Parzen windows, the number of nearest neighbors
is not fixed. Instead, all of the neighbors within a fixed distance (“window”) of
an instance are considered its nearest neighbors. In this way, instances in dense

14 Named after Emanuel Parzen, an American statistician.



9.2 Clustering 389

areas will have many nearest neighbors, and those in sparse areas will have few.
Figure 9.17 shows the same set of points from Figure 9.16, but clustered using
a Parzen window approach. We see that fewer outliers get assigned to incorrect
clusters for points in sparse areas of the space (e.g., point C), whereas points in
denser regions havemore neighbors assigned to them (e.g., B). However, the clus-
ters formed are not perfect. The quality of the clusters now depends on the size
of the window. Therefore, although this technique eliminates the need to choose
K , it introduces the need to choose the window size, which can be an equally
challenging problem.

9.2.5 Clustering and Search

A number of issues with clustering algorithms have resulted in them being less
widely used in practice than classification algorithms. These issues include the
computational costs, as well as the difficulty of interpreting and evaluating the
clusters. Clustering has been used in a number of search engines for organizing
the results, as we discussed in section 6.3.3. There are very few results for a search
compared to the size of the document collection, so the efficiency of clustering is
less of a problem. Clustering is also able to discover structure in the result set for
arbitrary queries that would not be possible with a classification algorithm.

Topic modeling, which we discussed in section 7.6.2, can also be viewed as
an application of clustering with the goal of improving the ranking effectiveness
of the search engine. In fact, most of the information retrieval research involving
clustering has focused on this goal. The basis for this research is the well-known
cluster hypothesis. As originally stated by van Rijsbergen (1979), the cluster hy-
pothesis is:

Closely associated documents tend to be relevant to the same requests.
Note that this hypothesis doesn’t actually mention clusters. However, “closely as-
sociated” or similar documents will generally be in the same cluster. So the hy-
pothesis is usually interpreted as saying that documents in the same cluster tend
to be relevant to the same queries.

Two different tests have been used to verify whether the cluster hypothesis
holds for a given collection of documents. The first compares the distribution of
similarity scores for pairs of relevant documents (for a set of queries) to the dis-
tribution for pairs consisting of a non-relevant and a relevant document. If the
cluster hypothesis holds, we might expect to see a separation between these two
distributions. On some smaller corpora, such as the CACM corpus mentioned



390 9 Classification and Clustering

in Chapter 8, this is indeed the case. If there were a number of clusters of relevant
documents, however, which were not similar to each other, then this test may
fail to show any separation. To address this potential problem, Voorhees (1985)
proposed a test based on the assumption that if the cluster hypothesis holds, rel-
evant documents would have high local precision, even if they were scattered in
many clusters. Local precision simplymeasures thenumber of relevant documents
found in the top five nearest neighbors for each relevant document.

0.0 0.2 0.4 0.6 0.8 1.0

trec12

0.0 0.2 0.4 0.6 0.8 1.0

robust

0 0.2 0.4 0.6 0.8 1

trec12

Local Precision

Fr
eq

ue
nc

y

0

1000

2000

3000

4000

0 0.2 0.4 0.6 0.8 1

robust

Local Precision

Fr
eq

ue
nc

y

0

500

1000

1500

Fig. 9.18. Cluster hypothesis tests on two TREC collections. The top two compare
the distributions of similarity values between relevant-relevant and relevant-nonrelevant
pairs (light gray) of documents. The bottom two show the local precision of the relevant
documents.



9.2 Clustering 391

Figure 9.18 shows the results of these tests used on two TREC collections.
These collections have similar types of documents, including large numbers of
news stories. The 250 queries for the robust collection are known to be harder in
terms of the typical MAP values obtained than the 150 queries used for trec12.
The tests on the top row of the figure show that for both collections there is poor
separation between the distributions of similarity values. The tests on the lower
row, however, show that relevant documents in the trec12 collection have high
local precision. The local precision is lower in the robust collection, which means
that relevant documents tend to be more isolated and, consequently, harder to
retrieve.

Given that the cluster hypothesis holds, at least for some collections and
queries, the next question is how to exploit this in a retrieval model. There are,
in fact, a number of ways of doing this. The first approach, known as cluster-based
retrieval, ranks clusters instead of individual documents in response to a query. If
there were K clusters C1 . . . CK , for example, we could rank clusters using the
query likelihood retrieval model. This means that we rank clusters by P (Q|Cj),
whereQ is the query, and:

P (Q|Cj) =
n?

i=1

P (qi|Cj)

The probabilities P (qi|Cj) are estimated using a smoothed unigram language
model based on the frequencies of words in the cluster, as described for docu-
ments in Chapter 7. After the clusters have been ranked, documents within each
cluster could be individually ranked for presentation in a result list. The intuition
behind this ranking method is that a cluster language model should provide bet-
ter estimates of the importantword probabilities than document-based estimates.
In fact, a relevant document with no terms in common with the query could po-
tentially be retrieved if it were a member of a highly ranked cluster with other
relevant documents.

Rather than using this two-stage process, the cluster language model can be
directly incorporated into the estimation of the document language model as fol-
lows:

P (w|D) = (1? ?? ?)fw,D
|D|

+ ?
fw,Cj
|Cj|

+ ?
fw,Coll
|Coll|

where ? and ? are parameters, fw,D is the word frequency in the document D,
fw,Cj is the word frequency in the cluster Cj that contains D, and fw,Coll is the



392 9 Classification and Clustering

word frequency in the collection Coll. The second term, which comes from the
cluster language model, increases the probability estimates for words that occur
frequently in the cluster and are likely to be related to the topic of the document.
In other words, the cluster language model makes the document more similar to
other members of the cluster. This document language model with cluster-based
smoothing can be used directly by the query likelihood retrieval model to rank
documents as described in section 7.3.1.

The document language model can be further generalized to the case where
the documentD is a member of multiple overlapping clusters, as follows:

P (w|D) = (1? ?? ?)fw,D
|D|

+ ?
?
Cj

fw,Cj
|Cj|

P (D|Cj) + ?
fw,Coll
|Coll|

In this case, the second term in thedocument languagemodel probability estimate
for a word w is the weighted sum of the probabilities from the cluster language
models for all clusters.Theweight (P (D|Cj)) is the probability of the document
being a member of clusterCj . We can also make the simplifying assumption that
P (D|Cj) is uniform for those clusters that containD, and zero otherwise.

Retrieval experiments have shown that retrieving clusters can yield small but
variable improvements in effectiveness. Smoothing thedocument languagemodel
with cluster-based estimates, on the other hand, provides significant and consis-
tent benefits. In practice, however, the expense of generating clusters has meant
that cluster-based techniques have not been deployed as part of the ranking al-
gorithm in operational search engines. However, promising results have recently
been obtained using query-specific clustering, where clusters are constructed only
from the top-ranked (e.g., 50) documents (Liu & Croft, 2008; Kurland, 2008).
These clusters, which can be used for either cluster-based retrieval or document
smoothing, can obviously be generated much more efficiently.

References and Further Reading

Classification and clustering have been thoroughly investigated in the research ar-
eas of statistics, pattern recognition, andmachine learning.The books byDuda et
al. (2000) andHastie et al. (2001) describe a wide range of classification and clus-
tering techniques and provide more details about the mathematical foundations
the techniques are built upon. These books also provide good overviews of other



9.2 Clustering 393

useful machine learning techniques that can be applied to various search engine
tasks.

For a more detailed treatment of Naïve Bayes classification for text classifi-
cation, see McCallum and Nigam (1998). C. J. C. Burges (1998) gives a very de-
tailed tutorial on SVMs that covers all of the basic concepts and theory.However,
the subject matter is not light and requires a certain level of mathematical sophis-
tication to fully understand. In addition, Joachims (2002a) is an entire book de-
scribing various uses of SVMs for text classification.

Van Rijsbergen (1979) provides a review of earlier research on clustering in
information retrieval, and describes the cluster hypothesis and cluster-based re-
trieval.Diaz (2005) proposed an alternative interpretation of the cluster hypothe-
sis by assuming that closely related documents should have similar scores, given the
same query. Using this assumption, Diaz developed a framework for smoothing
retrieval scores using properties ofK nearest neighbor clusters. Language model-
ing smoothing usingK-means clustering was examined in Liu and Croft (2004).
Another language modeling smoothing technique based on overlappingK near-
est neighbor clusters was proposed in Kurland and Lee (2004).

There are various useful software packages available for text classification. The
Mallet software toolkit15 provides implementations of various machine learning
algorithms, including Naïve Bayes, maximum entropy, boosting, Winnow, and
conditional random fields. It also provides support for parsing and tokenizing
text into features. Another popular software package is SVMLight,16 which is an
SVM implementation that supports all of the kernels described in this chapter.
Clustering methods are included in a number of packages available on the Web.

Exercises

9.1. Provide an example of howpeople use clustering in their everyday lives.What
are the features that they use to represent the objects?What is the similarity mea-
sure? How do they evaluate the outcome?

9.2. Assume we want to do classification using a very fine-grained ontology, such
as one describing all the families of human languages. Suppose that, before train-
ing, we decide to collapse all of the labels corresponding to Asian languages into a
single “Asian languages” label. Discuss the negative consequences of this decision.
15 http://mallet.cs.umass.edu/
16 http://svmlight.joachims.org/



394 9 Classification and Clustering

9.3. Suppose that we were to estimate P (d|c) according to:

P (d|c) = Nd,c
Nc

whereNd,c is the number of times document d is assigned to class c in the training
set, andNc is the number of instances assigned class label c in the training set.This
is analogous to the way thatP (c) is estimated.Why can this estimate not be used
in practice?

9.4. For some classification data set, compute estimates for P (w|c) for all words
w usingboth themultiple-Bernoulli andmultinomialmodels.Compare themultiple-
Bernoulli estimates with the multinomial estimates. How do they differ? Do the
estimates diverge more for certain types of terms?

9.5. Explainwhy the solution to theoriginal SVMformulationw = arg maxw 2||w||
is equivalent to the alternative formulationw = arg minw 12 ||w||

2.

9.6. Compare the accuracy of a one versus all SVM classifier and a one versus
one SVM classifier on a multiclass classification data set. Discuss any differences
observed in terms of the efficiency and effectiveness of the two approaches.

9.7. Under what conditions will the microaverage equal the macroaverage?

9.8. Cluster the following set of two-dimensional instances into three clusters us-
ing each of the five agglomerative clustering methods:

(–4, –2), (–3, –2), (–2, –2), (–1, –2), (1, –1), (1, 1), (2, 3), (3, 2), (3, 4), (4, 3)

Discuss the differences in the clusters across methods. Which methods pro-
duce the same clusters? How do these clusters compare to how you would manu-
ally cluster the points?

9.9. Use K-means and spherical K-means to cluster the data points in Exercise
9.8. How do the clusterings differ?

9.10. Nearest neighbor clusters are not symmetric, in the sense that if instanceA
is one of instanceB’s nearest neighbors, the reverse is not necessarily true. Explain
how this can happen with a diagram.



9.2 Clustering 395

9.11. The K nearest neighbors of a document could be represented by links to
those documents. Describe twoways this representation could be used in a search
application.

9.12. Can theClusterPrecision evaluation metric ever be equal to zero? If so, pro-
vide an example. If not, explain why.

9.13. Test the cluster hypothesis on the CACM collection using both methods
shown in Figure 9.18. What do you conclude from these tests?





10
Social Search

“You will be assimilated.”

Borg Collective, Star Trek: First Contact

10.1 What Is Social Search?

In this chapter we will describe social search, which is rapidly emerging as a key
search paradigm on the Web. As its name implies, social search deals with search
within a social environment. This can be defined as an environment where a com-
munity of users actively participate in the search process. We interpret this defi-
nition of social search very broadly to include any application involving activities
such as defining individual user profiles and interests, interactingwith other users,
and modifying the representations of the objects being searched. The active role
of users in social search applications is in stark contrast to the standard search
paradigms and models, which typically treat every user the same way and restrict
interactions to query formulation.

Users may interact with each other online in a variety of ways. For example,
users may visit a social media site,1 which have recently gained a great deal of
popularity. Examples of these sites include Digg (websites), Twitter (status mes-
sages), Flickr (pictures), YouTube (videos), Del.icio.us (bookmarks), and CiteU-
Like (research papers). Social networking sites, such as MySpace, Facebook, and
LinkedIn, allow friends, colleagues, and people with similar interests to interact
with each other in various ways. More traditional examples of online social in-
teractions include email, instant messenger, massively multiplayer online games
(MMOGs), forums, and blogs.

1 Social media sites are often collectively referred to as Web 2.0, as opposed to the clas-
sical notion of the Web (“Web 1.0”), which consists of non-interactive HTML docu-
ments.



398 10 Social Search

As we see, the online world is a very social environment that is rich with users
interacting with each other in various forms. These social interactions provide
new and unique data resources for search systems to exploit, as well as a myriad
of privacy issues. Most of the web search approaches we described in Chapter 7
only consider features of the documents or the link structure of the Web. In so-
cially rich environments, however, we also have a plethora of user interaction data
available that can help enhance the overall user experience in new and interesting
ways.

It would be possible to write an entire book on online social interactions and
search within such environments. The focus of this chapter is to highlight and
describe a fewaspects of social search that are particularly interesting froma search
engine and information retrieval perspective.

The first topic we cover is user tags. Many social media websites allow users to
assign tags to items. For example, a video-sharing website may allow users to not
only assign tags to their own videos, but also to videos created by other people.
An underwater video, for example, may have the tags “swimming”, “underwater”,
“tropic”, and “fish”. Some sites allow multi-term tags, such as “tropical fish”, but
others allowonly single-term tags.Aswewill describe, user tags are a formofman-
ual indexing, where the content of an object is represented by manually assigned
terms. There are many interesting search tasks related to user tags, such as search-
ing for items using tags, automatically suggesting tags, and visualizing clusters of
tags.

The second topic covered here is searching within communities, which de-
scribes online communities and how users search within such environments. On-
line communities are virtual groups of users that share common interests and in-
teract socially in various ways in an online environment. For example, a sports fan
who enjoys the outdoors and photography may be a member of baseball, hiking,
and digital camera communities. Interactions in these communities range from
passive activities (reading web pages) to those that are more active (writing in
blogs and forums). These communities are virtual and ad hoc, meaning that there
is typically no formalmechanism for joining one, and consequently people are im-
plicitly rather than explicitly members of a community. Therefore, being able to
automatically determine which communities exist in an online environment, and
which users are members of each, can be valuable for a number of search-related
tasks. One such task that we will describe is community-based question answer-
ing, whereby a user posts a question to an online system and members of his own
community, or the community most related to his question, provide answers to



10.1 What Is Social Search? 399

the question. Such a search task ismuchmore social, interactive, and focused than
standard web search.

The next topics we describe are filtering and recommender systems. It may be
considered somewhat unusual to include these in a chapter on social search, be-
cause they are not typical “Web 2.0” applications. Both types of systems, however,
rely on representations of individual users called profiles, and for that reason fit
into our broad definition. Both systems also combine elements of document re-
trieval and classification. In standard search tasks, systems return documents in
response to many different queries. These queries typically correspond to short-
term information needs. In filtering, there is a fixed query (the profile) that rep-
resents some long-term information need. The search system monitors incoming
documents and retrieves only those documents that are relevant to the informa-
tion need. Many online news websites provide document filtering functionality.
For example,CNNprovides an alerts service,which allowsusers to specify various
topics of interest, such as “tropical storms”, or more general topics, such as sports
or politics. When a new story matches a user’s profile, the system alerts the user,
typically via email. In this way, the user does not need to continually search for
articles of interest. Instead, the search system is taskedwith finding relevant docu-
ments that match the user’s long-term information needs. Recommender systems
are similar to document filtering systems, except the goal is to predict how a user
would rate some item, rather than retrieving relevant documents. For example,
Amazon.com employs a recommender system that attempts to predict howmuch
a user would like certain items, such as books, movies, or music. Recommender
systems are social search algorithms because predictions are estimated based on
ratings given by similar users, thereby implicitly linking people to a community
of users with related interests.

The final two topics covered in this chapter, peer-to-peer (P2P) search and
metasearch, deal with architectures for social search. Peer-to-peer search is the
task of querying a community of “nodes” for a given information need. Nodes
can be individuals, organizations, or search engines.When a user issues a query, it
is passed through theP2Pnetwork and runononeormorenodes, and then results
are returned. This type of search can be fully distributed across a large network of
nodes. Metasearch is a special case of P2P search where all of the nodes are search
engines. Metasearch engines run queries against a number of search engines, col-
lect the results, and then merge the results. The goal of metasearch engines is to
provide better coverage and accuracy than a single search engine.



400 10 Social Search

Finally, we note that personalization is another area that could be regarded as
part of social search, because it covers a range of techniques for improving search
by representing individual user preferences and interests. Sincemost of these tech-
niques provide context for the query, however, they were discussed as part of
query refinement in section 6.2.5.

10.2 User Tags and Manual Indexing

Before electronic search systems became available at libraries, patrons had to rely
on card catalogs for finding books. As their name implies, card catalogs are large
collections (catalogs) of cards. Each card contains information about a particular
author, title, or subject. A person interested in a specific author, title, or subject
would go to the appropriate catalog and attempt to find cards describing relevant
books. The card catalogs, therefore, act as indexes to the information in a library.

Card catalogs existed long before computers did, whichmeans that these cards
were constructed manually. Given a book, a person had to extract the author, ti-
tle, and subject headings of the book so that the various catalogs could be built.
This process is known as manual indexing. Given that it is impractical to manu-
ally index the huge collections of digital media available today, search engines use
automatic indexing techniques to assign identifiers (terms, phrases, features) to
documents during index construction. Since this process is automatic, the quality
and accuracy of the indexing canbemuch lower than that ofmanual indexing.The
advantages of automatic indexing, however, are that it is exhaustive, in the sense
that every word in the document is indexed and nothing is left out, and consistent,
whereas people canmakemistakes indexing or have certain biases in how they in-
dex. Search evaluations that have compared manual to automatic indexing have
found that automatic indexing is at least as effective and often much better than
manual indexing. These studies have also shown, however, that the two forms of
indexing complement each other, and that the most effective searches use both.

As a compromise between manually indexing every item (library catalogs)
and automatically indexing every item (search engines), social media sites pro-
vide users with the opportunity to manually tag items. Each tag is typically a sin-
gle word that describes the item. For example, an image of a tiger may be assigned
the tags “tiger”, “zoo”, “big”, and “cat”. By allowing users to assign tags, some items
end upwith tags, and others do not.Of course, tomake every item searchable, it is
likely that every item is automatically indexed.Therefore, some items will contain



10.2 User Tags and Manual Indexing 401

both automatic and manual identifiers. As we will show later in this section, this
results in unique challenges for retrieval models and ranking functions.

Social media tagging, like card catalog generation, is called manual tagging.
This clash in naming is rather unfortunate, because the two types of indexing
are actually quite different. Card catalogs are manually generated by experts who
choose keywords, categories, and other descriptors from a controlled vocabulary
(fixed ontology). This ensures that the descriptors are more or less standardized.
On the other hand, social media tagging is done by end users who may or may
not be experts. There is little-to-no quality control done on the user tags. Fur-
thermore, there is no fixed vocabulary fromwhich users choose tags. Instead, user
tags form their own descriptions of the important concepts and relationships in
a domain. User-generated ontologies (or taxonomies) are known as folksonomies.
Therefore, a folksonomy can be interpreted as a dynamic, community-influenced
ontology.

There has been a great deal of research and interest invested in developing a
semantically tagged version of the Web, which is often called the semantic web.
The goal of the semantic web is to semantically tag web content in such a way
that it becomes possible to find, organize, and share information more easily. For
example, a news article could be tagged with metadata, such as the title, subject,
description, publisher, date, and language. However, in order for the semantic
web to materialize and yield significant improvements in relevance, a standard-
ized, fixed ontology of metadata tags must be developed and used consistently
across a large number of web pages. Given the growing popularity of social media
sites that are based on flexible, user-driven folksonomies, compared to the small
number of semantic web sites that are based on rigid, predefined ontologies, it
seems as though users, in general, are more open to tagging data with a relatively
unrestricted set of tags that are meaningful to them and that reflect the specific
context of the application.

Given that users are typically allowed to tag items in any way that they wish,
there aremanydifferent types of tags. For example,Golder andHuberman (2006)
described seven different categories of tags. Z. Xu et al. (2006) proposed a sim-
plified set of five tag categories, which consists of the following:

1. Content-based tags. Tags describing the content of an item. Examples: “car”,
“woman”, and “sky”.

2. Context-based tags. Tags that describe the context of an item. Examples:
“New York City” or “Empire State Building”.



402 10 Social Search

3. Attribute tags. Tags that describe implicit attributes of the item. Examples:
“Nikon” (type of camera), “black and white” (type of movie), or “homepage”
(type of web page).

4. Subjective tags. Tags that subjectively describe an item. Examples: “pretty”,
“amazing”, and “awesome”.

5. Organizational tags. Tags that help organize items. Examples: “todo”, “my pic-
tures”, and “readme”.

As we see, tags can be applied to many different types of items, ranging from web
pages to videos, andused formanydifferent purposes beyond just tagging the con-
tent. Therefore, tags and online collaborative tagging environments can be very
useful tools for users in terms of searching, organizing, sharing, and discovering
new information. It is likely that tags are here to stay and will become even more
widely used in the future. Therefore, it is important to understand the various
issues surrounding them and how they are used within search engines today.

In the remainder of this section, we will describe how tags can be used for
search, how new tags for an item can be inferred from existing tags, and how sets
of tags can be visualized and presented to the user.

10.2.1 Searching Tags

Since this is a book about search engines, the first tag-related task that we discuss
is searching a collection of collaboratively tagged items. One unique property of
tags is that they are almost exclusively textual keywords that are used to describe
textual or non-textual items. Therefore, tags can provide a textual dimension to
items that do not explicitly have a simple textual representation, such as images
or videos. These textual representations of non-textual items can be very useful
for searching. We can apply many of the retrieval strategies described in Chap-
ter 7 to the problem. Despite the fact that searching within tagged collections
can be mapped to a text search problem, tags present certain challenges that are
not present when dealing with standard document or web retrieval.

The first challenge, and by far the most pervasive, is the fact that tags are
very sparse representations of very complex items. Perhaps the simplest way to
search a set of tagged items is to use a Boolean retrieval model. For example, given
the query “fish bowl”, one could run the query “fish AND bowl”, which would
only return items that are tagged with both “fish” and “bowl”, or “fish OR bowl”,
which would return items that are tagged with either “fish” or “bowl”. Conjunc-
tive (AND) queries are likely to produce high-quality results, but may miss many



10.2 User Tags and Manual Indexing 403

relevant items. Thus, the approach would have high precision but low recall. At
the opposite end of the spectrum, the disjunctive (OR) queries will match many
more relevant items, but at the cost of precision.

Age of Aquariums - Tropical Fish 

Huge educational aquarium site for tropical fish hobbyists, promoting 

responsible fish keeping internationally since 1997.

The Krib (Aquaria and Tropical Fish) 

This site contains information about tropical fish aquariums, including 

archived usenet postings and e-mail discussions, along with new ...

…

Keeping Tropical Fish and Goldfish in Aquariums, Fish Bowls, and ... 

Keeping Tropical Fish and Goldfish in Aquariums, Fish Bowls, and 

Ponds at AquariumFish.net.

fi
sh

tr
o
p
ic
a
l

a
q
u
a
ri
u
m
s

g
o
ld
fi
sh

b
o
w
ls

P(w | “tropical fish” )

Fig. 10.1. Search results used to enrich a tag representation. In this example, the tag being
expanded is “tropical fish”.The query “tropical fish” is run against a search engine, and the
snippets returned are then used to generate a distribution over related terms.

Of course, it is highly desirable to achieve both high precision and high re-
call. However, doing so is very challenging. Consider the query “aquariums” and
a picture of a fish bowl that is tagged with “tropical fish” and “goldfish”. Most re-
trieval models, including Boolean retrieval, will not be able to find this item, be-
cause there is no overlap between the query terms and the tag terms.This problem,
which was described in Chapter 6 in the context of advertising, is known as the
vocabulary mismatch problem. There are various ways to overcome this problem,
including simple things such as stemming. Other approaches attempt to enrich
the sparse tag (or query) representation by performing a formof pseudo-relevance



404 10 Social Search

feedback. Figure 10.1 illustrates how web search results may be used to enrich a
tag representation. In the example, the tag “tropical fish” is run as a query against
a search engine. The snippets returned are then processed using any of the stan-
dard pseudo-relevance feedback techniques described in section 7.3.2, such as rel-
evance modeling, which forms a distribution over related terms. In this example,
the terms “fish”, “tropical”, “aquariums”, “goldfish”, and “bowls” are the terms with
the highest probability according to the model. The query can also, optionally,
be expanded in the same way. Search can then be done using the enriched query
and/or tag representations in order to maintain high levels of precision as well as
recall.

The second challenge is that tags are inherently noisy. As we have shown,
tags can provide useful information about items and help improve the quality
of search. However, like anything that users create, the tags can also be off topic,
inappropriate,misspelled, or spam.Therefore it is important to provide proper in-
centives to users to enter many high-quality tags. For example, it may be possible
to allowusers to report inappropriate or spam tags, thereby reducing the incentive
to produce junk tags. Furthermore, users may be given upgraded or privileged ac-
cess if they enter some number of (non-spam) tags over a given time period. This
incentive promotes more tagging, which can help improve tag quality and cover-
age.

The final challenge is that many items in a given collection may not be tagged,
which makes them virtually invisible to any text-based search system. For such
items, it would be valuable to automatically infer themissing tags and use the tags
for improving search recall. We devote the next section to diving deeper into the
details of this problem.

10.2.2 Inferring Missing Tags

As we just described, items that have no tags pose a challenge to a search sys-
tem.Althoughprecision is obviously a very importantmetric formany tag-related
search tasks, recall may also be important in some cases. In such cases, it is impor-
tant to automatically infer a set of tags for items that have nomanual tags assigned
to them.

Let us first consider the case when the items in our collection are textual, such
as books, news articles, research papers, or web pages. In these cases, it is possible
to infer tags based solely on the textual representation of the item. One simple
approach would involve computing someweight for every term that occurs in the



10.2 User Tags and Manual Indexing 405

text and then choosing theK terms with the highest weight as the inferred tags.
There are various measures of term importance, including a tf.idf -based weight,
such as:

wt(w) = log(fw,D + 1) log(
N

dfw
)

where fw,d is the number of times term w occurs in itemD,N is the total num-
ber of items, and dfw is the number of items that term w occurs in. Other term
importance measures may take advantage of document structure. For example,
terms that occur in the title of an item may be given more weight.

It is also possible to treat the problem of inferring tags as a classification prob-
lem, as was recently proposed by Heymann, Ramage, and Garcia-Molina (2008).
Given a fixed ontology or folksonomy of tags, the goal is to train a binary classifier
for each tag. Each of these classifiers takes an item as input and predicts whether
the associated tag should be applied to the item. This approach requires training
one classifier for every tag, which can be a cumbersome task and requires a large
amount of training data. Fortunately, however, training data for this task is virtu-
ally free since users are continuously tagging (manually labeling) items!Therefore,
it is possible to use all of the existing tag/item pairs as training data to train the
classifiers. Heymann et al. use an SVM classifier to predict web page tags. They
compute a number of features, including tf.idf weights for terms in the page text
and anchor text, as well as a number of link-based features. Results show that high
precision and recall can be achieved by using the textual features alone, especially
for tags that occur many times in the collection. A similar classification approach
can be applied to other types of items, such as images or videos. The challenge
when dealing with non-textual items is extracting useful features from the items.

The two approaches we described for inferring missing tags choose tags for
items independently of the other tags that were assigned. This may result in very
relevant, yet very redundant, tags being assigned to some item. For example, a
picture of childrenmay have the tags “child”, “children”, “kid”, “kids”, “boy”, “boys”,
“girl”, “girls”—all of whichwould be relevant, but as you see, are rather redundant.
Therefore, it is important to choose a set of tags that are both relevant and non-
redundant. This is known as the novelty problem.

Carbonell and Goldstein (1998) describe the Maximal Marginal Relevance
(MMR) technique,which addresses the problemof selecting a diverse set of items.
Rather than choosing tags independently of each other, MMR chooses tags iter-
atively, adding one tag to the item at a time. Given an item i and the current set
of tags for the item Ti, theMMR technique chooses the next tag according to the



406 10 Social Search

tag t that maximizes:

MMR(t;Ti) =

(
?Simitem(t, i)? (1? ?)max

t?Ti
Simtag(ti, t)

)
where Simitem is a function that measures that similarity between a tag t and
item i (such as those measures described in this section), Simtag measures the
similarity between two tags (such as the measures described in section 10.2.1),
and ? is a tunable parameter that can be used to trade off between relevance (? =
1) and novelty (? = 0). Therefore, a tag that is very relevant to the item and
not very similar to any of the other tags will have a large MMR score. Iteratively
choosing tags in this way helps eliminate the production of largely redundant sets
of tags, which is useful not only when presenting the inferred tags to the user, but
also from the perspective of using the inferred tags for search, since a diverse set
of tags should help further improve recall.

10.2.3 Browsing and Tag Clouds

As we have shown, tags can be used for searching a set of collaboratively tagged
items. However, tags can also be used to help users browse, explore, and discover
new items in a large collection of items. There are several different ways that tags
can be used to aid browsing. For example, when a user is viewing a given item,
all of the item’s tags may be displayed. The user may then click on one of the tags
and be shown a list of results of items that also have that tag. The user may then
repeat this process, repeatedly choosing an item and then clicking on one of the
tags. This allows users to browse through the collection of items by following a
chain of related tags.

Such browsing behavior is very focused and does not really allow the user to
explore a large range of the items in the collection. For example, if a user starts
on a picture of a tropical fish, it would likely take many clicks for the user to end
up viewing an image of an information retrieval textbook. Of course, this may be
desirable, especially if the user is only interested in things closely related to tropical
fish.

One way of providing the user with a more global view of the collection is to
allow the user to view the most popular tags. These may be the most popular tags
for the entire site or for a particular group or category of items. Tag popularity
may be measured in various ways, but is commonly computed as the number of
times the tag has been applied to some item. Displaying the popular tags allows



10.2 User Tags and Manual Indexing 407

the user to begin her browsing and exploration of the collection using one of these
tags as a starting point.

animals architecture art australia autumn baby band barcelona beach berlin
birthday black blackandwhite blue california cameraphone canada canon
car cat chicago china christmas church city clouds color concert day dog

england europe family festival film florida flower flowers food
france friends fun garden germany girl graffiti green halloween hawaii
holiday home house india ireland italy japan july kids lake landscape light live
london macro me mexico music nature new newyork night

nikon nyc ocean paris park party people portrait red river rock
sanfrancisco scotland sea seattle show sky snow spain spring street

summer sunset taiwan texas thailand tokyo toronto travel

tree trees trip uk usa vacation washington water wedding

Fig. 10.2.Example of a tag cloud in the formof aweighted list.The tags are in alphabetical
order and weighted according to some criteria, such as popularity.

Thus far we have described ways that tags may aid users with browsing. One of
the most important aspects of browsing is displaying a set of tags to a user in a vi-
sually appealing andmeaningful manner. For example, consider displaying the 50
most popular tags to the user. The simplest way to do so is to just display the tags
in a list or table, possibly in alphabetical or sorted order according to popularity.
Besides not being very visually appealing, this display also does not allow the user
to quickly observe all of the pertinent information. When visualizing tags, it is
useful to show the list of tags in alphabetical order, so that users may quickly scan
through the list or find the tags they are looking for. It is also beneficial to por-
tray the popularity or importance of a given tag. There are many ways to visualize
this information, but one of the most widely used techniques is called tag clouds.
In a tag cloud, the display size of a given tag is proportional to its popularity or
importance. Tags may be arranged in a random order within a “cloud” or alpha-
betically. Figure 10.2 shows an example of a tag cloud where the tags are listed
alphabetically. Such a representation is also called a weighted list. Based on this



408 10 Social Search

tag cloud, the user can easily see that the tags “wedding”, “party”, and “birthday”
are all very popular.Therefore, tag clouds provide a convenient, visually appealing
way of representing a set of tags.

10.3 Searching with Communities

10.3.1 What Is a Community?

The collaborative tagging environments that we just described are filled with im-
plicit social interactions. By analyzing the tags that users submit or search for, it is
possible to discover groups of users with related interests. For example, ice hockey
fans are likely to tag pictures of their favorite ice hockey players, tag their favorite
ice hockeyweb pages, search for ice hockey–related tags, and so on. Tagging is just
one example of how interactions in an online environment can be used to infer
relationships between entities (e.g., people). Groups of entities that interact in an
online environment and that share common goals, traits, or interests are an online
community.This definition is not all that different from the traditional definition
of community. In fact, online communities are actually very similar to traditional
communities and sharemany of the same social dynamics.The primary difference
between our definition and that of a traditional community is that an online com-
munity can bemade up of users, organizations, web pages, or just about any other
meaningful online entity.

Let us return to our example of userswho tag and search for ice hockey–related
items. It is easy to see that ice hockey fans form an online community. Members
of the community do many other things other than tag and search. For example,
they also post to blogs, newsgroups, and other forums.Theymay also send instant
messages and emails to other members of the community about their ice hockey
experiences. Furthermore, they may buy and sell ice hockey–related items online,
through sites such as eBay. Hence, there are many ways that a user may partici-
pate in a community. It is important to note, however, that his membership in
the community is implicit. Another important thing to notice is that users are
very likely to have a number of hobbies or interests, andmay bemembers of more
than one online community.Therefore, in order to improve the overall user expe-
rience, it can be useful for search engines and other online sites to automatically
determine the communities associated with a given user.

Some online communities consist of non-human entities. For example, a set of
web pages that are all on the same topic form an online community that is often



10.3 Searching with Communities 409

called a web community. These pages form a community since they share similar
traits (i.e., they are all about the same topic). Since web pages are created by users,
web communities share many of the same characteristics as communities of users.
Automatically identifying web communities can be useful for improving search.

The remainder of this section covers several aspects of online communities
that are useful from a search engine perspective. We first describe several ef-
fective methods for automatically finding online communities. We then discuss
community-based question answering, where people ask questions and receive
answers from other members of the community. Finally, we cover collaborative
searching, which is a search paradigm that involves a group of users searching to-
gether.

10.3.2 Finding Communities

The first task that we describe is how to automatically find online communities.
As we mentioned before, online communities are implicitly defined by interac-
tions among a set of entities with common traits. This definition is rather vague
and makes it difficult to design general-purpose algorithms for finding every pos-
sible type of online community. Instead, several algorithms have been developed
that can effectively find special types of communities that have certain assumed
characteristics. We will describe several such algorithms now.

Most of the algorithms used for finding communities take as input a set of en-
tities, such as users or web pages, information about each entity, and details about
how the entities interact or are related to each other.This can be conveniently rep-
resented as a graph, where each entity is a node in the graph, and interactions (or
relationships) between the entities are denoted by edges. Graphs can be either di-
rected or undirected. The edges in directed graphs have directional arrows that
indicate the source node and destination node of the edge. Edges in undirected
graphs do not have directional arrows and therefore have no notion of source and
destination. Directed edges are useful for representing non-symmetric or causal
relationships between two entities. Undirected edges are useful for representing
symmetric relationships or for simply indicating that two entities are related in
some way.

Using this representation, it is easy to define two criteria for finding communi-
tieswithin the graph. First, the set of entities (nodes)must be similar to each other
according to some similarity measure. Second, the set of entities should interact
with each othermore than they interact with other entities.The first requirement



410 10 Social Search

makes sure that the entities actually share the same traits, whereas the second en-
sures that the entities interact in a meaningful way with each other, thereby mak-
ing them a community rather than a set of users with the same traits who never
interact with each other.

The first algorithm that we describe is the HITS algorithm, which was briefly
discussed in Chapter 4 in the context of PageRank. The HITS algorithm is sim-
ilar to PageRank, except that it is query-dependent, whereas PageRank is usually
query-independent. You may be wondering what HITS has to do with finding
communities, since it was originally proposed as a method for improving web
search. BothPageRank andHITS, however, are part of a family of general, power-
ful algorithms known as link analysis algorithms.These algorithms can be applied
to many different types of data sets that can be represented as directed graphs.

Given a graph of entities, we must first identify a subset of the entities that
may possibly be members of the community. We call these entities the candidate
entities. For example, if we wish to find the ice hockey online community, then
we must query each node in the graph and find all of the nodes (users) that are
interested in ice hockey.This canbe accomplishedby, for example, finding all users
of a system who have searched for anything hockey-related. This ensures that the
first criteria, which states that entities should be similar to each other, is satisfied.
Another example is the task of finding the “fractal art” web community. Here, we
could search the Web for the query “fractal art” and consider only those entities
(web pages) that match the query. Again, this ensures that all of the pages are
topically similar to each other. This first step finds sets of similar items, but fails
to identify the sets of entities that actively participate, via various interactions,
within the community, which is the second criteria that we identified as being
important.

Given the candidate entities, the HITS algorithm can be used to find the
“core” of the community. The HITS algorithm takes a graph G with node set
V and edge setE as input. For finding communities, the vertex set V consists of
the candidate entities, and the edge setE consists of all of the edges between can-
didate entities. For each of the candidate entities (nodes) p in the graph, HITS
computes an authority score (A(p)) and a hub score (H(p)). It is assumed that
good hubs are those that point to good authorities and that good authorities are
those that are pointed to by good hubs. Notice the circularity in these definitions.
This means that the authority score depends on the hub score, which in turn de-
pends on the authority score. Given a set of authority and hub scores, the HITS
algorithm updates the scores according to the following equations:



10.3 Searching with Communities 411

Algorithm 3 HITS
1: procedure HITS(G = (V,E),K)
2: A0(p)? 1 ?p ? V
3: H0(p)? 1 ?p ? V
4: for i = 1 toK do
5: Ai(p)? 0 ?p ? V
6: Hi(p)? 0 ?p ? V
7: ZA ? 0
8: ZH ? 0
9: for p ? V do

10: for q ? V do
11: if (p, q) ? E then
12: Hi(p)? Hi(p) +Ai?1(q)
13: ZH ? ZH +Ai?1(q)
14: end if
15: if (q, p) ? E then
16: Ai(p)? Ai(p) +Hi?1(q)
17: ZA ? ZA +Hi?1(q)
18: end if
19: end for
20: end for
21: for p ? V do
22: Ai(p)? Ai(p)ZA
23: Hi(p)? Hi(p)ZH
24: end for
25: end for
26: returnAK , HK
27: end procedure

A(p) =
?
q?p

H(q)

H(p) =
?
p?q

A(q)

where p ? q indicates that an edge exists between entity p (source) and entity
q (destination). As the equations indicate, A(p) is the sum of the hub scores of
the entities that point at p, andH(p) is the sum of the authority scores pointed at
by p. Thus, to be a strong authority, an entity must have many incoming edges, all



412 10 Social Search

with relativelymoderatehub scores, or have very few incoming links thathave very
large hub scores. Similarly, to be a good hub, an entity must have many outgoing
edges to less authoritative pages, or few outgoing edges to very highly authorita-
tive pages.

1, 1

1, 1

1, 1

1, 1

1, 1

1, 1

1, 1

2, 0

1, 1

0, 3

0, 1

3, 0

0, 1

0, 0

.67, 0

.50, .33

0, 1

0, .50

.83, 0

0, .50

0,0

.57, 0

.43, .33

0,1

0, .42

.86, 0

0, .42

0,0

,

,

.33, 0

.17, .17

0, .50

0, .17

.50, 0

0, .17

0,0

.33, 0

.25, .14

0, .43

0, .21

.42, 0

0, .21

0,0

.31, 0

.23, .16

0, .46

0, .19

.46, 0

0, .19

0,0

,

,

,

.33, 0

.17, .17

0, .50

0, .17

.50, 0

0, .17

0,0

,

.33, 0

.25, .14

0, .43

0, .21

.42, 0

0, .21

,

0,0

Iteration 1: Input Iteration 1: Update Scores Iteration 1: Normalize Scores

Iteration 2: Input Iteration 2: Update Scores Iteration 2: Normalize Scores

Iteration 3: Input Iteration 3: Update Scores Iteration 3: Normalize Scores

Fig. 10.3. Illustration of the HITS algorithm. Each row corresponds to a single iteration
of the algorithm and each column corresponds to a specific step of the algorithm.

An iterative version of HITS is given in Algorithm 3. The algorithm begins
by initializing all hub and authority scores to 1. The algorithm then updates the
hub and authority scores according to the equations we just showed. Then, the
hub scores are normalized so that the sum of the scores is 1. The same is also done
for the authority scores. The entire process is then repeated on the normalized
scores for a fixednumber of iterations, denoted byK .The algorithm is guaranteed
to converge and typically does so after a small number of iterations. Figure 10.3
shows an example of the HITS algorithm applied to a graph with seven nodes
and six edges. The algorithm is carried out for three iterations. Notice that the
nodes with many incoming edges tend to have higher authority scores, and those
with more outgoing edges tend to have larger hub scores. Another characteristic



10.3 Searching with Communities 413

of the HITS algorithm is that nodes that are not connected to any other nodes
will always have hub and authority scores of 0.

Once the hub and authority scores have been computed, the entities can be
ranked according to their authority score. This list will contain the most authori-
tative entities within the community. Such entities are likely to be the “leaders” or
form the “core” of the community, based on their interactions with other mem-
bers of the community. For example, if this algorithm were applied to the com-
puter science researcher citation graph to find the information retrieval research
community, the most authoritative authors would be those that are cited many
times by prolific authors. These would arguably be the luminaries in the field and
those authors that form the core of the research community. When finding web
communities on the web graph, the algorithm will return pages that are linked to
by a large number of reputable web pages.

1

5

4

3

7

2

6

0

0

0

0

0

0

0

0

0

0

0

0

1

0

1

0

0

0

1

1

0

0

0

0

0

0

1

0

1

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

Node:

Vector:

1 2 3 4 5 6 7

1

5

4

3

7

2

6

1

3

6

4

6

5

3

6666

1

5

1

5

Fig. 10.4. Example of how nodes within a directed graph can be represented as vectors.
For a given node p, its vector representation has component q set to 1 if p? q.

Clustering algorithms, such as the ones described in Chapter 9, may also be
used for finding online communities. These algorithms easily adapt to the prob-



414 10 Social Search

lem, since community finding is an inherently unsupervised learning problem.
Both agglomerative clustering and K-means can be used for finding communi-
ties. Both of these clustering algorithms require a function that measures the dis-
tance between two clusters. As we discussed in Chapter 9, the Euclidean distance
is often used. However, it is not immediately clear how to apply the Euclidean
distance to nodes in a (directed or undirected) graph. One simple way is to rep-
resent each node (entity) in the graph as a vector that has |V | components—one
for every node in the graph. For some node p, component q of its vector repre-
sentation is set to 1 if p ? q, and 0 otherwise. This results in each node being
represented by the nodes it points to. Figure 10.4 shows how the nodes of a graph
are represented this way. Each vector may optionally be normalized. Using this
representation, it is possible to use the Euclidean distance and directly apply ag-
glomerative clustering or K-means to the problem. A high similarity according
to the Euclidean distancewill occurwhen two entities have edges directed toward
many of the same entities. For example, returning to the problem of finding the
information retrieval research community, two authors would be considered very
similar if they tended to cite the same set of authors. It is realistic to assume that
mostmembers of the information retrieval research community tend to citemany
of the same authors, especially those that would be given a large authority score
by HITS.

Evaluating the effectiveness of community-finding algorithms is typicallymore
difficult than evaluating traditional clustering tasks, since it is unclear how to de-
termine whether some entity should be part of a given community. In fact, it is
likely that if a group of people were asked to manually identify online communi-
ties, there would bemany disagreements due to the vague definition of a commu-
nity. Therefore, it is impossible to say whether HITS or agglomerative clustering
is better at finding communities. The best choice largely depends on the task and
data set for the application.

Now that you have seen several ways of automatically finding online commu-
nities, you may be wondering how this information can be put to practical use.
There are many different things that can be done after a set of communities has
been identified. For example, if a user has been identified as part of the informa-
tion retrieval research community, then when the user visits a web page, targeted
content may be displayed to the user that caters to her specific interests. Search
engines could use the community information as additional contextual informa-
tion for improving the relevance of search results, by retrieving results that are also
topically related to the community or communities associated with the user. On-



10.3 Searching with Communities 415

line community information can also be used in other ways, including enhanced
browsing, identifying experts, website recommendation, and possibly even sug-
gesting who may be a compatible date for you!

10.3.3 Community-Based Question Answering

In the last section,wedescribedhow to automatically findonline communities. In
this section, we describe how such communities can be used effectively to help an-
swer complex information needs that would be difficult to answer using conven-
tional search engines. For example, consider a personwho is interested in learning
about potential interactions between a medicine he was just prescribed and an
herbal tea he often drinks. He could use a search engine and spend hours entering
various queries, looking at search results, and trying to find useful information
on the subject. The difficulty with using this approach is that no single page may
exist that completely satisfies the person’s information need. Now, suppose that
the person could ask his question directly to a large group of other people, sev-
eral of whom are pharmacists or herbal experts. He would be much more likely
to get an answer. This search scenario, where a person submits a question to a
community consisting of both experts and non-experts in a wide range of topics,
each of whom can opt to answer the question, is called community-based ques-
tion answering (CQA). These systems harness the power of human knowledge in
order to satisfy a broad range of information needs. Several popular commercial
systems of this type exist today, including Yahoo! Answers and Naver, a Korean
search portal.

There are both pros and cons to CQA systems. The pros include users being
able to get answers to complex or obscure information needs; the chance to see
multiple, possibly differing opinions about a topic; and the chance to interact
with other users who may share common interests, problems, and goals. The cons
include the possibility of receiving no answer at all to a question, having to wait
(possibly days) for an answer, and receiving answers that are incorrect,misleading,
offensive, or spam.

Aswe justmentioned,many of the answers that people submit are of low qual-
ity. It turns out, however, that the old computer programming adage of “garbage
in, garbage out” also applies to questions. Studies have shown that low-quality an-
swers are often given to low-quality questions. Indeed, there are a wide range of
questions that users can, and do, ask. Table 10.1 shows a small sample of questions
submitted to Yahoo! Answers. Some of the questions in the table are well-formed



416 10 Social Search

What part of Mexico gets the most tropical storms?
How do you pronounce the french words, coeur and miel?

GED test?
Why do I have to pay this fine?

What is Schrödinger’s cat?
What’s this song?

Hi...can u ppl tell me sumthing abt death dreams??
What are the engagement and wedding traditions in Egypt?

Fun things to do in LA?
What lessons from the Tao Te Ching do you apply to your everyday life?

Foci of a hyperbola?
What should I do today?

Why was iTunes deleted from my computer?
Heather Locklear?

Do people in the Australian Defense Force (RAAF) pay less tax than civilians?
Whats a psp xmb?

If C(-3, y) and D(1, 7) lie upon a line whose slope is 2, find the value of y.?
Why does love make us so irrational?

Am I in love?
What are some technologies that are revolutionizing business?

Table 10.1. Example questions submitted to Yahoo! Answers

and grammatically correct, whereas others are not. In addition, some of the ques-
tions have simple, straightforward answers, but many others do not.

Besides allowing users to ask and answer questions, CQA services also provide
users with the ability to search the archive of previously asked questions and the
corresponding answers. This search functionality serves two purposes. First, if a
user finds that a similar question has been asked in the past, then they may not
need to ask the question and wait for responses. Second, search engines may aug-
ment traditional search results with hits from the question and answer database.
For example, if a user enters the query “schrödingers cat”, the search engine may
choose to return answers to “What is Schrödinger’s cat?” (which appears in Ta-
ble 10.1) in addition to the other, more standard set of ranked web pages.

Therefore, given a query,2 it is important to be able to automatically find po-
tential answers in the question and answer database. There are several possible

2 For the remainder of our discussion, we use the term “query” to refer to a question or
a search query.



10.3 Searching with Communities 417

ways to search this database. New queries can be matched against the archived
questions alone, the archived answers alone, or questions and answers combined.
Studies have shown that it is better to match queries against the archived ques-
tions rather than answers, since generally it is easier to find related questions
(which are likely to have relevant answers) than it is to match queries directly to
answers.

Matching queries to questions can be achieved using any of the retrieval mod-
els described in Chapter 7, such as language modeling or BM25. However, tradi-
tional retrieval models are likely to miss many relevant questions because of the
vocabulary mismatch problem. Here, vocabulary mismatch is caused by the fact
that there aremany different ways to ask the same question. For example, suppose
we had the query “who is the leader of india?”. Related questions are “who is the
prime minister of india?”, “who is the current head of the indian government?”,
and so on. Notice that the only terms in common among any two of these ques-
tions are “who”, “is”, “the”, “of ”, and “india”. Blindly applying any standard retrieval
model would retrieve non-related questions such as “who is the finance minister
of india?” and “who is the tallest person in all of india?”. Stopword removal in this
case does not help much. Instead, better matches can be achieved by generalizing
the notion of “leader” to include other concepts, such as “primeminister”, “head”,
and “government”.

In section 6.4, we described cross-language retrieval, where a user queries in a
source language (e.g., English) and documents are retrieved in a target language
(e.g., French). Most of the retrieval methods developed for cross-language re-
trieval are based onmachine translation techniques, which require learning trans-
lation probabilities of the form P (s|t), where s is a word in the source language
and t is a word in the target language. Translation models can also be used to
help overcome the vocabulary mismatch problem within a single language. This
is achieved by estimating P (t|t?), where t and t? are both words in the same
language. This probability can be interpreted as the probability that word t is
used in place of t?. Returning to our example, it is likely that P (leader|minister)
and P (leader|government) would have non-zero values, and therefore result in
more relevant questions being retrieved. We will now describe two translation-
based models that have been used for finding related questions and answers in an
archive.

Thefirstmodel was proposed byBerger andLafferty (1999). It is similar to the
query likelihoodmodel described in section 7.3.1, except it allows query terms to



418 10 Social Search

be “translated” from other terms. Given a query, related questions3 are ranked
according to:

P (Q|A) =
?
w?Q

?
t?V

P (w|t)P (t|A)

where Q is the query, A is a related question in the archive, V is the vocabulary,
P (w|t) are the translation probabilities, andP (t|D) is the smoothed probability
of generating t given documentD (see section 7.3.1 for more details). Therefore,
we see that the model allows query term w to be translated from other terms t
that may occur in the question. One of the primary issues with this model is that
there is no guarantee the question will be related to the query; since every term
is translated independently, the question with the highest score may be a good
term-for-term translation of the query, but not a good overall translation.

The second model, developed by Xue et al. (2008), is an extension of Berger’s
model that attempts to overcome this issue by allowing matches of the original
query terms to be given more weight than matches of translated terms. Under
this model, questions (or answers) are ranked using the following formula:

P (Q|A) =
?
w?Q

(1? ?)fw,A + ?
?

t?V P (w|t)ft,A + µ
cw
|C|

|A|+ µ

where ? is a parameter between 0 and 1 that controls the influence of the transla-
tion probabilities, and µ is the Dirichlet smoothing parameter. Notice that when
? = 0, this model is equivalent to the original query likelihood model, with no
influence from the translation model. As ? approaches 1, the translation model
begins to have more impact on the ranking and becomes more similar to Berger’s
model.

Ranking using these models can be computationally expensive, since each in-
volves a sumover the entire vocabulary, which can be very large.Query processing
speeds can be significantly improved by considering only a small number of trans-
lations per query term. For example, if the five most likely translations of each
query term are used, the number of terms in the summation will be reduced from
V to 5.

Theonemajor issue that has been ignored thus far is how to compute the trans-
lation probabilities. In cross-language retrieval, translation probabilities can be

3 The discussion focuses on question retrieval, but the same models can be used to re-
trieve archived answers. As we said, question retrieval is generally more effective.



10.3 Searching with Communities 419

everest xp search
everest xp search

mountain window google
tallest install information
29,035 drive internet
highest computer website

mt version web
ft click list

measure pc free
feet program info

mount microsoft page

Table 10.2. Translations automatically learned from a set of question and answer pairs.
The 10 most likely translations for the terms “everest”, “xp”, and “search” are given.

automatically learned using a parallel corpus. Translation probabilities are esti-
mated from pairs of documents of the form {(Ds1, Dt1), . . . , (DsN , DtN)}, where
Dsi is document i written in the source language and Dti is document i written
in the target language. However, the notion of a parallel corpus becomes hazy
when dealing with intralanguage translations. A variety of approaches have been
used for estimating translationprobabilitieswithin the same language. Forfinding
related questions, one of the most successful approaches makes the assumption
that question/answer pairs form a parallel corpus from which translation prob-
abilities can be estimated. That is, translation probabilities are estimated from
archived pairs of the form {(Q1, A1), . . . , (QN , AN)}, where Qi is question i
and Ai is answer i. Example translations estimated from a real question and an-
swer database using this approach are shown inTable 10.2. Pointers to algorithms
for estimating translation probabilities given a parallel corpus are given in the
“References and Further Reading” section at the end of this chapter.

In this section, we assumed that people in a community would provide an-
swers to questions, and an archive of questions and answers would be created by
this process. As we mentioned in Chapter 1, it is also possible to design question
answering systems that find answers for a more limited range of questions in the
text of large document corpora.Wedescribe these systems inmore detail inChap-
ter 11.



420 10 Social Search

10.3.4 Collaborative Searching

The final community-based search task that we consider is collaborative search-
ing. As the name suggests, collaborative searching involves a group of users with a
common goal searching together in a collaborative setting. There are many situa-
tions where collaborative searching can be useful. For example, consider a group
of students working together on a world history report. In order to complete the
report, the students must do background research on the report topic. Tradition-
ally, the students would split the topic into various subtopics, assign each group
member one of the subtopics, and then each student would search the Web or an
online library catalog, independently of the other students, for information and
resources on their specific subtopic. In the end, the students would have to com-
bine all of the information from the various subtopics to form a coherent report.
Each student would learn a great deal about his or her particular subtopic, and
no single student would have a thorough understanding of all of the material in
the report. Clearly, every student would end up learning a great deal more if the
research process were more collaborative. A collaborative search systemwould al-
low the students to search the Web and other resources together, so that every
member of the group could contribute and understand every subtopic of the re-
port. Collaborative search can also be useful within companies, where colleagues
must collect information about various aspects of a particular project. Last, but
certainly not least, recreational searchers may find collaborative search systems
particularly useful. Suppose you and your friends are planning a party. A collabo-
rative search systemwouldhelp everyone coordinate information-gathering tasks,
such as finding recipes, choosing decorations, selectingmusic, deciding on invita-
tions, etc.

There are two common types of collaborative search scenarios, depending on
where the search participants are physically located with respect to each other.
The first scenario, known as co-located collaborative search, occurs when all of the
search participants are in the same location, such as the same office or same li-
brary, sitting in front of the same computer. The other scenario, known as remote
collaborative searching, occurswhen the search participants are physically located
in different locations.The participants may be in different offices within the same
building, different buildings within the same city, or even in completely different
countries across the globe. Figure 10.5 provides a schematic for these scenarios.
Both situations present different challenges, and the systems developed for each
have different requirements in terms of how they support search.To illustrate this,
we briefly describe two examples of collaborative search systems.



10.3 Searching with Communities 421

Co-located Collaborative Searching Remote Collaborative Searching

Fig. 10.5.Overview of the two common collaborative search scenarios. On the left is co-
located collaborative search, which involves multiple participants in the same location
at the same time. On the right is remote collaborative search, where participants are in
different locations and not necessarily all online and searching at the same time.

TheCoSearch systemdeveloped byAmershi andMorris (2008) is a co-located
collaborative search system. The system has a primary display, keyboard, and
mouse that is controlled by the person called the “driver”, who leads the search
task.Additional participants, called “observers”, eachhave amouseor aBluetooth-
enabled4 mobile phone. The driver begins the session by submitting a query to a
search engine. The search results are displayed on the primary display and on the
display of any user with a mobile phone. Observers may click on search results,
which adds the corresponding page into a shared “page queue.” This allows every
participant to recommend which page should be navigated to next in a conve-
nient, centralized manner, rather than giving total control to the driver. In addi-
tion to the page queue, there is also a “query queue,” where participants submit
new queries. The query queue provides everyone with a list of potentially useful
queries to explore next, and provides the driver with a set of options generated

4 Bluetooth is the name of a short-range wireless technology that allows for communi-
cation between devices, such as laptops, printers, PDAs, and mobile phones.



422 10 Social Search

collectively by the group. The CoSearch system provides many useful ways for
a group of people to collaboratively search together, since it allows everyone to
work toward a common task, while at the same time preserving the important di-
vision of labor that is part of collaboration, via the use of multiple input devices.

An example of a remote collaborative search system is SearchTogether, devel-
oped by Morris and Horvitz (2007b). In this system, it is assumed that every
participant in the session is in a different location and has his own computer.
Furthermore, unlike co-located search, which assumes that all of the participants
are present during the entire search session, remote search makes no assumptions
about whether everyone is online at the same time.Therefore, whereas co-located
search sessions tend to be transient, remote search sessions can be persistent.Users
of the system may submit queries, which are logged and shared with all of the
other searchparticipants.This allows all participants to seewhat others are search-
ing for, and allows them to resubmit or refine the queries. Users can add ratings
(e.g., “thumbs up” or “thumbs down”) and comments to pages that are viewed
during the search process, which will be aggregated and made available to other
participants. In addition, a participant may explicitly recommend a given page
to another participant, which will then show up in her recommended pages list.
Therefore, the SearchTogether system provides most of the functionality of the
CoSearch system, except it is adapted to the specific needs of remote collabora-
tion. One particular advantage of a persistent search session is that new partici-
pants, who were not previously part of the search process, can quickly be brought
up to speed by browsing the query history, page ratings, comments, and recom-
mendations.

As we have outlined, collaborative search systems provide users with a unique
set of tools to effectively collaborate with each other during a co-located or re-
mote search session. Despite the promise of such systems, very few commercial
collaborative search systems exist today. However, such systems are beginning to
gain considerable attention in the research community. Given this, and the in-
creasingly collaborative nature of the online experience, it may be only a matter
of time before collaborative search systems become more widely available.



10.4 Filtering and Recommending 423

10.4 Filtering and Recommending

10.4.1 Document Filtering

As wementioned previously, one part of social search applications is representing
individual users’ interests and preferences.One of the earliest applications that fo-
cused on user profiles was document filtering. Document filtering, often simply
referred to as filtering, is an alternative to the standard ad hoc search paradigm.
In ad hoc search, users typically enter many different queries over time, while the
document collection stays relatively static. In filtering, the user’s informationneed
stays the same, but the document collection itself is dynamic, with new docu-
ments arriving periodically.The goal of filtering, then, is to identify (filter) the rel-
evantnewdocuments and send themto theuser. Filtering, as described inChapter
3, is a push application.

Filtering is also an example of a supervised learning task,where theprofile plays
the part of the training data and the incoming documents are the test items that
need to be classified as “relevant” or “not relevant.” However, unlike a spam de-
tection model, which would take thousands of labeled emails as input, a filtering
system profile may only consist of a single query, making the learning task even
more challenging. For this reason, filtering systems typically use more specialized
techniques than general classification techniques in order to overcome the lack of
training data.

Although they are not as widely used as standard web search engines, there
are many examples of real-world document filtering systems. For example, many
news sites offerfiltering services.These services include alertinguserswhen there is
breaking news, when an article is published in a certain new category (e.g., sports
or politics), orwhen an article is published about a certain topic,which is typically
specified using one ormore keywords (e.g., “terrorism” or “global warming”).The
alerts come in the form of emails, SMS (textmessages), or even personalized news
feeds, thereby allowing the user to keep up with topics of interest without having
to continually check the news site for updates or enter numerous queries to the
site’s search engine. Therefore, filtering provides a way of personalizing the search
experience by maintaining a number of long-term information needs.

Document filtering systems have two key components. First, the user’s long-
term informationneedsmust be accurately represented.This is done by construct-
ing a profile for every information need. Second, given a document that has just ar-
rived in the system, a decision mechanism must be devised for identifying which
are the relevant profiles for that document. This decision mechanism must not



424 10 Social Search

only be efficient, especially since there are likely to be thousands of profiles, but
it must also be highly accurate. The filtering system should not miss relevant doc-
uments and, perhaps even more importantly, should not be continually alerting
users about non-relevant documents. In the remainder of this section, we describe
the details of these two components.

Profiles

In web search, users typically enter a very short query. The search engine then
faces the daunting challenge of determining the user’s underlying information
need from this very sparse piece of information. There are numerous reasons why
most search engines today expect information needs to be specified as short key-
word queries. However, one of the primary reasons is that users do not want to
(or do not have the time to) type in long, complex queries for each and every one
of their information needs. Many simple, non-persistent information needs can
often be satisfied using a short query to a search engine. Filtering systems, on the
other hand, cater to long-term information needs. Therefore, users may be more
willing to spend more time specifying their information need in greater detail in
order to ensure highly relevant results over an extended period of time. The rep-
resentation of a user’s long-term information need is often called a filtering profile
or just a profile.

What actually makes up a filtering profile is quite general and depends on
the particular domain of interest. Profiles may be as simple as a Boolean or key-
word query. Profilesmay also contain documents that are known to be relevant or
non-relevant to the user’s informationneed. Furthermore, theymay contain other
items, such as social tags and related named entities. Finally, profilesmay also have
one or more relational constraints, such as “published before 1990”, “price in the
$10–$25 range”, and so on. Whereas the other constraints described act as soft
filters, relational constraints of this form act as hard filters that must be satisfied
in order for a document to be retrieved.

Although there are many different ways to represent a profile, the underlying
filtering model typically dictates the actual representation. Filtering models are
very similar to the retrieval models described in Chapter 7. In fact, many of the
widely used filteringmodels are simply retrievalmodelswhere the profile takes the
place of the query. There are two common types of filtering models. The first are
staticmodels. Here, static refers to the fact that the user’s profile does not change
over time, and therefore the same model can always be applied. The second are



10.4 Filtering and Recommending 425

adaptive models, where the user’s profile is constantly changing over time. This
scenario requires the filtering model to be dynamic over time as new information
is incorporated into the profile.

Static filtering models

As we just described, static filtering models work under the assumption that the
filtering profile remains static over time. In some ways, this makes the filtering
process easier, but in other ways it makes it less robust. All of the popular static
filteringmodels are derived from the standard retrievalmodels described inChap-
ter 7. However, unlike web search, filtering systems do not return a ranked list of
documents for each profile. Instead, when a new document enters the system, the
filtering systemmust decide whether or not it is relevant with respect to each pro-
file. Figure 10.6 illustrates how a static filtering system works. As new documents
arrive, they are compared to each profile. Arrows from a document to a profile
indicate that the document was deemed relevant to the profile and returned to
the user.

Document Stream

t = 2 t = 3 t = 5 t = 8

Profile

1

Profile

2

Profile

3

t = 2 t = 3 t = 5 t = 8

Fig. 10.6. Example of a static filtering system. Documents arrive over time and are com-
pared against each profile. Arrows from documents to profiles indicate the document
matches the profile and is retrieved.



426 10 Social Search

In themost simple case, a Boolean retrievalmodel can be used.Here, the filter-
ing profile would simply consist of a Boolean query, and a new document would
be retrieved for the profile only if it satisfied the query. The Boolean model, de-
spite its simplicity, can be used effectively for document filtering, especially where
precision is important. In fact, many web-based filtering systems make use of a
Boolean retrieval model.

One of the biggest drawbacks of the Boolean model is the low level of recall.
Depending on the filtering domain, users may prefer to have good coverage over
very high precision results. There are various possible solutions to this problem,
including using the vector space model, the probabilistic model, BM25, or lan-
guage modeling. All of these models can be extended for use with filtering by
specifying a profile using a keyword query or a set of documents. Directly apply-
ing these models to filtering, however, is not trivial, since each of them returns
a score, not a “retrieve” or “do not retrieve” answer as in the case of the Boolean
model. One of themost widely used techniques for overcoming this problem is to
use a score threshold to determine whether to retrieve a document. That is, only
documents with a similarity score above the threshold will be retrieved. Such a
threshold would have to be tuned in order to achieve good effectiveness. Many
complex issues arise when applying a global score threshold, such as ensuring that
scores are comparable across profiles and over time.

As a concrete example, we describe how static filtering can be done within
the language modeling framework for retrieval. Given a static profile, which may
consist of a single keyword query, multiple queries, a set of documents, or some
combination of these, we must first estimate a profile language model denoted by
P . There are many ways to do this. One possibility is:

P (w|P ) = (1? ?)?K
i=1 ?i

K?
i=1

?i
fw,Ti
|Ti|

+ ?
cw
|C|

where T1, . . . , Tk are the pieces of text (e.g., queries, documents) that make up
the profile, and ?i is the weight (importance) associated with text Ti. The other
variables and parameters are defined in detail in Chapter 7.

Then, given an incoming document, a document languagemodel (D)must be
estimated. We again follow the discussion in Chapter 7 and estimateD using the
following:

P (w|D) = (1? ?)fw,D
|D|

+ ?
cw
|C|



10.4 Filtering and Recommending 427

Documents can then be ranked according to the negative KL-divergence be-
tween the profile language model (P ) and the document language model (D) as
follows:

?KL(P ||D) =
?
w?V

P (w|P ) logP (w|D)?
?
w?V

P (w|P ) logP (w|P )

DocumentD is then delivered to profileP if?KL(P ||D) ? t, where t is some
relevance threshold.

Document filtering can also be treated as a machine learning problem. At its
core, filtering is a classification task that often has a very small amount of training
data (i.e., the profile). The task is then to build a binary classifier that determines
whether an incoming document is relevant to the profile. However, training data
wouldbenecessary in order toproperly learn such amodel. For this task, the train-
ing data comes in the form of binary relevance judgments over profile/document
pairs. Any of the classification techniques described in Chapter 9 can be used.
Suppose that a Support Vector Machine with a linear kernel is used; the scoring
function would then have the following form:

s(P ;D) = w · f(P,D) = w1f1(P,D) + w2f2(P,D) + . . .+ wdfd(P,D)

where w1, . . . , wd are the set of weights learned during the SVM training pro-
cess, and f1(P,D), . . . , fd(P,D) are the set of features extracted from the pro-
file/document pair. Many of the features that have been successfully applied to
text classification, such as unigrams and bigrams, can also be applied to filtering.
Given a large amount of training data, it is likely that amachine learning approach
will outperform the simple languagemodeling approach just described.However,
when there is little or no training data, the language modeling approach is a good
choice.

Adaptive filtering models

Static filtering profiles are assumed not to change over time. In such a setting, a
user would be able to create a profile, but could not update it to better reflect his
information need.The only optionwould be to delete the profile and create a new
one that would hopefully produce better results. This type of system is rigid and
not very robust.

Adaptive filtering is an alternative filtering technique that allows for dynamic
profiles. This technique provides a mechanism for updating the profile over time.



428 10 Social Search

Document Stream

t = 2 t = 3 t = 5 t = 8

Profile

1

Profile

2

Profile

3

Profile 

1.1

Profile 

2.1

Profile

3.1

t = 2 t = 3 t = 5 t = 8

Fig. 10.7. Example of an adaptive filtering system. Documents arrive over time and are
compared against each profile. Arrows fromdocuments to profiles indicate the document
matches the profile and is retrieved. Unlike static filtering, where profiles are static over
time, profiles are updated dynamically (e.g., when a new match occurs).

Profiles may be either updated using input from the user or done automatically
based on user behavior, such as click or browsing patterns. There are various rea-
sons why it may be useful to update a profile as time goes on. For example, users
may want to fine-tune their information need in order to findmore specific types
of information. Therefore, adaptive filtering techniques are more robust than
static filtering techniques and are designed to adapt to find more relevant docu-
ments over the life span of a profile. Figure 10.7 shows an example adaptive filter-
ing system for the same set of profiles and incoming documents from Figure 10.6.
Unlike the static filtering case, when a document is delivered to a profile, the user
provides feedback about the document, and the profile is then updated and used
for matching future incoming documents.

As Figure 10.7 suggests, one of the most common ways to adapt a profile is
in response to user feedback. User feedback may come in various forms, each of
which can be used in different ways to update the user profile. In order to provide
a concrete example of how profiles can be adapted in response to user feedback,
we consider the case where users provide relevance feedback (see Chapter 6) on



10.4 Filtering and Recommending 429

documents. That is, for some set of documents, such as the set of documents re-
trieved for a given profile, the user explicitly states whether or not the document
is relevant to the profile. Given the relevance feedback information, there are a
number of ways to update the profile. As before, how the profile is represented
and subsequently updated largely depends on the underlying retrieval model that
is being used.

As described in Chapter 7, the Rocchio algorithm can be used to perform rel-
evance feedback in the vector space model. Therefore, if profiles are represented
as vectors in a vector space model, Rocchio’s algorithm can be applied to update
the profiles when the user provides relevance feedback information. Given a pro-
file P , a set of non-relevant feedback documents (denotedNonrel), and a set of
relevant feedback documents (denotedRel), the adapted profile P ? is computed
as follows:

P ? = ?.P + ?.
1

|Rel|
?

Di?Rel

Di ? ?.
1

|Nonrel|
?

Di?Nonrel

Di

where Di is the vector representing document i, and ?, ?, and ? are parameters
that control how to trade off theweighting between the initial profile, the relevant
documents, and the non-relevant documents.

Chapter 7 also describedhow relevancemodels canbeusedwith languagemod-
eling for pseudo-relevance feedback. However, relevance models can also be used
for true relevance feedback as follows:

P (w|P ) = 1
|Rel|

?
Di?Rel

?
D?C

P (w|D)P (Di|D)

? 1
|Rel|

?
Di?Rel

P (w|Di)

where C is the set of documents in the collection,Rel is the set of documents that
have been judged relevant,Di is document i, andP (Di|D) is the probability that
document Di is generated from document D’s language model. The approxima-
tion (?) can bemade becauseDi is a document, andP (Di|D) is going to be 1 or
very close to 1 whenDi = D and nearly 0 for most other documents. Therefore,
the probability of w in the profile is simply the average probability of w in the
language models of the relevant documents. Unlike the Rocchio algorithm, the
non-relevant documents are not considered.



430 10 Social Search

If a classification technique, such as one of those described in Chapter 9, is
used for filtering, then an online learning algorithm can be used to adapt the clas-
sification model as new user feedback arrives. Online learning algorithms update
model parameters, such as the hyperplane w in SVMs, by considering only one
new item or a batch of new items. These algorithms are different from standard
supervised learning algorithms because they donot have a “memory.”That is, once
an input has been used for training, it is discarded and cannot be explicitly used
in the future to update the model parameters. Only the new training inputs are
used for training. The details of online learning methods are beyond the scope of
this book. However, several references are given in the “References and Further
Reading” section at the end of this chapter.

Model Profile Representation Profile Updating
Boolean Boolean Expression N/A

Vector Space Vector Rocchio
Language Modeling Probability Distribution Relevance Modeling

Classification Model Parameters Online Learning

Table 10.3. Summary of static and adaptive filtering models. For each, the profile repre-
sentation and profile updating algorithm are given.

Both static and adaptive filtering, therefore, can be considered special cases of
many of the retrieval models and techniques described in Chapters 6, 7, and 9.
Table 10.3 summarizes the various filtering models, including how profiles are
represented and updated. In practice, the vector space model and language mod-
eling have been shown to be effective and easy to implement, both for static and
adaptive filtering. The classification models are likely to be more robust in highly
dynamic environments. However, as with all classification techniques, the model
requires training data to learn an effective model.

Fast filtering with millions of profiles

In a full-scale production system, there may be thousands or possibly even mil-
lions of profiles that must be matched against incoming documents. Fortunately,
standard information retrieval indexing and query evaluation strategies can be
applied to perform this matching efficiently. In most situations, profiles are rep-
resented as a set of keywords or a set of feature values, which allows each profile to



10.4 Filtering and Recommending 431

be indexed using the strategies discussed in Chapter 5. Scalable indexing infras-
tructures can easily handle millions, or possibly even billions, of profiles. Then,
once the profiles are indexed, an incoming document can be transformed into a
“query”, which again is represented as either a set of terms or a set of features. The
“query” is then run against the index of profiles, retrieving a ranked list of profiles.
The document is then delivered to only those profiles whose score, with respect
to the “query”, is above the relevance threshold previously discussed.

Evaluation

Many of the evaluation metrics described in Chapter 8 can be used to evaluate
filtering systems. However, it is important to choose appropriate metrics, because
filtering differs in a number of ways from standard search tasks, such as news or
web search. One of the most important differences is the fact that filtering sys-
tems do not produce a ranking of documents for each profile. Instead, relevant
documents are simply delivered to the profile as they arrive. Therefore, measures
such as precision at rank k andmean average precision are not appropriate for the
task. Instead, set-based measures are typically used.

Relevant Non-Relevant
Retrieved TP FP

Not retrieved FN TN

Table 10.4. Contingency table for the possible outcomes of a filtering system. Here, TP
(true positive) is the number of relevant documents retrieved, FN (false negative) is the
number of relevant documents not retrieved, FP (false positive) is the number of non-
relevant documents retrieved, andTN (true negative) is the number of non-relevant doc-
uments not retrieved.

Table 10.4, which is similar to Table 8.3 in Chapter 8, shows all of the possi-
bilities for an incoming document with respect to some profile. A document may
be either relevant or non-relevant, as indicated by the column headings. Further-
more, a document may be either retrieved or not retrieved by the filtering system,
as indicated by the row headings. All of the filtering evaluation metrics described
here can be formulated in terms of the cells in this table.

The simplest way to evaluate a filtering system is using the classical evaluation
measures of precision and recall, which correspond to TP

TP+FP
and TP

TP+FN
, re-

spectively. The F measure, which is the harmonic mean of precision and recall, is



432 10 Social Search

also commonly used. Typically, these measures are computed for each profile in
the system and then averaged together.5

It is possible to define a more general evaluation metric that combines each of
the four cells in Table 10.4 in the following way:

U = ? · TP + ? · TN + ? · FP + ? · FN

where the coefficients ?, ?, ?, and ? can be set in different ways to achieve differ-
ent trade-offs between the various components of themeasure. One setting of the
coefficients that has been widely used in filtering experiments is ? = 2, ? = 0,
? = ?1, and ? = 0. This results in true positives (relevant retrieved documents)
being given weight 2 and false negatives (relevant documents that were not re-
trieved) being penalized by a factor of 1. Of course, different coefficients can be
chosen based on the actual costs of the underlying task.

10.4.2 Collaborative Filtering

Static and adaptive filtering are not social tasks, in that profiles are assumed to be
independent of each other. If we now consider the complex relationships that ex-
ist between profiles, additional useful information can be obtained. For example,
suppose that we have an adaptive filtering system with two profiles, which we call
profile A (corresponding to user A) and profile B (corresponding to user B). If
both user A and B judged a large number of the same documents to be relevant
and/or non-relevant to their respective profiles, then we can infer that the two
profiles are similar to each other. We can then use this information to improve
the relevance of thematches to both user A and B. For example, if user A judged a
document to be relevant to profile A, then it is likely that the document will also
be relevant to profile B, and so it should probably be retrieved, even if the score
assigned to it by the adaptive filtering system is below the predetermined thresh-
old. Such a system is social, in the sense that a document is returned to the user
based on both the document’s topical relevance to the profile and any judgments
or feedback that users with similar profiles have given about the document.

Filtering that considers the relationship between profiles (or between users)
and uses this information to improve how incoming items arematched to profiles
(or users) is called collaborative filtering. Collaborative filtering is often used as
a component of recommender systems. Recommender systems use collaborative
5 Recall that this type of averaging is known asmacroaveraging.



10.4 Filtering and Recommending 433

filtering algorithms to recommend items (such as books ormovies) to users.Many
major commercial websites, such as Amazon.com and Netflix, make heavy use of
recommender systems to provide users with a list of recommended products in
the hopes that the user will see something she may like but may not have known
about, and consequentlymake a purchase.Therefore, such systems can be valuable
both to the end users, who are likely to see relevant products, including some that
they may not have considered before, and to search engine companies, who can
use such systems to increase revenue.

In the remainder of this section, we focus on collaborative filtering algorithms
for recommender systems. It is important tonote that these algorithmsdiffer from
static and adaptive filtering algorithms in a number ofways. First, when collabora-
tive filtering algorithms are used for making recommendations, they typically as-
sociate a single profile with each user.That is, the user is the profile. Second, static
and adaptive filtering systems would make a binary decision (retrieve or do not
retrieve) for each incoming document, but collaborative filtering algorithms for
recommender systems provide ratings for items.These ratings may be 0 (relevant)
and 1 (non-relevant) or more complex, such as ratings on a scale of 1 through 5.
Finally, collaborative filtering algorithms for recommender systems provide a rat-
ing for every incoming item, as well as every item in the database for which the
current user has not explicitly provided a judgment.On the other hand, static and
adaptive filtering algorithms only decide whether or not to send incoming docu-
ments to users and never retrospectively examine older documents to determine
whether they should be retrieved.

Figure 10.8 represents a virtual space of users, where users with similar prefer-
ences and tastes are close to each other. The dialog boxes drawn above each user’s
head denote their preference for some item, such as a movie about tropical fish.
Those users who have not rated the movie have question marks in their dialog
boxes. It is the job of the collaborative filtering algorithm to predict as accurately
as possible what rating these users would give to the movie.

Collaborative filtering is conceptually simple, but the details can be difficult to
get correct. For example, onemust decide how to represent users and how tomea-
sure the similarity between them.After similar users have been identified, the user
ratings must be combined in some way. Another important issue concerns how
collaborative filtering and, in particular, recommender systems should be evalu-
ated.Wewill address these issues in the remainder of this sectionwhile describing
the details of two collaborative filtering algorithms that have been used success-
fully in recommender systems.



434 10 Social Search

4

1 1

2

5

?

5

3

1 5
?

?

11
?

Fig. 10.8. A set of users within a recommender system. Users and their ratings for some
item are given. Users with question marks above their heads have not yet rated the item.
It is the goal of the recommender system to fill in these question marks.

Rating with user clusters

In both of the algorithms that follow, we assume that we have a set of users U
and a set of items I . Furthermore, ru(i) is user u’s rating of item i, and r?u(i) is
our system’s prediction for user u’s rating for item i. Note that ru(i) is typically
undefined when user u has not provided a rating for item i, although, as we will
describe later, this does not need to be the case. Therefore, the general collabora-
tive filtering task is to compute r?u(i) for every user/item pair that does not have
an explicit rating.We assume that the only inputwe are given is the explicit ratings
ru(i), which will be used for making predictions. Furthermore, for simplicity, we
will assume that ratings are integers in the range of 1 throughM , although most
of the algorithms described will work equally well for continuous ratings.

One simple approach is to first apply one of the clustering algorithms de-
scribed in Chapter 9 to the set of users. Typically, users are represented by their
rating vectors ru = [ru(i1) . . . ru(i|U|)]. However, since not all users judge all
items, not every entry of the vector ru may be defined, whichmakes it challenging
to compute distance measures, such as cosine similarity. Therefore, the distance
measures must bemodified to account for themissing values.The simplest way to
do this is to fill in all of the missing ratings with some value, such as 0. Another



10.4 Filtering and Recommending 435

possibility is to fill in the missing values with the user’s average rating, denoted by
ru, or the item’s average rating.

One of the common similarity measures used for clustering users is the corre-
lationmeasure, which is computed as follows:?

i?Iu?Iu?
(ru(i)? ru) · (ru?(i)? ru?)??

i?Iu?Iu?
(ru(i)? ru)2

?
i?Iu?Iu?

(ru?(i)? ru?)2

where Iu and Iu? are the sets of items that users u and u? judged, respectively,
which means that the summations are only over the set of items that both user
u and u? judged. Correlation takes on values in the range –1 to 1, with 1 being
achieved when two users have identical ratings for the same set of items, and –1
being achieved when two users rate items exactly the opposite of each other.

4

1 1

2

5

?

5

3

1 5
?

?

11
?

A

B

C

D

Fig. 10.9. Illustration of collaborative filtering using clustering. Groups of similar users
are outlined with dashed lines. Users and their ratings for some item are given. In each
group, there is a single user who has not judged the item. For these users, the unjudged
item is assigned an automatic rating based on the ratings of similar users.

In Figure 10.9, we provide a hypothetical clustering of the users, denoted by
dashed boundaries. After users have been clustered, any user within a cluster that



436 10 Social Search

has not judged some item could be assigned the average rating for the item among
other users in the cluster. For example, the user who has not judged the tropical
fish movie in cluster A would be assigned a rating of 1.25, which is the average
of the ratings given to the movie by the four other users in cluster A. This can be
stated mathematically as:

r?u(i) =
1

|Cluster(u)|
?

u??Cluster(u)

ru?(i)

whereCluster(u) represents the cluster that user u belongs to.
Averaging the ratings of a group of users is one simple way of aggregating the

ratings within a cluster. Another possible approach is to use the expected rating of
the item, given the ratings of the other users within the cluster, which is calculated
as:

r?u(i) =
M?
x=1

x · P (ru(i) = x|C = Cluster(u))

=
M?
x=1

x · |u
? : ru?(i) = x|
|Cluster(u)|

whereP (ru(i) = x|C = Cluster(u)) is the probability that useruwill rate the
item with rating m, given that they are in cluster Cluster(u). This probability
is estimated as |u

?:ru? (i)=x|
|Cluster(u)| , which is the proportion of users in Cluster(u) who

have rated item iwith value x. For example, if all of the users inCluster(u) rate
the item 5, then r?u(i) will equal 5. However, if five users inCluster(u) rate the
item 1 and five users rate it 5, then r?u(i) = 1 · 510 + 5 ·

5
10

= 3.
One issue that arises when relying on clustering for predicting ratings is very

sparse clusters, such as cluster D in Figure 10.9. What score should be assigned
to a user who does not fit nicely into a cluster and has rather unique interests and
tastes?This is a complex and challengingproblemwithno straightforward answer.
One simple, but not very effective, solution is to assign average item ratings to ev-
ery unrated item for the user. Unfortunately, this explicitly assumes that “unique”
users are average, which is actually unlikely to be true.

Rating with nearest neighbors

An alternative strategy to using clusters is to use nearest neighbors for predicting
user ratings. This approach makes use of theK nearest neighbors clustering tech-
nique described in Chapter 9. To predict ratings for user u, we first find the K



10.4 Filtering and Recommending 437

users who are closest to the user according to some similarity measure. Once we
have found the nearest neighbors, we will use the ratings (and similarities) of the
neighbors for prediction as follows:

r?u(i) = ru +
1?

u??N (u) sim(u, u
?)

?
u??N (u)

sim(u, u?)(ru?(i)? ru?)

where sim(u, u?) is the similarity of useru andu?, andN (u) is the set ofu’s near-
est neighbors. This algorithm predicts user u’s rating of item i by first including
the user’s average item rating (ru). Then, for every user u? in u’s nearest neighbor-
hood, ru?(i)? ru? is weighted by sim(u, u?) and added into the predicted value.
You may wonder why ru?(i)? ru? is used instead of ru?(i). The difference is used
because ratings are relative. Certain users may very rarely rate any item with 1,
whereas other users may never rate an item below 3. Therefore, it is best to mea-
sure ratings relative to a given user’s average rating for the purpose of prediction.

Although the approaches using clusters and nearest neighbors are similar in
nature, the nearest-neighbors approach tends to be more robust with respect to
noise. Furthermore, when using nearest neighbors, there is no need to choose a
clustering cost function, only a similarity function, thereby simplifying things.
Empirical results suggest that predicting ratings using nearest neighbors and the
correlation similarity measure tends to outperform the various clustering ap-
proaches across a range of data sets. Based on this evidence, the nearest neighbor
approach, using the correlation similarity function, is a good choice for a wide
range of practical collaborative filtering tasks.

Evaluation

Collaborative filtering recommender systems can be evaluated in a number of
ways. Standard information retrieval metrics, such as those described in Chap-
ter 8, can be used, including accuracy, precision, recall, and the F measure.

However, standard information retrieval measures are very strict, since they
require the system to predict exactly the correct value. Consider the case when
the actual user rating is 4 and system A predicts 3 and system B predicts 1. The
accuracy of both system A and B is zero, since they both failed to get exactly the
right answer.However, systemA ismuch closer to the correct answer than system
B. For this reason, a number of evaluation metrics that consider the difference
between the actual and predicted ratings have been used. One such measure is
absolute error, which is computed as:



438 10 Social Search

ABS =
1

|U||I|
?
u?U

?
i?I

|r?u(i)? ru(i)|

where the sums are over the set of user/itempairs for which predictions have been
made.The other measure is calledmean squared error, which can be calculated as:

MSE =
1

|U||I|
?
u?U

?
i?I

(r?u(i)? ru(i))2

The biggest difference between absolute error and mean squared error is that
mean squared error penalizes incorrect predictionsmore heavily, since the penalty
is squared.

These are the most commonly used evaluation metrics for collaborative filter-
ing recommender systems. So, in the end, which measure should you use? Unfor-
tunately, that is not something we can easily answer. As we have repeated many
times throughout the course of this book, the proper evaluationmeasure depends
a great deal on the underlying task.

10.5 Peer-to-Peer and Metasearch

10.5.1 Distributed Search

We have described social search applications that involve networks or communi-
ties of people, but a number of tools for finding and sharing information are im-
plemented using communities of “nodes,” where each node can store and search
information, and communicate with other nodes. The simplest form of this type
of distributed search environment is a metasearch engine, where each node is a
complete web search engine and the results from a relatively small number of dif-
ferent search engines are combined with the aim of improving the effectiveness of
the ranking. A peer-to-peer (P2P) search application, on the other hand, typically
has a large number of nodes, each with a relatively small amount of information
and only limited knowledge about other nodes.

In contrast to search applications that use only a single document collection,
all distributed search6 applications must carry out three additional, important
functions:
6 Often called distributed information retrieval or federated search.



10.5 Peer-to-Peer and Metasearch 439

• Resource representation: Generating a description of the information resource
(i.e., the documents) stored at a node.

• Resource selection: Selecting one or more resources to search based on their
descriptions.

• Result merging: Merging the ranked result lists from the searches carried out
at the nodes containing the selected information resources.

These functions are carried out by designated nodes that depend on the archi-
tecture of the application.The simplest assumption is that therewill be one special
node that provides thedirectory services of selection andmerging, and every other
node is responsible for providing its own representation. For a metasearch appli-
cation with the architecture shown in Figure 10.10, the resource representation
and selection functions are trivial. Rather than selecting which search engines to
use for a particular query, the query will instead be broadcast by the metasearch
engine to all engines being used by the application. For each search engine, this
is done using the application programming interface (API) and transforming the
query into the appropriate format for the engine.This transformation is generally
very simple since most search engine query languages are similar.

Metasearch

Engine

Web Search 

Engine 3

Web Search 

Engine 2

Web Search 

Engine 1Query

Result List

Query

Merged

Result List

Fig. 10.10.Metasearch engine architecture.Thequery is broadcast tomultipleweb search
engines and result lists are merged.

More generally, in a distributed search environment, each node can be repre-
sented by the probabilities of occurrence of the words in the documents stored at



440 10 Social Search

that node. This is the unigram language model that was used to represent docu-
ments inChapter 7. In this case, there is only one languagemodel representing all
the documents at that node, and the probabilities are estimated using word fre-
quencies summed over the documents. In other words, the documents stored at
that node are treated as one large document to estimate the language model. This
representation is compact, and has been shown to perform well in distributed
retrieval experiments. In some applications, nodes may not be actively cooperat-
ing in the distributed search protocol (process) and, in that case, only provide a
search API. A language model description of the contents of those nodes can still
be generated by query-based sampling. This involves generating a series of queries
to retrieve a sample of documents from the node, which are used to estimate the
languagemodel. Different strategies have been used for selecting query terms, but
even queries based on random selection from the terms in retrieved documents
have been shown to generate an accurate language model.

Resource selection in a general distributed search application involves first
ranking the nodes using their representations, and then selecting the top k ranked
nodes, or all nodes that score above some threshold value. Since we are represent-
ing thenodes using a languagemodel, thenatural ranking algorithmtouse is query
likelihood. This is sometimes referred to in the distributed search literature as the
KL-divergence resource ranking algorithm, since query likelihood is a special case
of KL-divergence. Following the query likelihood score given in section 7.3.1, a
nodeN is ranked by the following score:

logP (Q|N) =
n?

i=1

log fqi,N + µP (qi|C)
|N |+ µ

where there are n query terms, fqi,N is the frequency of query term qi in the doc-
uments at nodeN , P (qi|C) is the background probability estimated using some
large collection of textC , and |N | is the number of term occurrences in the doc-
uments stored at nodeN .

After nodes have been selected, local searches are carried out at each of those
nodes. The results of these searches must be merged to produce a single ranking.
If the same retrieval model (e.g., query likelihood) and the same global statistics
(e.g., the backgroundmodel) are used for each local search, themerge canbebased
directly on the local scores. If different global statistics are used in each node, such
as calculating idf weights using only the documents at that node, then the local
scores can be recalculated by sharing these statistics before merging. If different
retrieval models are used, or if global statistics cannot be shared, then the scores



10.5 Peer-to-Peer and Metasearch 441

must be normalized before merging. A common heuristic approach to score nor-
malization is to use the score from the resource ranking of the node that returned
a document d,Rd, to modify the local document score, Sd, as follows:

S ?d = Sd(? + (1? ?)R?d)

where ? is a constant, and R?d is the resource ranking score normalized with re-
spect to other resource scores.Oneway of normalizing the resource score is to cal-
culate the minimum and maximum possible scores for a given query, Rmin and
Rmax, and then:

R?d = (Rd ?Rmin)/(Rmax ?Rmin)

It is also possible to learn a score-normalizing function by comparing scores from
a sample document collection to the local scores (Si & Callan, 2003).

Result merging in a metasearch application is somewhat different than gen-
eral distributed search. The two main characteristics of metasearch are that doc-
ument scores from local searches generally are not available, and local searches
are often done over collections with very similar content. A metasearch engine
that uses multiple web search engines, for example, is essentially using different
retrieval models on the same collection (theWeb). In this case, local searches pro-
duce ranked lists that have high overlap in terms of the documents that are re-
trieved. Effective methods of combining ranked result lists have been developed
specifically for this situation. The most well-studied methods can be described by
the following formula, giving themodified score for a document,S ?d, as a function
of the scores Sd,i produced by the ith search engine:

S ?d = n
?
d

k?
i=1

Sd,i

where nd is the number of search engines that returned document d in the result
list, ? = (?1, 0, 1), and there are k search engines that returned results. When
? = ?1, the modified score is the average of the local search scores; when ? = 0,
the modified score is the sum of the local scores; and when ? = 1, the modified
score is the sum of the local scores weighted by the number of search engines that
returned document d. The last variation is known as CombMNZ (combine and
multiply by the number of non-zero results) and has been shown to be effective
in many search engine combination experiments.



442 10 Social Search

In a typical metasearch application, scores are not available, and document
ranks are used instead. In this case, the CombMNZ formula with scores based on
ranks can be used. This means, for example, that ifm documents are retrieved in
a result list, the score for a document at rank r would be (m ? r + 1)/m. This
rank-based CombMNZ produces a merged ranking with reasonable effective-
ness, although it is worse than a score-based combination. More effective rank-
based combinations can be achieved with techniques based on voting procedures
(Montague & Aslam, 2002).

In general, distributed search on non-overlapping collections can be compa-
rable in effectiveness to searching a single collection that is the union of all the
distributed collections. Of course, in most applications it would not be possible
to build such a collection, but it does serve as a useful effectiveness benchmark.
Experiments withTREC collections indicate that when average precision at rank
10 or 20 is used as the effectiveness measure, a distributed search that selected
only 5–10 collections out of 200 was at least as effective as a centralized search,
and sometimes was more effective (Powell et al., 2000). On the other hand, in a
P2P testbed where the collection was distributed between 2,500 nodes and only
1% of these nodes were selected, the average precision at rank 10 was 25% lower
than a centralized search (Lu & Callan, 2006).

Metasearch, which combines different searches on the same or very similar
collections, generally improves retrieval effectiveness compared to a single search.
TREC experiments with metasearch have shown improvements of 5–20% in
mean average precision (depending on the query set used) for combinations using
four different search engines, compared to the results from the single best search
engine (Montague & Aslam, 2002).

10.5.2 P2P Networks

P2P networks are used in a range of applications involving communities of users,
although they were popularized through file-sharing applications for music and
video, such as KaZaA and BearShare. Search in file-sharing applications is gener-
ally restricted to finding files with a specified title or some other attribute, such
as the artist for music files. In other words, they support simple exact-match re-
trieval (see Chapter 7). A number of different network architectures or overlays7

7 A network overlay describes the logical connections between nodes implemented on
top of the underlying physical network, which is usually the Internet.



10.5 Peer-to-Peer and Metasearch 443

have been developed to support this type of search. Figure 10.11 shows three of
these architectures.

(a) (b)

(c)

Fig. 10.11. Network architectures for distributed search: (a) central hub; (b) pure P2P;
and (c) hierarchical P2P.Dark circles are hub or superpeer nodes, gray circles are provider
nodes, and white circles are consumer nodes.

Eachnode in a P2Pnetwork can act as a client, a server, or both.Clients (infor-
mation consumers) issue queries to initiate search. Servers (information providers)
respond to queries with files (if they have a match) and may also route queries to
other nodes. Servers thatmaintain information about the contents of other nodes
provide a directory service and are called hubs. The architectures in Figure 10.11
differ primarily in how they route queries to providers. In the first architecture,
which was the basis of the pioneering Napster file-sharing application, there is a
single central hub that provides directory services. Consumers send queries to the
hub, which routes them to nodes that contain the matching files. Although this



444 10 Social Search

architecture is efficient, it is also susceptible to failures or attacks that affect the
central hub.

In the second architecture, known as “pure” P2P (for example, Gnutella 0.48),
there arenohubs.Aquery generatedby a consumer is broadcast to theothernodes
in the network by flooding, which means a node sends the query to all the nodes
connected to it, each of those nodes sends the query to all of their connected
nodes, and so on. Queries have a limited horizon, which restricts the number of
network “hops” that can be made before they expire. The connections between
nodes are random, and each node only knows about its neighbors. The problem
with this architecture is that it does not scale well, in that the network traffic can
grow exponentially with the number of connected users.

The third architecture is the hierarchical P2P or superpeer network, which
was developed as an improvement of the pure P2P network. The Gnutella 0.6
standard is an example. In a hierarchical network, there is a two-level hierarchy of
hub nodes and leaf nodes. Leaf nodes can be either providers or consumers, and
connect only to hub nodes. A hub provides directory services for the leaf nodes
connected to it, and can forward queries to other hubs.

All of these network architectures could be used as the basis for full distributed
search instead of just exact match for file sharing. As we have mentioned, how-
ever, a hierarchical network has advantages in terms of robustness and scalability
(Lu & Callan, 2006). For a distributed search application, each provider node in
the network supports search over a local document collection. A consumer node
provides the interface for the user to specify queries. Hubs acquire resource de-
scriptions for neighboring hubs and providers, which they use to provide resource
selection and result merging services. Specifically, resource descriptions for neigh-
borhoods are used to route queriesmore efficiently than flooding, and resource de-
scriptions for providers are used to rank the local document collections. Instead
of selecting a fixed number of the top-ranked providers, in the P2P system each
hub must be able to decide how many providers to use to respond to the query.

Neighborhood resource descriptions are an important part of the query rout-
ing process. A neighborhood of a hubHi in the direction of a hubHj is the set of
hubs that a query can reach in a fixed number of hops. Figure 10.12 shows an ex-
ample of a hubwith three neighborhoods generated by amaximumof three hops.
The advantage of this definition of neighborhoods is that the information about

8 This means it is version 0.4 of the Gnutella standard. See
http://en.wikipedia.org/wiki/Gnutella.



10.5 Peer-to-Peer and Metasearch 445

the providers that can be reached by traveling several hops beyond the immediate
neighbors improves the effectiveness of query routing.

H

N
1

N
3

N
2

Fig. 10.12. Neighborhoods (Ni) of a hub node (H) in a hierarchical P2P network

The resource description for a hub is the aggregation of the resource descrip-
tions of the providers that are connected to it. In other words, it is a language
model recording probabilities of occurrences of words. A neighborhood resource
description is the aggregation of the hub descriptions in the neighborhood, but a
hub’s contribution is reduced based on the number of hops to the hub. In other
words, the closest neighbor hubs contribute the most to the neighborhood de-
scription.

Retrieval experiments with distributed search implemented on a hierarchical
P2P network show that effectiveness is comparable to searching using a central-
ized hub, which is the architecture we assumed in the last section. More specif-
ically, using neighborhood and provider descriptions to select about 1% of the
2,500 nodes in a P2P testbed produced the same average precision as selecting 1%
of the nodes using a centralized hub, with about one-third of the message traffic
of a query-flooding protocol (Lu & Callan, 2006).

Another popular architecture for file-sharing systems that we have not men-
tioned is a structured network.These networks associate each data itemwith a key
and distribute keys to nodes using a distributed hash table (DHT). Distributed
hash tables can support only exact match searching, but since they are used in a
number of applications, we describe briefly how they can be used to locate a file.



446 10 Social Search

In a DHT, all keys and nodes are represented asm-bit numbers or identifiers.
The name of a file is converted to a key using a hash function. The key and the
associated file are stored at one ormore nodeswhose identifiers are “close” in value
to the key. The definition of distance between keys depends on the specific DHT
algorithm. In theChordDHT, for example, the distance is the numeric difference
between the twom-bit numbers (Balakrishnan et al., 2003).

To find a file, a query containing the key value of the file name is submitted to
any node. Both storing and retrieving files relies on a node being able to forward
requests to a node whose identifier is “closer” to the key. This guarantees that the
request will eventually find the closest node. In Chord, keys are treated as points
on a circle, and if k1 and k2 are the identifiers for two “adjacent” nodes, the node
with identifier k2 is responsible for all keys that fall between k1 and k2. Each node
maintains a routing table containing the IP addresses of a node halfway around
the key “circle” from the node’s identifier, a node a quarter of the way around, a
node an eighth of the way, etc. A node forwards a request for key k to the node
from this table with the highest identifier not exceeding k. The structure of the
routing table ensures that the node responsible for k can be found in O(logN)
hops forN nodes.

References and Further Reading

Social search is growing in popularity amongst information retrieval researchers.
In particular, there has been an increased interest in social tagging and collabora-
tive online environments over the past few years. It is likely that this interest will
continue to grow, given the amount of research and exploration of new applica-
tions that remains to be done.

The subject of the relative effectiveness of manual and automatic indexing
has been discussed for many years in information retrieval, and dates back to
the original Cranfield studies (Cleverdon, 1970). A number of papers, such as
Rajashekar and Croft (1995), have shown the advantages of automatic indexing
relative to manual indexing, and also that effectiveness improves when the two
representations are combined. Several researchers have looked at the usefulness
of tags and other types of metadata for improving search effectiveness. Research
byHeymann,Koutrika, andGarcia-Molina (2008) showed that socialmedia tags,
such as those from deli.cio.us, are not useful for improving search, mainly due to
poor coverage and the fact thatmost of the tags are already present as anchor text.



10.5 Peer-to-Peer and Metasearch 447

Hawking andZobel (2007) report similar results for other types ofmetadata, and
discuss the implications for the semantic web.

Both Sahami and Heilman (2006) and Metzler et al. (2007) proposed similar
techniques for matching short segments of text by expanding the representations
to use web search results. Although these methods were evaluated in the context
of query similarity, they can easily be applied tomeasuring the similarity between
tags.

Tag clouds similar to Figure 10.2 can be generated by software available on the
Web, such as Wordle.9

More details of theHITS algorithm described in this section for finding com-
munities can be found in Gibson et al. (1998). Furthermore, Hopcroft et al.
(2003) describe various agglomerative clustering approaches. Other work related
to finding online communities includes that of Flake et al. (2000), which de-
scribes how a variety of community-finding approaches can be implemented effi-
ciently. In addition, Borgs et al. (2004) looks at the problem of identifying com-
munity structure within newsgroups, while Almeida and Almeida (2004) pro-
pose a community-aware search engine. Finally, Leuski and Lavrenko (2006) de-
scribe how clustering and language modeling can be used to analyze the behavior
and interactions of users in a virtual world.

Jeon et al. (2005) described the approach of question ranking for community-
based question answering. Xue et al. (2008) extended this work with more effec-
tive estimation methods for the translation probabilities and showed that com-
bining the archived questions and answers produced better rankings. The prob-
lem of answer quality and its effect on CQA is addressed in Jeon et al. (2006).
Agichtein et al. (2008) incorporate more features into a prediction of question
and answer quality, and show that features derived from the community graph of
people who ask and answer questions are very important.

The concept of community-based question answering had its origins in digital
reference services (Lankes, 2004).There are other search tasks, beyondcommunity-
based question answering, in which users search for human-generated answers to
questions. Several of these have been explored within the information retrieval
community. Finding answers to questions in FAQs10 has been the subject of a
number of papers. Burke et al. (1997) and Berger et al. (2000), for example,
both attempt to overcome the vocabulary mismatch problem in FAQ retrieval

9 http://www.wordle.net/
10 FAQ is an abbreviation of Frequently Asked Questions.



448 10 Social Search

by considering synonyms and translations. Jijkoun and de Rijke (2005) describe
retrieval from FAQ data derived from the Web, and Riezler et al. (2007) describe
a translation-based model for web FAQ retrieval. Forums are another source of
questions and answers. Cong et al. (2008) describe how question-answer pairs
can be extracted from forum threads to support CQA services.

There are a number of collaborative search systems beyond thosewe described,
includingCIRE (Romano et al., 1999) and S3 (Morris&Horvitz, 2007a).Morris
(2008) provides a good survey of how practitioners actually use collaborative web
search systems. Pickens et al. (2008) evaluate algorithms for iterative merging of
ranked lists to support collaborative search.

Belkin and Croft (1992) provide a perspective on the connection between
ad hoc retrieval and document filtering. Y. Zhang and Callan (2001) describe
an effective method for automatically setting filtering thresholds. The work by
Schapire et al. (1998) describes how boosting, an advancedmachine learning tech-
nique, and Rocchio’s algorithm can be applied to filtering. Finally, Allan (1996)
showed how incremental feedback, which is akin to online learning, can be used
to improve filtering effectiveness. Although not covered in this chapter, a research
area within information retrieval called topic detection and tracking has largely
focused on topical filtering (tracking) of news articles. See Allan (2002) for an
overview of research on the topic.

For a more complete treatment of collaborative filtering algorithms described
in this chapter, seeBreese et al. (1998). Furthermore,Herlocker et al. (2004)detail
the many aspects involved with evaluating collaborative filtering systems.

Callan (2000) gives an excellent overview of research in distributed search. A
more recent paper by Si and Callan (2004) compares the effectiveness of tech-
niques for resource selection. A different approach to query-based sampling for
generating resource descriptions, called query probing, is described by Ipeirotis
and Gravano (2004). This work is focused on providing access to deep Web data-
bases, which are databases that are accessible through the Web, but only through
a search interface.

There aremanypapers describing techniques for combining the output ofmul-
tiple search engines or retrieval models. Croft (2000) gives an overview of much
of this research, andMontague andAslam (2002) provide pointers tomore recent
work.

A general overview of P2P search and more details of how distributed search
is implemented in a hierarchical network can be found in Lu and Callan (2006,
2007).



10.5 Peer-to-Peer and Metasearch 449

Exercises

10.1. Describe how social media tags are similar to anchor text. How are they
different?

10.2. Implement two algorithms for measuring the similarity between two tags.
The first algorithm should use a standard retrieval model, such as language mod-
eling. The second algorithm should use the Web or another resource to expand
the tag representation. Evaluate the effectiveness of the two algorithms on a set of
10–25 tags. Describe the algorithms, evaluation metrics, tag set, and results.

10.3. Compute five iterations ofHITS (seeAlgorithm3) and PageRank (see Fig-
ure 4.11) on the graph in Figure 10.3. Discuss how the PageRank scores compare
to the hub and authority scores produced by HITS.

10.4. Describe two examples of online communities that were not already dis-
cussed in this chapter. How can the community-finding algorithms presented in
this chapter be used to detect each?

10.5. Find a community-based question answering site on the Web and ask two
questions, one that is low-quality andone that is high-quality.Describe the answer
quality of each question.

10.6. Find two examples of document filtering systems on theWeb.How do they
build a profile for your information need? Is the system static or adaptive?

10.7. List the basic operations an indexer must support to handle the following
tasks: 1) static filtering, 2) adaptive filtering, and 3) collaborative filtering.

10.8. Implement the nearest neighbor–based collaborative filtering algorithm.
Using a publicly available collaborative filtering data set, compare the effective-
ness, in terms of mean squared error, of the Euclidean distance and correlation
similarity.

10.9. Both the clustering andnearest neighbor–based collaborative filtering algo-
rithms described in this chapter make predictions based on user/user similarity.
Formulate both algorithms in terms of item/item similarity.Howcan the distance
between two items be measured?

10.10. Form a group of 2–5 people and use a publicly available collaborative
search system.Describe your experience, including thepros and cons of using such
a system.



450 10 Social Search

10.11. Suggest how the maximum and minimum resource ranking scores,Rmax
andRmin, could be estimated for a given query.

10.12. Use the rank-based version of CombMNZ to combine the results of two
search engines for a sample set of queries. Evaluate the combined ranking and
compare its effectiveness to the two individual result lists.

10.13. Choose your favorite file-sharing application and find out how it works.
Describe it and compare it to the P2P networks mentioned in this chapter.

10.14. In a P2P network with small-world properties, any two nodes are likely
to be connected by a small number of hops. These networks are characterized by
a node having local connections to nodes that are “close” and a few long-range
connections to distant nodes, where distance can be measured by content simi-
larity or some other attribute, such as latency. Do you think Gnutella 0.4 or 0.6
would have content-based small-world properties? What about a structured net-
work based on Chord?



11
Beyond Bag of Words

“It means the future is here, and all bets are off.”

Agent Mulder,The X-Files

11.1 Overview

The term “bag of words” is used to refer to a simple representation of text that is
used in retrieval and classification models. In this representation, a document is
considered to be an unordered collection of words with no relationships, either
syntactic or statistical, between them.1 Many of the retrieval models discussed in
Chapter 7, such as the query likelihood model, the BM25 model, and even the
vector space model, are based on a bag of words representation. From a linguistic
point of view, the bag of words representation is extremely limited. No one could
read a sorted bag of words representation and get the same meaning as normal
text.The sorted version of the last sentence, for example, is “a and as bag could get
meaning no normal of one read representation same sorted text the words”.

Despite its obvious limitations, the bag of words representation has been very
successful in retrieval experiments compared to more complex representations of
text content. Incorporating even simple phrases and word proximity into a word-
based representation, which would seem to have obvious benefits, took many
years of research before retrieval models were developed that had significant and
consistent effectiveness benefits. Search applications, however, have evolved be-
yond the stage where a bag of words representation of documents and queries
would be adequate. For these applications, representations and ranking based on
many different features are required. Features derived from the bag of words are
still important, but linguistic, structural, metadata, and non-textual content fea-
tures can also be used effectively in retrieval models such as the inference network

1 In mathematics, a bag is like a set, but duplicates (i.e., multiple occurrences of a word)
are allowed.



452 11 Beyond Bag of Words

or the ranking SVM.We start this chapter by examining the general properties of
a feature-based retrieval model.

In previous chapters we have discussed a number of representation features
and how they can be used in ranking. In this chapter, we look at four aspects of
representation in more detail and describe how they could affect the future de-
velopment of search engines. Bag of wordsmodels assume there is no relationship
between words, so we first look at how term dependencies can be captured and
used in a linear feature-based model. Document structure is ignored in a bag of
words representation, but we have seen how it can be important in web search.
The second aspect of representation we look at is how the structured representa-
tions used in a database system could be used in a search engine. In a bag of words
representation, queries are treated the same as documents. In question-answering
applications, however, the syntactic structure of the query can be particularly im-
portant. The third aspect of representation we look at is how query structure is
used to answer questions. Finally, bags of words are based on words, and there are
many applications, such as image search or music search, where the features used
to represent the objects that are retrieved may not be words. The fourth aspect of
representation we look at is what these non-text features could be, and how they
are used in ranking.

In the final section of this chapter, we indulge in some mild (not wild) specu-
lation about the future of search.

11.2 Feature-Based Retrieval Models

Wedescribed feature-based retrievalmodelsbriefly inChapter 7, andprovidemore
detail here because of their growing importance as the basis for modern search
engines.

For a set of documents D and a set of queries Q, we can define a scoring or
ranking functionS?(D;Q) parameterized by?, which is a vector of parameters.
Given a queryQi, the scoring function S?(D;Qi) is computed for eachD ? D,
and documents are then ranked in descending order according to their scores.
For linear feature-based models, we restrict the scoring function to those with
the form:

S?(D;Q) =
?
j

?j · fj(D,Q) + Z

where fj(D,Q) is a feature function that maps query/document pairs to real
values, and Z is a constant that does not depend on D (but may depend on ?



11.2 Feature-Based Retrieval Models 453

or Q). The feature functions correspond to the features that we have previously
mentioned. Although some models permit non-linear combinations of features,
the scoring functions that have been used in research and applications to date are
based on linear combinations. For this reason, we focus here on linear feature-
based models. Note that this ranking function is a generalization of the abstract
ranking model that we described in Chapter 5.

In addition to defining the form of the scoring function, we also need to spec-
ify the method for finding the best values for the parameters. To do this, we need
a set of training data T and an evaluation function E(R?; T ), whereR? is the
set of rankings produced by the scoring function for all the queries. The evalu-
ation function produces real-valued output given the set of ranked lists and the
training data. Note that E is only required to consider the document rankings
and not the document scores. This is a standard characteristic of the evaluation
measures described in Chapter 8, such as mean average precision, precision at 10,
or NDCG.

The goal of a linear feature-based retrieval model is to find a parameter setting
? thatmaximizes the evaluationmetricE for the training data. Formally, this can
be stated as:

?? = arg max
?

E(R?; T )

where R? are the rankings produced by the linear scoring function
?

j ?j ·
fj(D,Q) + Z .

For a small number of features, the optimal parameter values can be found by
a brute-force search over the entire space of possible values. For larger numbers of
features, an optimization procedure, such as that provided by the Ranking SVM
model, is needed.Thekey advantages of the linear feature-basedmodels compared
to other retrieval models are the ease with which new features can be added to the
model, and efficient procedures for optimizing effectiveness given training data.
It is these advantages that make linear feature-based models the ideal framework
for incorporating the range of representation features we discuss in this chapter.

A relatively small number of features have been used as the basis of the retrieval
models described in Chapter 7 that focus on topical relevance. These include:

• Term occurrence: whether or not a term occurs within a document
• Term frequency: number of times a term occurs within a document
• Inverse document frequency: inverse of the proportion of documents that con-

tain a given term
• Document length: number of terms in a document



454 11 Beyond Bag of Words

• Term proximity: occurrence patterns of terms within a document (the most
common way of incorporating term dependency)

The Galago query language (and the inference network model it is based on)
provides a means of specifying a range of features and scoring documents based
on aweighted linear combination of these features. Galago ismore general in that
it also supports the definition and combination of arbitrary features using the
#feature operator. For example, using this operator, it is possible to have a fea-
ture based on the BM25 term-weighting function as part of the scoring function.
Galago, like the inference networkmodel, does not specify a particular optimiza-
tion method for finding the best parameter values (i.e., the feature weights).

11.3 Term Dependence Models

In Chapter 4, we discussed the potential importance of relationships between
words that are part of phrases. In Chapter 5, we showed how term proximity in-
formation can be incorporated into indexes. Chapter 6 described techniques for
measuring the association between words, and Chapter 7 showed how term rela-
tionships can be expressed in the Galago query language. Exploiting the relation-
ships between words is clearly an important part of building an effective search
engine, especially for applications such as web search that have large numbers of
documents containing all ormost of the query words. Retrievalmodels thatmake
use of term relationships are often called term dependence models because they do
not assume that words occur independently of each other. More generally, term
dependence information can be incorporated into a number of features that are
used as part of the ranking algorithm.

TheGalago implementation of web search described in section 7.5 is based on
a specific linear feature-basedmodel known as theMarkov Random Field (MRF)
model (Metzler & Croft, 2005b). This model, in addition to allowing arbitrary
features, explicitly represents dependencies between terms. Although a number
of term dependence models have been proposed, we describe the MRF model
because it has produced significant effectiveness benefits in both document rank-
ing and in the related process of pseudo-relevance feedback (Metzler & Croft,
2007a).

The MRF model works by first constructing a graph that consists of a docu-
ment node and one node per query term.These nodes represent random variables
within a Markov random field, which is a general way of modeling a joint distri-



11.3 Term Dependence Models 455

bution. Thus, in the MRF model, the joint distribution over the document ran-
domvariable and query term randomvariables is beingmodeled.Markov random
fields are typically represented as graphs, by what is known as a graphical model.
In particular, MRFs are undirected graphical models, which means the edges in
the graph are undirected. The inference network model described in Chapter 7
was an example of a directed graphical model.

q1 q2 q3

D

q1 q2 q3

D

q1 q2 q3

D

q1 q2 q3

D

Fig. 11.1. Example Markov Random Field model assumptions, including full indepen-
dence (top left), sequential dependence (top right), full dependence (bottom left), and
general dependence (bottom right)

TheMRFmodels dependencies between randomvariables by drawing an edge
between them. Since the importance of query terms depends on the document,
the document node is always connected to every query term node. It is straight-
forward to model query term dependencies by drawing edges between the query
term nodes.There are several possible ways to determine which query term nodes
to draw an edge between. These different cases are summarized in Figure 11.1. In
the simplest case, no edges are drawn between the query terms. This corresponds
to the full independence assumption, where no dependencies exist between the
query terms. This is analogous to a unigram language model or any of the bag of
words models described in Chapter 7. Another possibility is to draw edges be-
tween adjacent query terms. This is known as the sequential dependence assump-



456 11 Beyond Bag of Words

tion. Here it is assumed that adjacent terms are dependent on each other, but not
on terms that are farther away. This type of assumption is similar to a bigram lan-
guage model. Another possible assumption is that all terms are somehow depen-
dent on all other terms.This is known as the full dependence assumption.The final
possibility is that edges are drawn between the query terms in some meaningful
way, such as automatically or manually identifying terms that are dependent on
each other. This is referred to as general dependence. In practice, however, it has
been shown that using the sequential dependence assumption is the best option.
In fact, all attempts tomanually or automatically determinewhich terms tomodel
dependencies between have come up short against using the simple assumption
that adjacent terms are dependent on each other.

After theMRF graph has been constructed, a set of potential functionsmust be
defined over the cliques of the graph. The potential functions are meant to mea-
sure the compatibility between the observed values for the random variables in
the clique. For example, in the sequential dependence graph shown inFigure 11.1,
a potential function over the clique consisting of the terms q1, q2, and D might
compute howmany times the exact phrase “q1 q2” occurs in documentD, or how
many times the two terms occur within some window of each other. Therefore,
these potential functions are quite general and can compute a variety of differ-
ent features of the text. In this way, the MRF model is more powerful than other
models, such as language modeling or BM25, because it allows dependencies and
arbitrary features to be included in a straightforward manner.

By constructing queries that have a particular form, the Galago search engine
can be used to emulate one of the instantiations of the MRF model that has been
very effective in TREC experiments. This approach was also used in section 7.5.
For example, given the query president abraham lincoln, the full independence
MRF model is computed using the following query:

#combine(president abraham lincoln)

Notice that this is the most basic formulation possible and does not consider
any dependencies between terms.The sequential dependenceMRFmodel can be
computed by issuing the following query:

#weight(0.8 #combine(president abraham lincoln)
0.1 #combine(#od:1(president abraham)

#od:1(abraham lincoln)
0.1 #combine(#uw:8(president abraham)

#uw:8(abraham lincoln)



11.3 Term Dependence Models 457

This query formulation consists of three parts, each of which corresponds to
a specific feature type used within the MRF model. The first part scores the con-
tribution of matching individual terms. The second part scores the contribution
of matching subphrases within the query. This gives higher weight to documents
that match “president abraham” and “abraham lincoln” as exact phrases. Notice
that these phrases only consist of adjacent pairs of query terms, because the se-
quential dependence model only models dependencies between adjacent query
terms. The first part of the formulation scores the contribution of matching un-
ordered windows of adjacent query terms. In particular, if the terms “president”
and “abraham” occur within a window of eight terms of each other in any or-
der, then the document’s score will be boosted. Notice that each component is
weighted, with the individual term component having weight 0.8 and the exact
phrase and unordered window components being weighted 0.1. These weights,
which were derived empirically, show the relative importance of matching indi-
vidual terms versus matching phrase and proximity features within text. The in-
dividual terms are by far the most important things to match, although the other
features play an important role.

The algorithm for converting a plain text queryQ to a sequential dependence
MRF query in Galago is very simple. The first component (for individual terms)
is simply #combine(Q). The second component puts every adjacent pair of query
terms in a #od:1 operator, and then combines all such operators with a #com-
bine. The third and final component puts every adjacent pair of query terms into
a #uw:8 operator, and again combines them with a #combine operator. The three
components are then givenweights 0.8, 0.1, and 0.1, as described earlier, and com-
bined within a #weight operator.

Finally, the full dependence MRF model is much more complex, since many
more dependencies are modeled. However, we show the full dependence MRF
model query for the sake of completeness here:

#weight(0.8 #combine(president abraham lincoln)
0.1 #combine(#od:1(president abraham)

#od:1(abraham lincoln)
#od:1(president abraham lincoln))

0.1 #combine(#uw:8(president abraham)
#uw:8(abraham lincoln)
#uw:8(president lincoln)
#uw:12(president abraham lincoln)))



458 11 Beyond Bag of Words

It is important to note that the #combine operator used in all of the exam-
ples here could easily be replaced with the #feature operator in order to compute
the individual term, exact phrase, and unordered phrase features differently. For
example, one could implement BM25 weighting using #feature and compute a
dependence model based on it instead of Galago’s default weighting.

The MRF model can also be used to model dependencies in pseudo-relevance
feedback, which is an important technique for query expansion that we described
in section 7.3.2. Figure 11.2 compares a graphical model representation of the rel-
evance model technique used for pseudo-relevance feedback with the MRF ap-
proach, which is known as latent concept expansion.2 The relevance model graph
(the top one) represents a bag of words, or unigram,model where words occur in-
dependently of each other, given a particular document. Pseudo-relevance feed-
back uses a set of highly ranked documents to estimate the probability of expan-
sion words (the questionmarks) given the query words.Thewords with the high-
est probability are added to the query.

In the lower latent concept expansion graph, there are dependencies rep-
resented between query words and expansion words. The process of pseudo-
relevance feedback is still the same, in that highly ranked documents are used to
estimate the probabilities for possible expansionwords, but the dependencies will
change theway that those probabilities are estimated and generally produce better
results. By modeling dependencies between the expansion words, the latent con-
cept expansion model can produce multiword phrases as expansion terms rather
than only words. As an example, Table 11.1 shows the top-ranked one- and two-
word concepts produced by the latent concept expansion model for the query
“hubble telescope achievements”.

To summarize, theMRFmodel,which is a linear feature-based retrievalmodel,
is an effective method of incorporating features based on term dependence in the
scoring function used to rank documents. Latent concept expansion supports
pseudo-relevance feedback in the MRF framework. Latent concept expansion
can be viewed as a “feature expansion” technique, in that it enriches the original
feature set by including new features based on the expanded query.

2 Latent, or hidden, concepts are words or phrases that users have in mind but do not
mention explicitly when they express a query.



11.4 Structure Revisited 459

hubble telescope achievements ? ?

D

hubble telescope achievements ? ?

D

Fig. 11.2. Graphical model representations of the relevance model technique (top) and
latent concept expansion (bottom) used for pseudo-relevance feedback with the query
“hubble telescope achievements”

11.4 Structure Revisited

The goal of having a common platform for dealing with both structured and un-
structured data is a long-standing one, going back to the 1960s. A number of ap-
proaches have been suggested, both from the database and information retrieval
perspective, but the motivation for finding a solution or solutions that work has
grown tremendously since the advent of very large-scale web databases. Areas that
were once the exclusive concerns of information retrieval, such as statistical infer-
ence and ranking, have now become important topics for database researchers,
and both communities have a common interest in providing efficient indexing
and optimization techniques for web-scale data. Exploiting document structure
is a critical part of web search, and combining different sources of evidence ef-
fectively is an important part of many database applications. There are many pos-
sibilities for integration, such as extending a database model to more effectively
deal with probabilities, extending an information retrieval model to handle more
complex structures andmultiple relations, or developing a unifiedmodel and sys-



460 11 Beyond Bag of Words

1-word concepts 2-word concepts
telescope hubble telescope
hubble space telescope
space hubble space
mirror telescope mirror
NASA telescope hubble
launch mirror telescope

astronomy telescope NASA
shuttle telescope space
test hubble mirror
new NASA hubble

discovery telescope astronomy
time telescope optical

universe hubble optical
optical telescope discovery
light telescope shuttle

Table 11.1. Most likely one- and two-word concepts produced using latent concept ex-
pansion with the top 25 documents retrieved for the query “hubble telescope achieve-
ments” on the TREC ROBUST collection

tem. Applications such as web search, e-commerce, and data mining provide the
testbeds where these systems are being evaluated and compared.

In Chapter 7, we showed how document structure can be handled in the
Galago query language. Froma conventional database perspective, there aremajor
problemswithusingGalago to represent andquerydata.Using relational database
terminology, there is no schema,3 nomeans of defining the data type of attributes,
and no joins between relations.4 Instead, as described inChapter 7, a document is
represented as a (possibly nested) set of contexts defined by tag pairs. Documents
are stored in a simple database with only primary-key access, where the primary
key is the document identifier. The query language supports the definition and
combination of search features based on the structure and contents of the doc-
uments. Different document types with different contexts can be incorporated

3 A schema is a description of the logical structure of the database, which in this case
would be the names of the relations (tables) and the attributes in each relation.

4 A join connects tuples (rows) from two different relations based on one or more com-
mon attributes. An example would be to connect product information with vendor
information based on the product number attribute.



11.4 Structure Revisited 461

into a single Galago database. Each document is indexed only by the contexts it
contains. Although there is no way of defining the data type of contexts, opera-
tors associatedwith a specific data type could be defined and applied to particular
contexts. For example, a date range operator could be applied to a context that
contains the creation date for a document.

Although this is very different from the functionality of a full relational data-
base system, in many applications involving search engines this additional func-
tionality is not needed. The BigTable storage system described in Chapter 3, for
example, does not have data types or joins. Additionally, it has only a very simple
specification of tuple and attribute names. Systems such as BigTable focus on pro-
viding data persistence and reliable access to data in an environment where many
components can fail, and scalable performance using distributed computing re-
sources. Access to the data is provided through a simple API that allows client
applications to read, write, or delete values. Figure 11.3 summarizes the functions
provided by the search engine and the database system in applications such as web
search or e-commerce. Note that the indexes created by the search engine are not
stored in the database system.

Search Engine

!indexing

!query language

!ranking

!scalability

Database

!persistence

!reliability

!scalability

simple API

Fig. 11.3.Functions providedby a search engine interactingwith a simple database system

11.4.1 XML Retrieval

XML is an important standard for both exchanging data between applications
and encoding documents. To support this more data-oriented view, the database
communityhas defined languages for describing the structure ofXMLdata (XML
Schema), and querying andmanipulating that data (XQuery andXPath). XQuery
is a query language that is similar to the database language SQL, with the major
difference that it must handle the hierarchical structure of XML data instead of



462 11 Beyond Bag of Words

the simpler tabular structure of relational data.XPath is a subset ofXQuery that is
used to specify the search constraints for a single type of XML data or document.
XPath, for example, could be used in an XML movie database to find the movies
that were directed by a particular person and were released in a particular year.
XQuery could be used to combine information about movies with information
about actors, assuming that the XML movie database contained both movie and
actor “documents.” An example would be to findmovies starring actors who were
born in Australia.

Complex database query languages, such as XQuery, that focus on the struc-
ture of data and combining data are generally less useful in text search applica-
tions. The extent to which structure is useful in queries for databases of XML
documents has been studied in the INEX project.5 This project has taken a simi-
lar approach to TREC for search evaluation. This means that a number of XML
search tasks have been defined, and appropriate test collections constructed for
evaluating those tasks. One type of query used in these evaluations is the content-
and-structure (CAS) query. These queries contain a description of a topic and ex-
plicit references to the XML structure. CAS queries are specified using a simpli-
fied version of XPath calledNEXI.6 The two important constructs in this query
language are paths and path filters. A path is a specification of an element (or node)
in the XML tree structure. Some examples of path specifications in NEXI are:

//A//B - any B element7 that is a descendant of an A element in the XML
tree. A descendant element will be contained in the parent element.
//A/* - any descendant element of an A element.

A path filter restricts the results to those that satisfy textual or numerical con-
straints. Some examples are:

//A[about(.//B,”topic”)] - A elements that contain a B element that is about
“topic”.The about predicate is not defined, but is implemented using some
type of retrieval model. .//B is a relative path.
//A[.//B = 777] - A elements that contain a B element with value equal to
777.

5 INitiative for the Evaluation of XML Retrieval, http://inex.is.informatik.uni-
duisburg.de/.

6 Narrowed Extended XPath (Trotman & Sigurbjörnsson, 2004).
7 This means an element that has a start tag <B> and an end tag </B>.



11.4 Structure Revisited 463

The database used in the earlier INEX experiments consisted of technical ar-
ticles from computer science publications. The following are examples of some of
the CAS queries:

//article[.//fm/yr < 2000]//sec[about(.,”search engines”)]
- find articles published before 2000 (fm is the front matter of the article)
that contain sections discussing the topic “search engines”.

//article[about(.//st,+comparison) AND about (.//bib,”machine learning”)]
- find articles with a section title containing the word “comparison” and
with a bibliography that mentions “machine learning”.

//*[about(.//fgc, corba architecture) AND about(.//p, figure
corba architecture)]
- find any elements that contain a figure caption about “corba architecure”
and a paragraph mentioning “figure corba architecture”.

Although these queries seem reasonable, INEX experiments and previous re-
search indicate that people do not use structural cues in their queries or, if they are
forced to, generally will use them incorrectly.There is essentially no evidence that
structure in user queries improves search effectiveness. For this reason, the INEX
project has increasingly focused on content-only queries, which are the same as
the queries we have been discussing throughout this book, and on techniques for
automatically ranking XML elements rather than documents.

To summarize, structure is an important part of defining features for effective
ranking, but not for user queries. In applications such asweb search, relatively sim-
ple user queries are transformed into queries that involvemany features, including
features based on document structure. The Galago query language is an example
of a language that can be used to specify the features that are used for ranking, and
user queries can be transformed into Galago queries. Most of the structural cues
that can be specified in NEXI can be incorporated into features using Galago.

Database systems are used in many search applications. The requirements for
these applications, however, are different than those for typical database applica-
tions, such as banking. This has led to the development of storage systems that
are simple from a database schema and query language perspective, but are also
efficient, reliable, and scalable.



464 11 Beyond Bag of Words

11.4.2 Entity Search

In addition to exploiting the existing structure in documents, it is also possible to
create structure by analyzing the document contents. In Chapter 4, we described
information extraction techniques that canbe used to identify entities in text such
as people, organizations, and locations.Entity search uses this structure to provide
a ranked list of entities in response to a query instead of a list of documents. To do
this, a representation for each entity is generated based on the words that occur
near the entity in the document texts. The simplest approach to building these
representations is to create “pseudo-documents” by accumulating all words that
occur within a specified text window (e.g., 20 words) for each occurrence of an
entity. For example, if the organization entity “california institute of technology”
occurred 65 times in a corpus, every word within 20 words of those 65 occur-
rences would be accumulated into the pseudo-document representation. This is
the approach used in the early research on entity search, such as Conrad and Utt
(1994). These large word-based representations can be stored in a search engine
and then used to rank entities in response to a query.

Figure 11.4 shows an example of entity retrieval given in the Conrad paper.
The top-ranked organizations for this query will have co-occurred with words
such as “biomedical” a number of times in the corpus.

Query:  

biomedical research and technology

Top Ranked Results:

minneapolis research   

signs inc.

syntex

california institute of technology

massachusetts institute of technology

therapeutic products

Fig. 11.4.Example of an entity search for organizations using theTRECWall Street Jour-
nal 1987 Collection

Theapproach of building representations fromwords that occur in the context
or locality of a target word or phrase (sometimes called context vectors) has been
used to automatically build a thesaurus that retrieves words and phrases for query



11.4 Structure Revisited 465

expansion (Jing & Croft, 1994). Interestingly, it has also been used by cognitive
scientists as the basis for a model of semantic memory (Lund & Burgess, 1996).

Much of the recent research on entity search has focused onmethods for find-
ing people who have expertise in a particular area or topic. This task, known as
expert search, has been studied for some time but has been evaluated more thor-
oughly since it became part of a TREC track in 2005. The main contribution of
this research has been the development of probabilistic retrieval models for enti-
ties (or experts) based on the languagemodeling approach (Balog et al., 2006). In
general, given a set of documentsD and a query q, we can rank candidate entities
e by the joint distribution P (e, q) of entities and query terms. We can represent
this distribution as:

P (e, q) =
?
d?D

P (e, q|d)P (d)

If we focus on the P (e, q|d) term, the problem of entity ranking can be decom-
posed into two components:

P (e, q|d) = P (q|e, d)P (e|d)

where theP (e|d) component corresponds to finding documents that provide in-
formation about an entity, and the P (q|e, d) component involves ranking en-
tities in those documents with respect to a query. Different ways of estimating
these probabilities result in different entity ranking algorithms. If we assume
that words and entities are independent given a document, then P (e, q|d) =
P (q|d)P (e|d), and the two components could be computed separately by using
q and e as queries for probabilistic retrieval.This assumption, however, ignores the
relationshipbetweenwords and entities that appear in the samedocument (which
is captured in the context vector approach) and consequently the effectiveness of
the method suffers. Instead, we can estimate the strength of association between
e and q using the proximity of co-occurrence of the query words and the entities
in a document. One way to do this, assuming a query consisting of a single term
and a single entity occurrence in a document, is to estimate P (q|e, d) as:

P (q|e, d) = 1
Z

N?
i=1

?d(i, q)k(q, e)

where ?d is an indicator function that is 1 when the term at position i in d is q and
0 otherwise, k is a proximity-kernel function,Z =

?N
i=1 k(q, e) is a normalizing

constant, andN is the length of the document.



466 11 Beyond Bag of Words

If the query has multiple terms, we can compute the ranking score as follows:

P (e, q)
rank
=
?
qi?q

{?
d?D

P (qi|e, d)P (e|d)

}

Petkova and Croft (2007) showed that the most effective kernel function is
the Gaussian kernel, which is shown in Table 9.1 and, in this case, is

exp?||q ? e||2/2?2

where q ? e is the distance in words between the query q and the entity e. This
paper also showed that, for expert search, accurate named entity recognition does
not have a large effect on performance and that using a simple Galago query such
as #od:2( <first name> <last name>) works well for estimating P (e|d) for people
entities.

11.5 Longer Questions, Better Answers

In nearly all visions of the future that we see inmovies or on television, the search
engine, disguised as a computer system such as HAL 9000 in 2001: A Space
Odyssey or theComputer in the Star Trek series, has evolved into a human-like as-
sistant that can answer complex questions about any subject.Althoughweb search
engines provide access to a huge range of information, we are still a long way from
achieving the capabilities of these intelligent assistants. One obvious difference is
that queries to web search engines are generally formulated as a small number of
keywords, rather than as actual questions expressed in natural language. In Chap-
ter 10, we described how people who use community-based question answering
systems describe their information needs in sentences, or even paragraphs, be-
cause they know that other people will read them and give better responses if the
problem is described well. In contrast, the same long queries will generally pro-
duce very poor responses or nothing at all from a web search engine. People are
forced to translate their problem into one or more appropriate keywords to get a
reasonable result list. A long-term goal of information retrieval research is to de-
velop retrieval models that produce accurate results from a longer, more specific
query.

The task of question answering, which we mentioned briefly in Chapter 1 and
again in Chapter 10, involves providing a specific answer to a user’s query, rather



11.5 Longer Questions, Better Answers 467

than a ranked list of documents.This task has a long history in the fields of natural
language processing and artificial intelligence. Early question answering systems
relied on detailed representations in logic of small, very specific domains such as
baseball, lunar rocks, or toy blocks. More recently, the focus has shifted to an in-
formation retrieval perspective where the task involves identifying or extracting
answers found in large corpora of text.

Passage 

Retrieval
Answer

Selection

Answer 

Features

Query

Question

Analysis/

Classification

Corpus/Web

AnswersQuestion

Fig. 11.5. Question answering system architecture

Figure 11.5 shows the typical components of a question answering system that
retrieves answers from a text corpus. The range of questions that is handled by
such a system is usually limited to fact-based questions with simple, short answers,
such as who, where, and when questions that have people’s names, organization
names, places, and dates as answers. The following questions are a sample from
the TREC question answering (QA) track:8

Who invented the paper clip?
Where is the Valley of the Kings?
When was the last major eruption of Mt. St. Helens?

There are, of course, other types of fact-based questions that could be asked,
and they can be asked in many different ways. The task of the question analysis
and classification component of the system is to classify a question by the type of
answer that is expected. For the TREC QA questions, one classification that is
frequently used has 31 different major categories,9 many of which correspond to

8 The TREC QA questions were drawn from the query logs of a variety of search appli-
cations (Voorhees & Harman, 2005).

9 This is the question classification created by BBN. This classification and others are
discussed in Metzler and Croft (2005a).



468 11 Beyond Bag of Words

named entities (see Chapter 4) that can be automatically identified in text. Table
11.2 gives an example of a TREC question for each of these categories. Question
classification is a moderately difficult task, given the large variation in question
formats. The question word what, for example, can be used for many different
types of questions.

The information derived from question analysis and classification is used by
the answer selection component to identify answers in candidate text passages,
which are usually sentences. The candidate text passages are provided by the pas-
sage retrieval component based on a query generated from the question. Text
passages are retrieved from a specific corpus or the Web. In TREC QA experi-
ments, candidate answer passages were retrieved from TREC news corpora, and
the Web was often used as an additional resource. The passage retrieval compo-
nent of many question answering systems simply finds passages containing all the
non-stopwords in the question. In general, however, passage retrieval is similar to
other types of search, in that features associated with good passages can be com-
bined to produce effective rankings. Many of these features will be based on the
question analysis. Text passages containing named entities of the type associated
with the question category as well as all the important question words should ob-
viously be ranked higher.

For example, with the question “where is the valley of the kings”, sentences
containing text tagged as a location and the words “valley” and “kings” would be
preferred. Some systems identify text patterns associated with likely answers for
the question category, using either text mining techniques with the Web or pre-
defined rules. Patterns such as <question-location> in <location>, where question-
location is “valley of the kings” in this case, often may be found in answer pas-
sages.The presence of such a pattern should improve the ranking of a text passage.
Another feature that has been shown to be useful for ranking passages is related
words from a thesaurus such as Wordnet. For example, using Wordnet relations,
words such as “fabricates”, “constructs”, and “makes” can be related to “manu-
factures” when considering passages for the question “who manufactures magic
chef appliances”. A linear feature-based retrieval model provides the appropriate
framework for combining features associated with answer passages and learning
effective weights.

The final selection of an answer from a text passage can potentially involve
more linguistic analysis and inference than is used to rank the text passages. In
most cases, however, users of a question answering system will want to see the
context of an answer, or even multiple answers, in order to verify that it appears



11.5 Longer Questions, Better Answers 469

Example Question Question Category
What do you call a group of geese? Animal
Who was Monet? Biography
How many types of lemurs are there? Cardinal
What is the effect of acid rain? Cause/Effect
What is the street address of the White House? Contact Info
Boxing Day is celebrated on what day? Date
What is sake? Definition
What is another name for nearsightedness? Disease
What was the famous battle in 1836 between
Texas and Mexico? Event
What is the tallest building in Japan? Facility
What type of bridge is the Golden Gate Bridge? Facility Description
What is the most popular sport in Japan? Game
What is the capital of Sri Lanka? Geo-Political Entity
Name a Gaelic language. Language
What is the world’s highest peak? Location
How much money does the Sultan of Brunei have? Money
Jackson Pollock is of what nationality? Nationality
Who manufactures Magic Chef appliances? Organization
What kind of sports team is the Buffalo Sabres? Org. Description
What color is yak milk? Other
How much of an apple is water? Percent
Who was the first Russian astronaut to walk in space? Person
What is Australia’s national flower? Plant
What is the most heavily caffeinated soft drink? Product
What does the Peugeot company manufacture? Product Description
How far away is the moon? Quantity
Why can’t ostriches fly? Reason
What metal has the highest melting point? Substance
What time of day did Emperor Hirohito die? Time
What does your spleen do? Use
What is the best-selling book of all time? Work of Art

Table 11.2. Example TREC QA questions and their corresponding question categories



470 11 Beyond Bag of Words

to be correct or possibly to make a decision about which is the best answer. For
example, a system might return “Egypt” as the answer to the Valley of the Kings
question, but it would generally be more useful to return the passage “The Val-
ley of the Kings is located on the West Bank of the Nile near Luxor in Egypt.”
From this perspective, we could view search engines as providing a spectrum of
responses for different types of queries, from focused text passages to entire doc-
uments. Longer, more precise questions should produce more accurate, focused
responses, and in the case of fact-oriented questions such as those shown in Table
11.2, this will generally be true.

The techniques used in question answering systems show how syntactic and
semantic features can be used to obtain more accurate results for some queries,
but they do not solve the more difficult challenges of information retrieval. A
TREC query such as “Where have dams been removed and what has been the
environmental impact?” looks similar to a fact-based question, but the answers
need to be more comprehensive than a list of locations or a ranked list of sen-
tences. On the other hand, using question answering techniques to identify the
different text expressions for dam removal should be helpful in ranking answer
passages or documents. Similarly, a TREC query such as “What is being done
to increase mass transit use?”, while clearly not a fact-based question, should also
benefit from techniques that could recognize discussions about the use of mass
transit.These potential benefits, however, have yet to be demonstrated in retrieval
experiments, which indicates that there are significant technical issues involved in
applying these techniques to large numbers of queries. Search engines currently
rely on users learning, based on their experience, to submit queries such as “mass
transit” instead of the more precise question.

11.6 Words, Pictures, and Music

Although information retrieval has traditionally focused on text, much of the in-
formation that people are looking for, particularly on the Web, is in the form of
images, videos, or audio. Web search engines, as well as a number of other sites,
provide searches specifically for images and video, and online music stores are a
very popular way of finding music. All of these services are text-based, relying on
titles, captions, user-supplied “tags,” and other related text to create representa-
tions of non-text media for searching. This approach can be effective and is rel-
atively straightforward to implement. In some cases, however, there may not be



11.6 Words, Pictures, and Music 471

any associated text, or the textmay not capture important aspects of the object be-
ing represented.Many of the videos stored at video-sharing sites do not have good
textual descriptions, for example, and because there are somany of them, user tags
do not solve this problem.Another example is that titles do not provide an appro-
priate description for searching music files to find a particular melody. For these
situations, researchers have been developing content-based retrieval techniques for
non-text media.

Some non-text media use words to convey information and can be converted
into text. Optical character recognition (OCR) technology, for example, is used
to convert scanned documents containing written or printed text into machine-
readable text. Speech recognition technology10 is used to convert recorded speech
(or spoken documents) into text. Both OCR and speech recognition produce
“noisy” text, meaning that the text has errors relative to the original printed text
or speech transcript. Figure 11.6 shows two examples of the errors produced by
OCR. In both cases, the OCR output was produced by off-the-shelf OCR soft-
ware. The first example is based on a text passage created using a word proces-
sor, printed, copied multiple times (to reduce the quality), and finally scanned
for OCR. The resulting output has some small errors, but in general theOCR er-
ror rate for high-quality printed text is low. The second example uses much lower
quality11 input that was created by scanning a photocopy of an old conference pa-
per. In this case, the OCR output contains significant errors, with words such as
“sponsorship” and “effectiveness” being virtually unreadable. Note that OCR er-
rors occur at the character level. In otherwords, the errors are a result of confusion
about individual characters and cause the output of incorrect characters.

Figure 11.7 shows the output of high-quality speech recognition software for
a news broadcast. Most words are recognized correctly, but when the system en-
counters words that it has not seen before (known as out-of-vocabulary, or OOV,
words), it makes some significant errors. Many of the OOV words come from
personal or organization names, such as “Pinochet” in this example, and consid-
erable research effort has gone into addressing this problem. Note that speech
recognition errors tend to create new words in the output, such as “coastal fish”
in the example, since the software attempts to find known words that best match
the sound patterns as well as a language model. Both this type of error and the

10 Sometimes referred to as ASR (Automatic Speech Recognition).
11 By “quality” we mean image quality measured in terms of contrast, sharpness, clean

background, etc.



472 11 Beyond Bag of Words

Original: 

   

OCR: 

   The fishing supplier had many items in stock, including a large variety of  

   tropical fish and aquariums ot aH sizes~ 

 

Original: 

   

OCR: 

   This work was carried out under the sp011J!0rship 01 NatiolUl1 Setenee 

   Foundation 0rant. NSF!0N!SB0 (Studl .. In Indexing Depth and Retrieval 

   Eflccth”ene&&) and NSF!0N!482 (Requirements Study lor Future ‘Catalogs)• 

Fig. 11.6. Examples of OCR errors

character-level errors from OCR have the potential to reduce the effectiveness of
search.

A number of evaluations with OCR and ASR data have been done at TREC
and other forums. These studies indicate that retrieval effectiveness generally is
not significantly impacted by OCR or ASR errors. The main reason for this is
the large amount of redundancy in the collections that are used for these eval-
uations. For example, in ASR evaluations, there are often many relevant spoken
documents that each contain many instances of the important words for a query.
Even if some instances of words are not recognized, other instances may be. In
addition, even if a query word is consistently not recognized, there are usually a
number of other words in the query that can be used to estimate relevance. A sim-
ilar situation occurs withOCRdata, where some instances of a word in a scanned
document may be of higher image quality than others, and thus will be recog-
nized successfully. The only situation where OCR and ASR errors were shown
to significantly reduce effectiveness was with short documents, which have little
redundancy, and in environments with high error rates. Techniques such as char-
acter n-gram indexing and expansionwith related terms can improveperformance
in these situations.



11.6 Words, Pictures, and Music 473

Transcript: 

French prosecutors are investigating former Chilean strongman Augusto  

Pinochet.  The French justice minister may seek his extradition from 

Britain.  Three French families whose relatives disappeared in Chile 

have filed a Complaint charging Pinochet with crimes against humanity. 

The national court in Spain has ruled crimes committed by the  

Pinochet regime fall under Spanish jurisdiction.   

 

Speech recognizer output: 

french prosecutors are investigating former chilean strongman of 

coastal fish today the french justice minister may seek his 

extradition from britain three french families whose relatives 

disappeared until i have filed a complaint charging tenants say with 

crimes against humanity the national court in spain has ruled crimes 

committed by the tennessee with james all under spanish jurisdiction 

 

Fig. 11.7. Examples of speech recognizer errors

In contrast to media that can be converted to noisy text, content-based re-
trieval of pictures12 is a more challenging problem. The features that can be ex-
tracted from an image, such as color, texture, and shape, have little semantic con-
tent relative to words. For example, one of the common features used in image
retrieval applications is the color histogram. Color in images is represented using
a specific color model, such as RGB.13 The RGB model represents colors as mix-
tures of red, blue, and green, typically with 256 values (8 bits) being used for each
component. A color histogram for an image can be created by first “quantizing”
the color values to reduce the number of possible “bins” in the histogram. If the
RGBvalues are quantized into 8 levels instead of 256 levels, for example, the num-
ber of possible color combinations is reduced from 256×256×256 to 8×8×8 =
512 values or bins. Then, for each pixel in the image, the bin corresponding to
the color value for that pixel is incremented by one. The resulting histogram can
be used to represent the images in a collection and also be indexed for fast re-
trieval. Given a new image as a query, the color histogram for that image would
be comparedwith the histograms from the image collection using some similarity
measure, and images would be ranked using the similarity values.

12 Also known as content-based image retrieval (CBIR).
13 Another common model is HSV (Hue, Saturation, and Value).



474 11 Beyond Bag of Words

Fig. 11.8.Two images (a fish and a flower bed)with color histograms.Thehorizontal axis
is hue value.

Figure 11.8 shows two example images and their color histograms. In this case,
the histogram is based only on hue values (rather than RGB values), so the peaks
in the histogram correspond to peaks in colors. Both the fish and the flowers are
predominantly yellow, so both histograms have a similar peak in that area of the
spectrum (on the left). The other smaller peaks are associated with greens and
blues.

The color feature is useful for finding images with strong color similarity, such
as pictures of sunsets, but two pictures with completely different content can be
considered very similar based solely on their colors. The picture of the flowers in
Figure 11.8, for example, may be ranked highly in comparison with the picture of
the fish because of the similar peaks in the histograms. The ability to find seman-
tically related images can be improved by combining color features with texture
and shape features. Figure 11.9 shows two examples of image retrieval based on
texture features (the cars and the trains), and one example of retrieval based on
shape features (the trademarks). Texture is broadly defined as the spatial arrange-
ment of gray levels in the image, and shape features describe the form of object
boundaries and edges. The examples show that images with similar appearance
can generally be found using these types of representations, although the second



11.6 Words, Pictures, and Music 475

Fig. 11.9. Three examples of content-based image retrieval. The collection for the first
two consists of 1,560 images of cars, faces, apes, and other miscellaneous subjects. The
last example is from a collection of 2,048 trademark images. In each case, the leftmost
image is the query.

example makes it clear that similarity in terms of texture does not guarantee se-
mantic similarity. In the case of text-based search, high-ranking documents that
are not relevant can at least be easily understood by the user. With content-based
image retrieval, a retrieval failure such as the picture of the ape in Figure 11.9 will
be difficult to explain to a user who is looking for pictures of trains.

Retrieval experiments have shown that the most effective way of combining
image features is with a probabilistic retrieval model. If images have text captions
or user tags, these features can easily be incorporated into the ranking, as we have
discussed previously. Video retrieval applications are similar to image retrieval,
except that they may have even more features, such as closed caption text or text
generated from speech recognition. The image component of a video is typically
represented as a series of key frame images. To generate key frames, the video is
first segmented into shots or scenes. A video shot can be defined as a continuous
sequence of visually coherent frames, and boundaries can be detected by visual
discontinuities, such a sharp decrease in the similarity of one frame to the next.
Given the segmentation into shots, a single frame (picture) is selected as the key
frame. This can be done simply by using the first frame in each shot, or by more



476 11 Beyond Bag of Words

sophisticated techniques based on visual similarity and motion analysis. Figure
11.10 shows an example of four key frames extracted from a video of a news con-
ference.

Fig. 11.10. Key frames extracted from a TREC video clip

The image retrieval techniques we have discussed assume that the query is an
image. In many applications, users would prefer to describe the images they are
looking for with a text query. Words cannot be compared directly to features de-
rived from the image. Recent research has shown, however, that given enough
training data, a probabilistic retrieval model can learn to associate words or cat-
egories with image-based features and, in effect, automatically annotate images.
There are actually two questions that we need to answer using this model:

- Given an image with no text annotation, how can we automatically assign
meaningful keywords to that image?

- Given a text query {q1, ...qn}, how can we retrieve images that are relevant to
the query?

The relevance model described in section 7.3.2 has been shown to be effective
for this task. Instead of estimating the joint probability of observing a word w
with the query words P (w, q1, . . . qn), the relevance model is used to estimate
P (w, i1, . . . im), where an image is assumed to be represented by a set of image
terms{i1, ...im}.The “vocabulary” of image terms in this approach is constrained
byusing image segmentation and clustering techniques to identify regions that are
visually similar.14 As an example, in one test corpus of 5,000 images, a vocabulary
of 500 image terms was used to represent the images, with each image being de-
scribed by 1–10 terms.The joint probabilities are estimated using a training set of
images that have text annotations. This model can be used to answer both of the
questions just mentioned. To retrieve images for a text query, a process similar to
pseudo-relevance feedback would be followed:
14 One such technique represents images as “blobs” (Carson et al., 1999).



11.6 Words, Pictures, and Music 477

1. Use the text query to rank images that do contain text annotations.
2. Estimate joint probabilities for the image vocabulary given the top-ranked

images.
3. Rerank images using the query expandedwith image terms to find images that

do not have text annotations.

people, pool, 

swimmers, water

fox, forest, 

river, water

cars, formula, 

tracks, wall

clouds, jet, 

plane, sky

Fig. 11.11. Examples of automatic text annotation of images

Alternatively, the joint probability estimates from the training set can be used
to assign keywords to images that do not have annotations. Figure 11.11 shows
examples of images annotated using this approach. Most of the words used to de-
scribe the images are reasonable, although the annotation for the picture of the
bear shows that significant errors can be made. Retrieval experiments using auto-
matic annotation techniques have shown that this approach has promise and can
increase the effectiveness of image and video retrieval in some applications. Sig-
nificant questions remain about the type and size of text and image vocabularies
that will be the most effective.

Music is a media that is even less associated with words than pictures. Pictures
can at least be described by words, and automatic annotation techniques can be
used to retrieve images using text queries. Apart from the title, composer, per-
former, and lyrics, however, it is very difficult to describe a piece of music using
words.Music has a number of representations that are used for different purposes.
Figure 11.12 shows three of these representations for “Fugue #10” composed by
Bach. The first is the audio signal from a performance of the music. This is what
is stored in a compressed form in MP3 files. The second is a MIDI15 represen-
tation that provides a digital specification of “events” in the music, such as the
pitch, intensity, duration, and tempo of musical notes. MIDI is the standard for

15 Musical Instrument Digital Interface



478 11 Beyond Bag of Words

communication between electronic instruments and computers. The third rep-
resentation is conventional musical notation, which contains the most explicit
information, especially for polyphonicmusicmade up ofmultiple parts or voices.

Fig. 11.12.Three representations of Bach’s “Fugue #10”: audio, MIDI, and conventional
music notation

A number of approaches have been developed for deriving index terms for
searching from these basic representations. In the case of audio, one of the most
successful has been the use of “signatures” created by hashing to represent themu-
sic. A signature could be created, for example, based on the peaks in a spectrogram
of the audio in a time slice.16 This type of indexing is the basis of services that can

16 Aspectrogram represents the energy or amplitude of each frequency in the audio signal
at a given time.



11.7 One Search Fits All? 479

identify music based on a short recording captured using a mobile phone (e.g.,
Wang, 2006).

Another popular approach to content-based retrieval of music is query-by-
humming. In this type of system, a user literally sings, hums, or plays a tune, and a
music collection is searched for similar melodies. This type of searching is based
onmusic that has a singlemelody line (monophonic).The query is converted into
a representation of a melody that consists of information such as the sequence of
notes, relative pitches, and intervals between notes. The music in the collection
must also be converted to the same type of representation, and this is most read-
ily done using MIDI as the starting point. The query will be a very noisy repre-
sentation of the relevant melody, so a number of retrieval models developed for
text searching, such as n-grammatching and languagemodels, have been adapted
for this task (Dannenberg et al., 2007). Search techniques for polyphonic music
based on probabilistic models have also been used for the retrieval ofmusic scores
represented in conventional music notation.

In summary, search techniques based on retrieval models for text have been
developed for a large range of non-text media. In the case of scanned and spoken
documents, retrieval effectiveness is similar to text documents because OCR and
speech recognition tools generally have low error rates. Content-based retrieval
of images and video shows promise, but search applications for these media must
rely on associated text from sources such as captions and user tags to achieve good
effectiveness.Music is difficult to describe in text, but effectivemusic search appli-
cations have been developed because index terms that have a strong relationship
to what users look for can be derived from the audio or MIDI representations.

11.7 One Search Fits All?

So what is the future of search? Certainly it does not look like we will build the
omniscient assistant system anytime soon. On the other hand, as we discussed
before, using that type of system as our goal makes it clear how much further
we have to go from current search engines. Our knowledge and understanding
of search and effectiveness are steadily increasing, despite the field being more
than 40 years old. Interestingly, this has produced a variety of different search
services, rather than a single search engine with more and more capability. At the
home page for a popular web search engine, we find links to search engines for
the Web, images, blogs, maps, academic papers, products, patents, news, books,



480 11 Beyond Bag of Words

financial information, videos, government documents, and photographs. In addi-
tion, there are links to tools for desktop search, enterprise search, and advertising
search. Rather than being simply multiple instances of the same search engine, it
is clear that many of these use somewhat different features, ranking algorithms,
and interfaces. If we look at the research literature, an even greater range of appli-
cations, media, and approaches to search are being developed and evaluated. One
safe prediction is that this expansion of new ideas will continue.

Despite the proliferation of customized search engines, there is also a growing
consensus on the principles that underlie them. Researchers from information
retrieval and related fields, such as machine learning and natural language pro-
cessing, have developed similar approaches to representing text andmodeling the
process of retrieval.These approaches are rapidly being expanded to include struc-
tured data andnon-textmedia. Research results based onnew applications or data
have consistently reinforced the view that probabilistic models of text and linear
feature-basedmodels for retrieval provide a powerful and effective framework for
understanding search. Another prediction is that the sophistication of this under-
lying “theory” of search will continue to grow and provide steady improvements
in effectiveness for a range of applications.

What impact will this “theory” have on search engines? If there is more agree-
ment about how to represent text and other types of data, and more agreement
about how to rank potential answers in response to questions, then the search
tools that developers use will become more similar than they are currently. Open
source search engines, web search engines, desktop search engines and enterprise
search engines available today all use different term weighting, different features,
different ranking algorithms, and different query languages. This is simply due to
the fact that there is no consensus yet on the right way to do these things, but
this will change. When there is more agreement on the underlying models, there
will still be a variety of search tools available, but the choice between themwill be
basedmore on the efficiency of the implementation, the flexibility and adaptabil-
ity for new applications, and the extent to which the tools implement the more
sophisticated algorithms suggested by the models. This is analogous to what hap-
pened with database systems, where there have been multiple vendors and orga-
nizations providing tools based on the relational model since the 1980s.

Another aspect of search, which we have not devoted enough coverage to in
this book, is the fundamental importance of the interaction between users and the
search engine, and the impact of the user’s task on this process. Information sci-
entists in particular have focused on these issues and have contributed important



11.7 One Search Fits All? 481

insights to our understanding of how people find relevant information. As social
search and social networking applications have grown, the study of interaction
has also expanded to include interaction between users as well as between a user
and a search engine. In the near future, we can expect to see theories andmodels of
search that incorporate users and interaction in a more explicit way than current
models. Fuhr (2008) is a recent example of this development.

A common vision of the future, supported by countless films and television
series, assumes an interface based on a simple natural language input with multi-
media output. Interaction in this interface is based on dialog. Despite, or because
of, its simplicity, this seems like a reasonable long-term goal. In current search
interfaces, queries are certainly simple but, as we have discussed, a considerable
effort can go into formulating these simple queries in order to find the one that
retrieves relevant information. In addition, there is very little dialog or interaction,
and even simple ideas, such as relevance feedback, are not used. Even worse, the
availability of many different search engines means that another decision (which
search engine?) is added to the interaction.

Developers in search engine companies and researchers are studying tech-
niques for improving interaction. Some interfaces put results frommultiple types
of search engines into a single results display. Simple examples of this include
putting a map search engine result at the top of the result list when the query
includes an address, or a link to an academic paper at the top when the query
matches the title closely. It is clear, however, that interfaces in the future must
continue to evolve in order to more actively incorporate users and their knowl-
edge into the search process.

A final prediction is self-serving in the context of this book. Search, in all
its forms, will continue to be of critical importance in future software applica-
tions. Training people to understand the principles, models, and evaluation tech-
niques that underlie search engines is an important part of continuing to improve
their effectiveness and efficiency. There are not enough courses that focus on this
topic, but through this book and others like it,more peoplewill knowmore about
search.

References and Further Reading

Linear feature-based retrievalmodels are discussed inMetzler andCroft (2007b).
This paper contains references to other models that were discussed in Chapter 7.
Another recent paper discussing linear models is Gao et al. (2005).



482 11 Beyond Bag of Words

Many term dependency models have been proposed in the information re-
trieval literature, although few have produced interesting results. van Rijsbergen
(1979) presented one of the most-cited dependency models as an extension of
the Bayesian classification approach to retrieval. In another early paper, Croft et
al. (1991) showed that phrases and term proximity could potentially improve ef-
fectiveness by modeling them as dependencies in the inference net model. Gao et
al. (2004) describe a dependencemodel that showed significant effectiveness ben-
efits, especially for sequential dependencies (or n-grams). Other recent research
with larger test collections have shown that term proximity information is an ex-
tremely useful feature.

From an information retrieval perspective, dealingwith structure in data start-
ed in the 1970s with commercial search services such as MEDLINE and DIA-
LOG that had Boolean field restrictions. In the 1970s and 1980s, a number of
papers described the implementation of search engines using relational database
systems (e.g., Crawford, 1981). Efficiency issues persisted with this approach un-
til the 1990s, although object management systems were successfully used to sup-
port indexes (e.g., Brown et al., 1994). The 1990s were also the period when im-
portantworkwas done on developing probabilistic extensions of databasemodels
for search applications. Fuhr andhis colleagues described aprobabilistic relational
algebra (Fuhr & Rölleke, 1997) and a probabilistic datalog system (Fuhr, 2000).

In the commercial world, text retrieval had become a standard function in
database systems such as Oracle by the early 1990s, but the explosion of web data
and the growth of text-based web applications later that decade made the abil-
ity to handle text effectively a critical part of most information systems. An in-
teresting discussion of database and search engine integration from the database
perspective can be found in Chaudhuri et al. (2005).

Another important line of research has been retrieval using structured and
XML documents. Early work in this area dealt with office documents (Croft,
Krovetz,&Turtle, 1990) anddocumentmarkup (Croft et al., 1992).TheXQuery
query language for XML data is described in Chamberlin (2002). Kazai et al.
(2003) describe the INEXproject that evaluates retrieval methods for XMLdoc-
uments. Trotman and Lalmas (2006) describe the NEXI language.

In the area of question answering,Metzler andCroft (2005a) give an overview
of techniques for question classification. Probabilistic approaches to question an-
swering that have been shown to be effective include themaximumentropymodel
(Ittycheriah et al., 2001) and the translation model (Echihabi & Marcu, 2003).
Both are very similar to the retrieval models described in Chapter 7.



11.7 One Search Fits All? 483

Taghva et al. (1996) describe the first comprehensive set of experiments show-
ing that OCR errors generally have little effect on retrieval effectiveness. Harding
et al. (1997) show how n-grams can compensate for situations where there are
significant OCR error rates.

The book by Coden et al. (2002) contains a collection of papers about spo-
ken document retrieval. Singhal and Pereira (1999) describe an expansion tech-
nique for spoken documents that gave significant effectiveness improvements.
The data andmajor results from the TREC spoken document track are described
in Voorhees and Harman (2005).

Manypapers havebeenpublished about content-based image retrieval. Flickner
et al. (1995)describeQBIC, oneof thefirst commercial systems to incorporate re-
trieval using color, texture, and shape features. The Photobook system (Pentland
et al., 1996) also had a significant impact on other CBIR projects. Ravela and
Manmatha (1997) describe one of the first texture-based retrieval techniques to
be evaluated using an information retrieval approach. The SIFT (scale-invariant
feature transform) algorithm (Lowe, 2004) is currently a popularmethod for rep-
resenting images for search.Vasconcelos (2007) gives a recent overviewof thefield
of CBIR.

In the area of content-based retrieval of music, most research is published in
the International Conference on Music Information Retrieval (ISMIR).17 Byrd
and Crawford (2002) give a good overview of the research issues in this field.
Midomi18 is an example of searching music by “humming.”

With regard to the information science perspective on search and interaction,
Belkin haswritten a number of key papers, such asKoenemann andBelkin (1996)
andBelkin (2008).The book by Ingwersen and Järvelin (2005) contains in-depth
discussions of the role of interaction and context in search. Marchionini (2006)
discusses similar issues with an emphasis on the search interface.

Exercises

11.1. Can you find other “visions of the future” related to search engines on the
Web or in books, films, or television? Describe these systems and any unique fea-
tures they may have.

17 http://www.ismir.net/
18 http://www.midomi.com



484 11 Beyond Bag of Words

11.2. Does your favorite web search engine use a bag of words representation?
How can you tell whether it does or doesn’t?

11.3. Use the Galago #feature operator to create a ranking algorithm that uses
both a BM25 feature and a query likelihood feature.

11.4. Show how the linear feature-based ranking function is related to the ab-
stract ranking model from Chapter 5.

11.5. Howmany papers dealingwith termdependency can you find in the SIGIR
proceedings since 2000? List their citations.

11.6. Write a program that converts textual queries to sequential dependence
MRF queries in Galago, as described in the text. Run some queries against an
index, and compare the quality of the results with and without term dependence.
Which types of queries are the most improved using the dependence model?
Which are hurt the most?

11.7. Think of five queries where you are searching for documents structured us-
ing XML. The queries must involve structure and content features. Write the
queries in English and in NEXI (explain the XML structure if it is not obvious).
Do you think the structural part of the query will improve effectiveness? Give a
detailed example.

11.8. Find out about the text search functionality of a database system (either
commercial or open source). Describe it in as much detail as you can, including
the query language. Compare this functionality to a search engine.

11.9. Find a demonstration of a question answering system running on the Web.
Using a test set of questions, identify which types of questions work and which
don’t on this system. Report effectiveness using MRR or another measure.

11.10. Using the text-based image search for a web search engine, find examples
of images that you think could be retrieved by similarity based on color.Use a tool
such as Photoshop to generate color histogram values based on hue (or one of the
RGB channels) for your test images. Compare the histograms using some simi-
larity measure (such as the normalized sum of the differences in the bin values).
How well do these similarities match your visual perceptions?



11.7 One Search Fits All? 485

11.11. Look at a sample of images or videos that have been tagged by users and
separate the tags into three groups: those you think could eventually be done au-
tomatically by image processing and object recognition, those you think would
not be possible to derive by image processing, and spam. Also decide which of the
tags should be most useful for queries related to those images. Summarize your
findings.

11.12. What features would you like to have to support indexing and retrieval of
personal digital photographs and videos? Which of these features are available in
off-the-shelf software? Which of the features are discussed in research papers?

11.13. Startingwith twoMP3files of two versions of the same song (i.e., different
artists), use tools available on the Web to analyze and compare them. You should
be able to find tools to generateMIDI from the audio, spectrograms, etc. Can you
find any similarities between these files that come from the melody? You could
also try recording a song using amicrophone and comparing the audio file created
from the recording with the original.





References

AbdulJaleel, N., & Larkey, L. S. (2003). Statistical transliteration for English-
Arabic cross language information retrieval. In CIKM ’03: Proceedings of
the twelfth international conference on information and knowledge manage-
ment (pp. 139–146). ACM.

Agichtein, E., Brill, E., & Dumais, S. (2006). Improving web search ranking by
incorporating user behavior information. In SIGIR ’06: Proceedings of the
29th annual international ACM SIGIR conference on research and develop-
ment in information retrieval (pp. 19–26). ACM.

Agichtein, E., Brill, E., Dumais, S., & Ragno, R. (2006). Learning user inter-
action models for predicting web search result preferences. In SIGIR ’06:
Proceedings of the 29th annual international ACM SIGIR conference on re-
search and development in information retrieval (pp. 3–10). ACM.

Agichtein, E., Castillo, C., Donato,D., Gionis, A., &Mishne, G. (2008). Finding
high-quality content in social media. In WSDM ’08: Proceedings of the
international conference on web search andweb datamining (pp. 183–194).
ACM.

Allan, J. (1996). Incremental relevance feedback for information filtering. In
SIGIR ’96: Proceedings of the 19th annual international ACM SIGIR con-
ference on research and development in information retrieval (pp. 270–278).
ACM.

Allan, J. (Ed.). (2002). Topic detection and tracking: Event-based information
organization. Norwell, MA: Kluwer Academic Publishers.

Almeida,R.B.,&Almeida,V.A. F. (2004). A community-aware search engine. In
WWW ’04: Proceedings of the 13th international conference onWorldWide
Web (pp. 413–421). ACM.



488 References

Amershi, S., & Morris, M. R. (2008). CoSearch: A system for co-located
collaborative web search. In CHI ’08: Proceeding of the twenty-sixth
annual SIGCHI conference on human factors in computing systems (pp.
1,647–1,656). ACM.

Anagnostopoulos, A., Broder, A., & Carmel, D. (2005). Sampling search-engine
results. In WWW ’05: Proceedings of the 14th international conference on
WorldWideWeb (pp. 245–256). ACM.

Anh, V. N., & Moffat, A. (2005). Simplified similarity scoring using term
ranks. In SIGIR ’05: Proceedings of the 28th annual international ACM
SIGIR conference on research and development in information retrieval (pp.
226–233). ACM.

Anh, V. N., & Moffat, A. (2006). Pruned query evaluation using pre-computed
impacts. In SIGIR ’06: Proceedings of the 29th annual international ACM
SIGIR conference on research and development in information retrieval (pp.
372–379). New York: ACM.

Baeza-Yates, R.,&Ramakrishnan,R. (2008). Data challenges atYahoo! InEDBT
’08: Proceedings of the 11th international conference on extending database
technology (pp. 652–655). ACM.

Baeza-Yates, R., & Ribeiro-Neto, B. A. (1999). Modern information retrieval.
New York: ACM/Addison-Wesley.

Balakrishnan, H., Kaashoek, M. F., Karger, D., Morris, R., & Stoica, I. (2003).
Looking up data in P2P systems. Communications of the ACM , 46(2),
43–48.

Balog,K., Azzopardi, L.,&deRijke,M. (2006). Formalmodels for expert finding
in enterprise corpora. In SIGIR ’06: Proceedings of the 29th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 43–50). ACM.

Barroso, L.A.,Dean, J.,&Hölzle,U. (2003). Web search for a planet:TheGoogle
cluster architecture. IEEEMicro, 23(2), 22–28.

Beeferman, D., & Berger, A. (2000). Agglomerative clustering of a search en-
gine query log. In Proceedings of the sixth ACM SIGKDD international
conference on knowledge discovery and data mining (pp. 407–416). ACM.

Belew, R. K. (2000). Finding out about. Cambridge, UK: Cambridge University
Press.

Belkin, N. J. (2008). (Somewhat) grand challenges for information retrieval.
SIGIR Forum, 42(1), 47–54.

Belkin, N. J., & Croft, W. B. (1992). Information filtering and information re-



References 489

trieval: Two sides of the same coin? Communications of the ACM , 35(12),
29–38.

Belkin, N. J., Oddy, R. N., & Brooks, H. M. (1997). ASK for information re-
trieval: Part I.: background and theory. InReadings in information retrieval
(pp. 299–304). San Francisco:Morgan Kaufmann. (Reprinted from Jour-
nal of Documentation, 1982, 38, 61–71)

Benczúr, A., Csalogány, K., Sarlós, T., & Uher, M. (2005). Spamrank – fully
automatic link spam detection. In AIRWeb: 1st international workshop on
adversarial information retrieval on the web (pp. 25–38).

Berger, A., Caruana, R., Cohn, D., Freitag, D., & Mittal, V. (2000). Bridging
the lexical chasm: Statistical approaches to answer-finding. In SIGIR ’00:
Proceedings of the 23rd annual international ACM SIGIR conference on re-
search and development in information retrieval (pp. 192–199). ACM.

Berger, A., &Lafferty, J. (1999). Information retrieval as statistical translation. In
SIGIR ’99: Proceedings of the 22nd annual international ACM SIGIR con-
ference on research and development in information retrieval (pp. 222–229).
ACM.

Berger, A., & Mittal, V. O. (2000). Ocelot: a system for summarizing web
pages. In SIGIR ’00: Proceedings of the 23rd annual international ACM
SIGIR conference on research and development in information retrieval (pp.
144–151). ACM.

Bergman, M. K. (2001). The deep web: Surfacing hidden value. Journal of Elec-
tronic Publishing, 7(1).

Bernstein, Y., & Zobel, J. (2005). Redundant documents and search effective-
ness. In CIKM ’05: Proceedings of the 14th ACM international conference
on information and knowledge management (pp. 736–743). ACM.

Bernstein, Y., & Zobel, J. (2006). Accurate discovery of co-derivative documents
via duplicate text detection. Information Systems, 31, 595–609.

Bikel, D.M.,Miller, S., Schwartz, R., &Weischedel, R. (1997). Nymble: A high-
performance learning name-finder. In Proceedings of the fifth conference on
applied natural language processing (pp. 194–201). Morgan Kaufmann.

Bikel, D. M., Schwartz, R. L., & Weischedel, R. M. (1999). An algorithm that
learns what’s in a name. Machine Learning, 34(1–3), 211–231.

Blei,D.M.,Ng,A.Y.,& Jordan,M. I. (2003). LatentDirichlet allocation. Journal
of Machine Learning Research, 3, 993–1,022.

Borgs, C., Chayes, J., Mahdian, M., & Saberi, A. (2004). Exploring the commu-
nity structure of newsgroups. In KDD ’04: Proceedings of the tenth ACM



490 References

SIGKDD international conference on knowledge discovery and data mining
(pp. 783–787). ACM.

Breese, J., Heckerman, D., & Kadie, C. (1998). Empirical analysis of predictive
algorithms for collaborative filtering. InUAI ’98: Proceedings of the uncer-
tainty in artifical intelligence conference (pp. 43–52).

Brill, E. (1994). Some advances in transformation-based part of speech tagging.
In AAAI ’94: National conference on artificial intelligence (pp. 722–727).

Brin, S., & Page, L. (1998). The anatomy of a large-scale hypertextualWeb search
engine. Computer Networks and ISDN Systems, 30(1–7), 107–117.

Broder, A. (2002). A taxonomy of web search. SIGIR Forum, 36(2), 3–10.
Broder, A., Fontoura, M., Josifovski, V., & Riedel, L. (2007). A semantic ap-

proach to contextual advertising. In SIGIR ’07: Proceedings of the 30th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 559–566). ACM.

Broder, A., Fontura, M., Josifovski, V., Kumar, R., Motwani, R., Nabar, S., … Xu,
Y. (2006). Estimating corpus size via queries. InCIKM ’06: Proceedings of
the 15thACM international conference on information and knowledgeman-
agement (pp. 594–603). ACM.

Broder, A., Glassman, S. C., Manasse, M. S., & Zweig, G. (1997). Syntactic
clustering of the Web. Computer Networks and ISDN Systems, 29(8–13),
1157–1166.

Brown, E. W., Callan, J., Croft, W. B., & Moss, J. E. B. (1994). Supporting
full-text information retrieval with a persistent object store. In EDBT ’94:
4th international conference on extending database technology (Vol. 779, pp.
365–378). Springer.

Buckley, C., & Voorhees, E. M. (2004). Retrieval evaluation with incom-
plete information. In SIGIR ’04: Proceedings of the 27th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 25–32). ACM.

Burges, C., Shaked, T., Renshaw, E., Lazier, A., Deeds, M., Hamilton, N., & Hul-
lender, G. (2005). Learning to rank using gradient descent. In ICML ’05:
Proceedings of the 22nd international conference on machine learning (pp.
89–96). ACM.

Burges, C. J. C. (1998). A tutorial on support vector machines for pattern recog-
nition. DataMining and Knowledge Discovery, 2(2), 121–167.

Burke, R. D., Hammond, K. J., Kulyukin, V. A., Lytinen, S. L., Tomuro, N., &
Schoenberg, S. (1997). Question answering from frequently asked question



References 491

files: Experiences with the FAQ finder system (Tech. Rep.). Chicago, IL,
USA.

Büttcher, S., &Clarke, C. L. A. (2007). Index compression is good, especially for
random access. In CIKM ’07: Proceedings of the sixteenth ACM conference
on information and knowledge management (pp. 761–770). ACM.

Büttcher, S., Clarke, C. L. A., & Lushman, B. (2006). Hybrid indexmaintenance
for growing text collections. In SIGIR ’06: Proceedings of the 29th annual
international ACM SIGIR conference on research and development in infor-
mation retrieval (pp. 356–363). ACM.

Byrd, D., & Crawford, T. (2002). Problems of music information retrieval in the
real world. Information Processing andManagement, 38(2), 249–272.

Callan, J. (2000). Distributed information retrieval. In Advances in informa-
tion retrieval: Recent research from the CIIR (pp. 127–150). Norwell, MA:
Kluwer Academic Publishers.

Callan, J., Croft, W. B., & Broglio, J. (1995). TREC and Tipster experiments
with Inquery. Information Processing andManagement, 31(3), 327–343.

Callan, J., Croft, W. B., & Harding, S. M. (1992). The Inquery retrieval system.
In Proceedings of DEXA-92, 3rd international conference on database and
expert systems applications (pp. 78–83).

Cao, Y., Xu, J., Liu, T.-Y., Li, H., Huang, Y., & Hon, H.-W. (2006). Adapting
ranking SVM to document retrieval. In SIGIR ’06: Proceedings of the 29th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 186–193). ACM.

Carbonell, J., &Goldstein, J. (1998). The use ofMMR, diversity-based reranking
for reordering documents and producing summaries. In SIGIR ’98: Pro-
ceedings of the 21st annual international ACMSIGIR conference on research
and development in information retrieval (pp. 335–336). ACM.

Carson,C.,Thomas,M., Belongie, S.,Hellerstein, J.M.,&Malik, J. (1999). Blob-
world:A system for region-based image indexing and retrieval. InVISUAL
’99: Third international conference on visual information and information
systems (pp. 509–516). Springer.

Carterette, B., Allan, J., & Sitaraman, R. (2006). Minimal test collections for
retrieval evaluation. In SIGIR ’06: Proceedings of the 29th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 268–275). ACM.

Carterette, B., & Jones, R. (2007). Evaluating search engines by modeling the
relationship between relevance and clicks. InNIPS ’07: Proceedings of the



492 References

conference on neural information processing systems (pp. 217–224). MIT
Press.

Chakrabarti, S., van den Berg, M., & Dom, B. (1999). Focused crawling: A new
approach to topic-specific web resource discovery. Computer Networks,
31(11-16), 1,623–1,640.

Chamberlin, D. (2002). XQuery: An XML query language. IBM Systems Jour-
nal , 41(4), 597–615.

Chang, F., Dean, J., Ghemawat, S., Hsieh, W. C., Wallach, D. A., Burrows, M., …
Gruber, R. E. (2006). Bigtable: a distributed storage system for structured
data. In OSDI ’06: Proceedings of the 7th symposium on operating systems
design and implementation (pp. 205–218). USENIX Association.

Charikar, M. S. (2002). Similarity estimation techniques from rounding algo-
rithms. In STOC ’02: Proceedings of the annual ACM symposium on theory
of computing (pp. 380–388). ACM.

Chaudhuri, S., Ramakrishnan, R., & Weikum, G. (2005). Integrating DB and
IR technologies:What is the sound of one hand clapping? InCIDR 2005:
Second biennial conference on innovative data systems research (pp. 1–12).

Chen, Y.-Y., Suel, T., & Markowetz, A. (2006). Efficient query processing in
geographic web search engines. In SIGMOD ’06: Proceedings of the ACM
SIGMOD international conference on management of data (pp. 277–288).
ACM.

Cho, J., & Garcia-Molina, H. (2002). Parallel crawlers. In WWW 2002: Pro-
ceedings of the 11th annual international world wide web conference (pp.
124–135). ACM.

Cho, J., & Garcia-Molina, H. (2003). Effective page refresh policies for web
crawlers. ACMTransactions on Database Systems, 28, 390–426.

Church, K. W. (1988). A stochastic parts program and noun phrase parser for
unrestricted text. In Proceedings of the second conference on applied natural
language processing (pp. 136–143). Association for Computational Lin-
guistics.

Church, K. W., & Hanks, P. (1989). Word association norms, mutual informa-
tion, and lexicography. In Proceedings of the 27th annual meeting on Asso-
ciation for Computational Linguistics (pp. 76–83). Association for Com-
putational Linguistics.

Clarke, C. L., Agichtein, E., Dumais, S., & White, R. W. (2007). The influence
of caption features on clickthrough patterns in web search. In SIGIR ’07:
Proceedings of the 30th annual international ACM SIGIR conference on re-



References 493

search and development in information retrieval (pp. 135–142). ACM.
Cleverdon, C. (1970). Evaluation tests of information retrieval systems. Journal

of Documentation, 26(1), 55–67.
Coden, A., Brown, E. W., & Srinivasan, S. (Eds.). (2002). Information retrieval

techniques for speech applications. London: Springer-Verlag.
Cong, G., Wang, L., Lin, C.-Y., Song, Y.-I., & Sun, Y. (2008). Finding question-

answer pairs from online forums. In SIGIR ’08: Proceedings of the 31st
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 467–474). ACM.

Conrad, J. G., & Utt, M. H. (1994). A system for discovering relationships by
feature extraction from text databases. In SIGIR ’94: Proceedings of the 17th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 260–270). Springer-Verlag.

Cooper,W. S. (1968). Expected search length:A singlemeasure of retrieval effec-
tiveness based on the weak ordering action of retrieval systems. American
Documentation, 19(1), 30–41.

Cooper, W. S., Gey, F. C., & Dabney, D. P. (1992). Probabilistic retrieval based
on staged logistic regression. In SIGIR ’92: Proceedings of the 15th annual
international ACM SIGIR conference on research and development in infor-
mation retrieval (pp. 198–210). ACM.

Cowie, J., & Lehnert,W. (1996). Information extraction. Communications of the
ACM , 39(1), 80–91.

Crawford, R. (1981). The relational model in information retrieval. Journal of
the American Society for Information Science, 32(1), 51–64.

Croft,W.B. (2000). Combining approaches to information retrieval. InAdvances
in information retrieval: Recent researchfrom theCIIR (pp. 1–36). Norwell,
MA: Kluwer Academic Publishers.

Croft, W. B., Krovetz, R., & Turtle, H. (1990). Interactive retrieval of complex
documents. Information Processing andManagement, 26(5), 593–613.

Croft, W. B., & Lafferty, J. (2003). Language modeling for information retrieval.
Norwell, MA: Kluwer Academic Publishers.

Croft,W. B., Smith, L. A., &Turtle, H. R. (1992). A loosely-coupled integration
of a text retrieval system and an object-oriented database system. In SIGIR
’92: Proceedings of the 15th annual international ACMSIGIR conference on
research and development in information retrieval (pp. 223–232). ACM.

Croft, W. B., & Turtle, H. (1989). A retrieval model incorporating hypertext
links. InHypertext ’89: Proceedings of the second annual ACM conference on



494 References

hypertext (pp. 213–224). ACM.
Croft, W. B., Turtle, H. R., & Lewis, D. D. (1991). The use of phrases and struc-

tured queries in information retrieval. In SIGIR ’91: Proceedings of the 14th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 32–45). ACM.

Cronen-Townsend, S., Zhou, Y., & Croft, W. B. (2006). Precision prediction
based on ranked list coherence. Information Retrieval , 9(6), 723–755.

Cucerzan, S., & Brill, E. (2004). Spelling correction as an iterative process that
exploits the collective knowledge of web users. In D. Lin & D. Wu (Eds.),
Proceedings of EMNLP 2004 (pp. 293–300). Association for Computa-
tional Linguistics.

Cui, H., Wen, J.-R., Nie, J.-Y., & Ma, W.-Y. (2003). Query expansion by mining
user logs. IEEE Transactions on Knowledge and Data Engineering, 15(4),
829–839.

Dannenberg, R. B., Birmingham, W. P., Pardo, B., Hu, N., Meek, C., & Tzane-
takis, G. (2007). A comparative evaluation of search techniques for query-
by-humming using the MUSART testbed. Journal of the American Society
for Information Science and Technology, 58(5), 687–701.

Dean, J., & Ghemawat, S. (2008). MapReduce: simplified data processing on
large clusters. Communications of the ACM , 51(1), 107–113.

DeCandia,G.,Hastorun,D., Jampani,M.,Kakulapati,G., Lakshman,A., Pilchin,
A., … Vogels, W. (2007). Dynamo: Amazon’s highly available key-value
store. InSOSP ’07: Proceedings of the twenty-firstACMSIGOPS symposium
on operating systems principles (pp. 205–220). ACM.

Deerwester, S. C., Dumais, S. T., Landauer, T. K., Furnas, G. W., & Harshman,
R. A. (1990). Indexing by Latent Semantic Analysis. Journal of the Amer-
ican Society of Information Science, 41(6), 391–407.

Deutsch, P. (1996). DEFLATE compressed data format specification version
1.3 (RFC No. 1951). Internet Engineering Task Force. Retrieved from
http://www.rfc-editor.org/rfc/rfc1951.txt

Diaz, F. (2005). Regularizing ad hoc retrieval scores. InCIKM ’05: Proceedings of
the 14thACM international conference on information and knowledgeman-
agement (pp. 672–679). ACM.

Duda, R. O., Hart, P. E., & Stork, D. G. (2000). Pattern classification (2nd ed.).
Wiley-Interscience.

Dunlop, M. D., & van Rijsbergen, C. J. (1993). Hypermedia and free text re-
trieval. Information Processing andManagement, 29(3), 287–298.



References 495

Echihabi, A.,&Marcu,D. (2003). Anoisy-channel approach to question answer-
ing. In ACL ’03: Proceedings of the 41st annual meeting on Association for
Computational Linguistics (pp. 16–23). Association for Computational
Linguistics.

Efthimiadis, E. N. (1996). Query expansion. In M. E. Williams (Ed.), An-
nual review of information systems and technology (ARIST) (Vol. 31, pp.
121–187).

Elmasri, R., & Navathe, S. (2006). Fundamentals of database systems (5th ed.).
Reading, MA: Addison-Wesley.

Fagin, R., Lotem, A., & Naor, M. (2003). Optimal aggregation algorithms for
middleware. Journal of Computer and Systems Sciences, 66(4), 614–656.

Feng, J., Bhargava, H. K., & Pennock, D. M. (2007). Implementing spon-
sored search in web search engines: Computational evaluation of alterna-
tive mechanisms. INFORMS Journal on Computing, 19(1), 137–148.

Fetterly, D., Manasse, M., & Najork, M. (2003). On the evolution of clusters of
near-duplicatewebpages. InLA-WEB ’03:Proceedings of the first conference
on Latin AmericanWeb Congress (pp. 37–45). IEEE Computer Society.

Finn, A., Kushmerick, N., & Smyth, B. (2001). Fact or fiction: Content clas-
sification for digital libraries. In DELOS workshop: Personalisation and
recommender systems in digital libraries.

Flake, G. W., Lawrence, S., & Giles, C. L. (2000). Efficient identification of web
communities. In KDD ’00: Proceedings of the sixth ACM SIGKDD inter-
national conference on knowledge discovery and datamining (pp. 150–160).
ACM.

Flickner, M., Sawhney, H. S., Ashley, J., Huang, Q., Dom, B., Gorkani, M., …
Yanker, P. (1995). Query by image and video content: The QBIC system.
IEEE Computer, 28(9), 23–32.

Fox, S., Karnawat, K., Mydland, M., Dumais, S., & White, T. (2005). Evaluating
implicit measures to improve web search. ACM Transactions on Informa-
tion Systems, 23(2), 147–168.

Fuhr, N. (2000). Probabilistic datalog: Implementing logical information re-
trieval for advanced applications. Journal of the American Society for Infor-
mation Science and Technology, 51(2), 95–110.

Fuhr, N. (2008). A probability ranking principle for interactive information
retrieval. Information Retrieval , 11(3), 251–265.

Fuhr, N., & Buckley, C. (1991). A probabilistic learning approach for document
indexing. ACMTransactions on Information Systems, 9(3), 223–248.



496 References

Fuhr, N., & Rölleke, T. (1997). A probabilistic relational algebra for the integra-
tion of information retrieval and database systems. ACM Transactions on
Information Systems, 15(1), 32–66.

Fujii, H., & Croft, W. B. (1993). A comparison of indexing techniques for
Japanese text retrieval. In SIGIR ’93: Proceedings of the 16th annual in-
ternational ACM SIGIR conference on research and development in infor-
mation retrieval (pp. 237–246). ACM.

Gao, J., Nie, J.-Y., Wu, G., & Cao, G. (2004). Dependence language model for
information retrieval. In SIGIR ’04: Proceedings of the 27th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 170–177). ACM.

Gao, J., Qi, H., Xia, X., & Nie, J.-Y. (2005). Linear discriminant model for in-
formation retrieval. In SIGIR ’05: Proceedings of the 28th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 290–297). ACM.

Garcia-Molina, H., Ullman, J. D., & Widom, J. D. (2008). Database systems:The
complete book. Prentice Hall.

Gibson, D., Kleinberg, J., & Raghavan, P. (1998). Inferring web communities
from link topology. In HYPERTEXT ’98: Proceedings of the ninth ACM
conference on hypertext and hypermedia (pp. 225–234). ACM.

Golder, S. A.,&Huberman, B. A. (2006). Usage patterns of collaborative tagging
systems. Journal of Information Science, 32(2), 198–208.

Goldstein, J., Kantrowitz, M., Mittal, V., & Carbonell, J. (1999). Summarizing
text documents: sentence selection and evaluation metrics. In SIGIR ’99:
Proceedings of the 22nd annual international ACM SIGIR conference on re-
search and development in information retrieval (pp. 121–128). ACM.

Grefenstette, G. (1998). Cross-language information retrieval. Norwell, MA:
Kluwer Academic Publishers.

Guo, J., Xu, G., Li, H., & Cheng, X. (2008). A unified and discriminative model
for query refinement. In SIGIR ’08: Proceedings of the 31st annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 379–386). ACM.

Gupta, S., Kaiser, G., Neistadt, D., & Grimm, P. (2003). DOM-based content
extraction of HTML documents. In WWW ’03: Proceedings of the 12th
international conference onWorldWideWeb (pp. 207–214). ACM.

Gyöngyi, Z., &Garcia-Molina, H. (2005). Web spam taxonomy. InAIRWeb: 1st
international workshop on adversarial information retrieval on the web (pp.



References 497

39–47).
Gyöngyi, Z., Garcia-Molina, H., & Pedersen, J. (2004). Combating web spam

with TrustRank. In VLDB 2004: Proceedings of the thirtieth international
conference on very large data bases (pp. 576–587). Morgan Kaufmann.

Ha, L. Q., Sicilia-Garcia, E. I., Ming, J., & Smith, F. J. (2002). Extension of Zipf ’s
law to words and phrases. In Proceedings of the 19th international confer-
ence on computational linguistics (pp. 1–6). Association forComputational
Linguistics.

Harding, S. M., Croft, W. B., & Weir, C. (1997). Probabilistic retrieval of OCR
degraded text using n-grams. In ECDL ’97: Proceedings of the first Euro-
pean conference on research and advanced technology for digital libraries (pp.
345–359). Springer-Verlag.

Hastie, T., Tibshirani, R., & Friedman, J. (2001). The elements of statistical learn-
ing: Data mining, inference, and prediction. Springer.

Hatcher, E.,&Gospodnetic,O. (2004). Lucene in action. Manning Publications.
Haveliwala, T. H. (2002). Topic-sensitive PageRank. In WWW ’02: Proceed-

ings of the 11th international conference onWorldWideWeb (pp. 517–526).
ACM.

Hawking, D., & Zobel, J. (2007). Does topic metadata help with web search?
Journal of the American Society for Information Science and Technology,
58(5), 613–628.

He, B., Patel, M., Zhang, Z., &Chang, K. (2007). Accessing the deep web. Com-
munications of the ACM , 50(5), 94–101.

Heaps, H. (1978). Information retrieval: Computational and theoretical aspects.
New York: Academic Press.

Hearst, M. A. (1999). User interfaces and visualization. InModern information
retrieval (pp. 257–324). ACM/Addison-Wesley.

Hearst, M. A. (2006). Clustering versus faceted categories for information ex-
ploration. Communications of the ACM , 49(4), 59–61.

Hearst, M. A., & Pedersen, J. O. (1996). Reexamining the cluster hypothesis:
scatter/gather on retrieval results. In SIGIR ’96: Proceedings of the 19th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 76–84). ACM.

Henzinger, M. (2006). Finding near-duplicate web pages: A large-scale evalua-
tion of algorithms. In SIGIR ’06: Proceedings of the 29th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 284–291). ACM.



498 References

Herlocker, J. L., Konstan, J. A., Terveen, L. G., & Riedl, J. T. (2004). Evaluating
collaborative filtering recommender systems. ACMTransactions on Infor-
mation Systems, 22(1), 5–53.

Heymann, P., Koutrika, G., & Garcia-Molina, H. (2008). Can social bookmark-
ing improve web search? In WSDM ’08: Proceedings of the international
conference on web search and web data mining (pp. 195–206). ACM.

Heymann, P., Ramage, D., &Garcia-Molina,H. (2008). Social tag prediction. In
SIGIR ’08: Proceedings of the 31st annual international ACM SIGIR con-
ference on research and development in information retrieval (pp. 531–538).
ACM.

Hiemstra, D. (1998). A linguistically motivated probabilistic model of infor-
mation retrieval. In ECDL ’98: Proceedings of the second european confer-
ence on research and advanced technology for digital libraries (pp. 569–584).
Springer-Verlag.

Hoad, T., & Zobel, J. (2003). Methods for identifying versioned and plagia-
rised documents. Journal of the American Society of Information Science
and Technology, 54(3), 203–215.

Hobbs, J., Douglas, R., Appelt, E., Bear, J., Israel, D., Kameyama, M., … Tyson,
M. (1997). Fastus: A cascaded finite-state transducer for extracting in-
formation from natural-language text. In Finite state language processing
(chap. 13). Cambridge, MA: MIT Press.

Hofmann, T. (1999). Probabilistic latent semantic indexing. In SIGIR ’99:
Proceedings of the 22nd annual international ACM SIGIR conference on re-
search and development in information retrieval (pp. 50–57). ACM.

Hopcroft, J., Khan, O., Kulis, B., & Selman, B. (2003). Natural communi-
ties in large linked networks. In KDD ’03: Proceedings of the ninth ACM
SIGKDD international conference on knowledge discovery and data mining
(pp. 541–546). ACM.

Ingwersen, P., & Järvelin, K. (2005). The turn: Integration of information seeking
and retrieval in context. Secaucus, NJ: Springer-Verlag.

Ipeirotis, P. G., & Gravano, L. (2004). When one sample is not enough: Improv-
ing text database selection using shrinkage. In SIGMOD ’04: Proceedings of
the 2004 ACM SIGMOD international conference on management of data
(pp. 767–778). ACM.

Ittycheriah,A., Franz,M.,Zhu,W.-J., Ratnaparkhi,A.,&Mammone,R. J. (2001).
Question answering using maximum entropy components. In NAACL
’01: Second meeting of the North American Chapter of the Association for



References 499

Computational Linguistics on language technologies (pp. 1–7). Association
for Computational Linguistics.

Järvelin, K., & Kekäläinen, J. (2002). Cumulated gain-based evaluation of IR
techniques. ACMTransactions on Information Systems, 20(4), 422–446.

Jeon, J., Croft, W. B., & Lee, J. H. (2005). Finding similar questions in large
question and answer archives. In CIKM ’05: Proceedings of the 14th ACM
international conference on information and knowledge management (pp.
84–90). ACM.

Jeon, J., Croft, W. B., Lee, J. H., & Park, S. (2006). A framework to predict
the quality of answers with non-textual features. In SIGIR ’06: Proceedings
of the 29th annual international ACM SIGIR conference on research and
development in information retrieval (pp. 228–235). ACM.

Jijkoun, V., & de Rijke, M. (2005). Retrieving answers from frequently asked
questions pages on the web. In CIKM ’05: Proceedings of the 14th ACM
international conference on information and knowledge management (pp.
76–83). ACM.

Jing, Y., & Croft, W. B. (1994). An association thesaurus for information re-
trieval. In Proceedings of RIAO-94, 4th international conference “recherche
d’information assistee par ordinateur” (pp. 146–160).

Joachims,T. (2002a). Learning to classify text using support vectormachines:Meth-
ods, theory and algorithms. Norwell, MA: Kluwer Academic Publishers.

Joachims, T. (2002b). Optimizing search engines using clickthrough data. In
KDD ’02: Proceedings of the eighthACMSIGKDD international conference
on knowledge discovery and data mining (pp. 133–142). ACM.

Joachims, T., Granka, L., Pan, B., Hembrooke, H., & Gay, G. (2005). Accurately
interpreting clickthrough data as implicit feedback. In SIGIR ’05: Proceed-
ings of the 28th annual internationalACMSIGIR conference on research and
development in information retrieval (pp. 154–161). ACM.

Jones, R., Rey, B., Madani, O., & Greiner, W. (2006). Generating query substi-
tutions. In WWW ’06: Proceedings of the 15th international conference on
WorldWideWeb (pp. 387–396). ACM.

Jurafsky, D., & Martin, J. H. (2006). Speech and language processing (2nd ed.).
London: Prentice Hall.

Kazai, G., Gövert, N., Lalmas, M., & Fuhr, N. (2003). The INEX evaluation
initiative. InH. Blanken,T.Grabs,H.-J. Schek, R. Schenkel,&G.Weikum
(Eds.), Intelligent XML retrieval (pp. 279–293). Springer.

Kelly, D., & Teevan, J. (2003). Implicit feedback for inferring user preference: A



500 References

bibliography. SIGIR Forum, 32(2).
Kleinberg, J. M. (1999). Authoritative sources in a hyperlinked environment.

Journal of the ACM , 46(5), 604–632.
Knuth, D. E. (1998). The art of computer programming: Sorting and searching

(2nd ed., Vol. 3). Redwood City, CA: Addison-Wesley Longman.
Koenemann, J., & Belkin, N. J. (1996). A case for interaction: a study of interac-

tive information retrieval behavior and effectiveness. In CHI ’96: Proceed-
ings of the SIGCHI conference on human factors in computing systems (pp.
205–212). ACM.

Kraaij, W., Westerveld, T., & Hiemstra, D. (2002). The importance of prior
probabilities for entry page search. In SIGIR ’02: Proceedings of the 25th
annual international ACM SIGIR conference on research and development
in information retrieval (pp. 27–34). ACM.

Krovetz, R. (1993). Viewing morphology as an inference process. In SIGIR
’93: Proceedings of the 16th annual international ACMSIGIR conference on
research and development in information retrieval (pp. 191–202). ACM.

Kukich, K. (1992). Techniques for automatically correcting words in text. ACM
Computing Surveys, 24(4), 377–439.

Kurland, O. (2008). The opposite of smoothing: A language model approach to
ranking query-specific document clusters. In SIGIR ’08: Proceedings of the
31st annual international ACM SIGIR conference on research and develop-
ment in information retrieval (pp. 171–178). ACM.

Kurland, O., & Lee, L. (2004). Corpus structure, language models, and ad hoc
information retrieval. In SIGIR ’04: Proceedings of the 27th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 194–201). ACM.

Kurland, O., & Lee, L. (2005). Pagerank without hyperlinks: structural re-
ranking using links induced by languagemodels. In SIGIR ’05: Proceedings
of the 28th annual international ACMSIGIR conference on research and de-
velopment in information retrieval (pp. 306–313). ACM.

Lafferty, J., & Zhai, C. (2001). Document language models, query models, and
risk minimization for information retrieval. In SIGIR ’01: Proceedings of
the 24th annual international ACM SIGIR conference on research and de-
velopment in information retrieval (pp. 111–119). ACM.

Lankes, R. D. (2004). The digital reference research agenda. Journal of the Amer-
ican Society for Information Science and Technology, 55(4), 301–311.

Larkey, L. S., Ballesteros, L., & Connell, M. E. (2002). Improving stemming



References 501

for Arabic information retrieval: Light stemming and co-occurrence anal-
ysis. In SIGIR ’02: Proceedings of the 25th annual international ACM SI-
GIR conference on research and development in information retrieval (pp.
275–282). ACM.

Lavrenko, V.,&Croft,W.B. (2001). Relevance based languagemodels. In SIGIR
’01: Proceedings of the 24th annual international ACMSIGIR conference on
research and development in information retrieval (pp. 120–127). ACM.

Lawrie, D. J., & Croft, W. B. (2003). Generating hierarchical summaries for web
searches. In SIGIR ’03: Proceedings of the 26th annual international ACM
SIGIR conference on research and development in information retrieval (pp.
457–458). ACM.

Leouski, A., & Croft, W. (1996). An evaluation of techniques for clustering search
results (Tech. Rep. Nos. IR–76). Department of Computer Science, Uni-
versity of Massachusetts Amherst.

Lester, N., Moffat, A., & Zobel, J. (2005). Fast on-line index construction
by geometric partitioning. In CIKM ’05: Proceedings of the 14th ACM
international conference on information and knowledge management (pp.
776–783). New York: ACM.

Leuski, A., & Lavrenko, V. (2006). Tracking dragon-hunters with languagemod-
els. InCIKM ’06: Proceedings of the 15th ACM international conference on
information and knowledge management (pp. 698–707). ACM.

Liu, X., &Croft,W. B. (2004). Cluster-based retrieval using languagemodels. In
SIGIR ’04: Proceedings of the 27th annual international ACM SIGIR con-
ference on research and development in information retrieval (pp. 186–193).
ACM.

Liu, X., &Croft,W. B. (2008). Evaluating text representations for retrieval of the
best group of documents. In ECIR ’08: Proceedings of the 30th European
conference on information retrieval (pp. 454–462). Springer.

Lowe, D. G. (2004). Distinctive image features from scale-invariant keypoints.
International Journal of Computer Vision, 60(2), 91–110.

Lu, J., &Callan, J. (2006). Full-text federated search of text-based digital libraries
in peer-to-peer networks. Information Retrieval , 9(4), 477–498.

Lu, J., & Callan, J. (2007). Content-based peer-to-peer network overlay for full-
text federated search. In RIAO ’07: Proceedings of the eighth RIAO confer-
ence.

Luhn, H. P. (1958). The automatic creation of literature abstracts. IBM Journal
of Research and Development, 2(2), 159–165.



502 References

Lund, K., & Burgess, C. (1996). Producing high-dimensional semantic spaces
from lexical co-occurrence. Behavior Research Methods, Instrumentation,
and Computers, 28(2), 203–208.

Manning, C.D., Raghavan, P., & Schütze,H. (2008). Introduction to information
retrieval. New York: Cambridge University Press.

Manning,C.D.,&Schütze,H. (1999). Foundations of statistical natural language
processing. Cambridge, MA: The MIT Press.

Marchionini, G. (2006). Exploratory search: from finding to understanding.
Communications of the ACM , 49(4), 41–46.

McBryan, O. A. (1994). GENVL and WWWW: Tools for Taming the Web. In
WWW’94:Proceedings of the first internationalWorldWideWeb conference
(p. 15). CERN, Geneva.

McCallum, A. (2005). Information extraction: distilling structured data from
unstructured text. Queue, 3(9), 48–57.

McCallum, A., & Nigam, K. (1998). A comparison of event models for naive
Bayes text classification. In AAAI-98 workshop on learning for text catego-
rization.

Menczer, F., & Belew, R. K. (1998). Adaptive information agents in distributed
textual environments. In AGENTS ’98: Proceedings of the second interna-
tional conference on autonomous agents (pp. 157–164). ACM.

Metzler,D.,&Croft,W.B. (2004). Combining the languagemodel and inference
network approaches to retrieval. Information Processing andManagement,
40(5), 735–750.

Metzler, D., &Croft,W. B. (2005a). Analysis of statistical question classification
for fact-based questions. Information Retrieval , 8(3), 481–504.

Metzler, D., & Croft, W. B. (2005b). A Markov random field model for
term dependencies. In SIGIR ’05: Proceedings of the 28th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 472–479). ACM.

Metzler, D., & Croft, W. B. (2007a). Latent concept expansion using Markov
random fields. In SIGIR ’07: Proceedings of the 30th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 311–318). ACM.

Metzler,D.,&Croft,W.B. (2007b). Linear feature-basedmodels for information
retrieval. Information Retrieval , 10(3), 257–274.

Metzler, D., Dumais, S. T., & Meek, C. (2007). Similarity measures for short
segments of text. In ECIR ’07: Proceedings of the European conference on



References 503

information retrieval (pp. 16–27). Springer.
Metzler, D., Lavrenko, V., & Croft, W. B. (2004). Formal multiple-Bernoulli

models for language modeling. In SIGIR ’04: Proceedings of the 27th an-
nual international ACM SIGIR conference on research and development in
information retrieval (pp. 540–541). ACM.

Metzler, D., Strohman, T., &Croft,W. B. (2008). A statistical view of binned re-
trieval models. In ECIR 2008: Proceedings of the 30th European conference
on information retrieval (pp. 175–186). Springer.

Metzler, D., Strohman, T., Turtle, H., & Croft, W. (2004). Indri at TREC
2004: Terabyte track. InNIST special publication 500–261: Text REtrieval
Conference proceedings (TREC 2004). National Institute of Standards and
Technology.

Miller, D. R. H., Leek, T., & Schwartz, R. M. (1999). A Hidden Markov Model
information retrieval system. In SIGIR ’99: Proceedings of the 22nd an-
nual international ACM SIGIR conference on research and development in
information retrieval (pp. 214–221). ACM.

Mizzaro, S. (1997). Relevance:Thewhole history. Journal of the American Society
of Information Science, 48(9), 810–832.

Moffat, A., Webber, W., & Zobel, J. (2007). Strategic system comparisons via
targeted relevance judgments. In SIGIR ’07: Proceedings of the 30th an-
nual international ACM SIGIR conference on research and development in
information retrieval (pp. 375–382). ACM.

Montague, M., & Aslam, J. A. (2002). Condorcet fusion for improved retrieval.
In CIKM ’02: Proceedings of the eleventh international conference on infor-
mation and knowledge management (pp. 538–548). ACM.

Morris,M. R. (2008). A survey of collaborative web search practices. InCHI ’08:
Proceeding of the twenty-sixth annual SIGCHI conference on human factors
in computing systems (pp. 1,657–1,660). ACM.

Morris, M. R., & Horvitz, E. (2007a). S3: Storable, shareable search. In Interact
(1) (pp. 120–123).

Morris, M. R., & Horvitz, E. (2007b). SearchTogether: an interface for col-
laborative web search. In UIST ’07: Proceedings of the 20th annual ACM
symposium on user interface software and technology (pp. 3–12). ACM.

Ntoulas, A., Najork, M., Manasse, M., & Fetterly, D. (2006). Detecting spam
web pages through content analysis. InWWW ’06: Proceedings of the 15th
international conference onWorldWideWeb (pp. 83–92).

Ogilvie, P., & Callan, J. (2003). Combining document representations for



504 References

known-item search. In SIGIR ’03: Proceedings of the 26th annual interna-
tional ACM SIGIR conference on research and development in informaion
retrieval (pp. 143–150). ACM.

Pang, B., Lee, L., & Vaithyanathan, S. (2002). Thumbs up?: sentiment classifi-
cation using machine learning techniques. In EMNLP ’02: Proceedings of
the ACL-02 conference on empirical methods in natural language processing
(pp. 79–86). Association for Computational Linguistics.

Peng, F., Ahmed,N., Li, X., &Lu, Y. (2007). Context sensitive stemming for web
search. In SIGIR ’07: Proceedings of the 30th annual international ACM
SIGIR conference on research and development in information retrieval (pp.
639–646). ACM.

Peng, F., Feng, F., &McCallum, A. (2004). Chinese segmentation and newword
detection using conditional random fields. In COLING ’04: Proceedings
of the 20th international conference on computational linguistics (p. 562).
Association for Computational Linguistics.

Pentland, A., Picard, R. W., & Sclaroff, S. (1996). Photobook: Content-based
manipulationof imagedatabases. International Journal ofComputerVision,
18(3), 233–254.

Petkova, D., & Croft, W. B. (2007). Proximity-based document represen-
tation for named entity retrieval. In CIKM ’07: Proceedings of the six-
teenth ACM conference on information and knowledge management (pp.
731–740). ACM.

Pickens, J., Golovchinsky, G., Shah, C., Qvarfordt, P., & Back, M. (2008). Al-
gorithmic mediation for collaborative exploratory search. In SIGIR ’08:
Proceedings of the 31st annual international ACM SIGIR conference on re-
search and development in information retrieval (pp. 315–322). ACM.

Pinto, D., Branstein, M., Coleman, R., Croft, W. B., King, M., Li, W., & Wei, X.
(2002). QuASM: a system for question answering using semi-structured
data. In JCDL ’02: Proceedings of the 2nd ACM/IEEE-CS joint conference
on digital libraries (pp. 46–55). ACM.

Ponte, J. M., & Croft, W. B. (1998). A language modeling approach to infor-
mation retrieval. In SIGIR ’98: Proceedings of the 21st annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 275–281). ACM.

Porter,M. F. (1997). An algorithm for suffix stripping. InReadings in information
retrieval (pp. 313–316). San Francisco: Morgan Kaufmann.

Powell, A. L., French, J. C., Callan, J., Connell, M., & Viles, C. L. (2000). The



References 505

impact of database selection on distributed searching. In SIGIR ’00: Pro-
ceedings of the 23rd annual internationalACMSIGIR conference on research
and development in information retrieval (pp. 232–239). ACM.

Pritchard-Schoch, T. (1993). WIN–WESTLAW goes natural. Online, 17(1),
101–103.

Rajashekar, T. B., & Croft, W. B. (1995). Combining automatic and manual
index representations in probabilistic retrieval. Journal of the American So-
ciety of Information Science, 46(4), 272–283.

Ravela, S., & Manmatha, R. (1997). Image retrieval by appearance. In SIGIR
’97: Proceedings of the 20th annual international ACMSIGIR conference on
research and development in information retrieval (pp. 278–285). ACM.

Riezler, S., Vasserman, A., Tsochantaridis, I.,Mittal, V., & Liu, Y. (2007). Statisti-
calmachine translation for query expansion in answer retrieval. InProceed-
ings of the 45th annual meeting of the association of computational linguistics
(pp. 464–471). ACL.

Robertson, S. E. (1997). The probability ranking principle in IR. In Readings
in information retrieval (pp. 281–286). Morgan Kaufmann. (Reprinted
from Journal of Documentation, 1977, 33, 294–304)

Robertson, S. E. (2004). Understanding inverse document frequency: On theo-
retical arguments for IDF. Journal of Documentation, 60, 503–520.

Robertson, S. E., & Walker, S. (1994). Some simple effective approximations to
the2-poissonmodel for probabilisticweighted retrieval. InSIGIR ’94:Pro-
ceedings of the 17th annual internationalACMSIGIR conference on research
and development in information retrieval (pp. 232–241). Springer-Verlag.

Robertson, S. E., Zaragoza, H., & Taylor, M. (2004). Simple BM25 extension to
multiple weighted fields. InCIKM ’04: Proceedings of the thirteenth ACM
international conference on information and knowledge management (pp.
42–49). ACM.

Rocchio, J. J. (1971). Relevance feedback in information retrieval. In G. Salton
(Ed.), The SMART retrieval system: Experiments in automatic document
processing (pp. 313–323). Englewood Cliffs, NJ: Prentice-Hall.

Romano, N. C., Roussinov, D., Nunamaker, J. F., & Chen, H. (1999). Collab-
orative information retrieval environment: Integration of information re-
trieval with group support systems. InHICSS ’99: Proceedings of the thirty-
second annual Hawaii international conference on system sciences-volume 1
(pp. 1,053). IEEE Computer Society.

Sahami, M., & Heilman, T. D. (2006). A web-based kernel function for measur-



506 References

ing the similarity of short text snippets. In WWW ’06: Proceedings of the
15th international conference onWorldWideWeb (pp. 377–386). ACM.

Salton, G. (1968). Automatic information organization and retrieval. New York:
McGraw-Hill.

Salton, G., & Buckley, C. (1988). Term-weighting approaches in automatic text
retrieval. Information Processing andManagement, 24(5), 513–523.

Salton, G., & McGill, M. J. (1983). Introduction to modern information retrieval.
New York: McGraw-Hill.

Salton, G., Wong, A., & Yang, C. S. (1975). A vector space model for automatic
indexing. Communications of the ACM , 18(11), 613–620.

Sanderson, M., & Zobel, J. (2005). Information retrieval system evaluation:
effort, sensitivity, and reliability. In SIGIR ’05: Proceedings of the 28th an-
nual international ACM SIGIR conference on research and development in
information retrieval (pp. 162–169). ACM.

Saracevic, T. (1975). Relevance: A review of and a framework for the thinking
on the notion in information science. Journal of the American Society for
Information Science, 26(6), 321–343.

Saraiva, P. C., de Moura, E. S., Ziviani, N., Meira, W., Fonseca, R., & Riberio-
Neto, B. (2001). Rank-preserving two-level caching for scalable search
engines. In SIGIR ’01: Proceedings of the 24th annual international ACM
SIGIR conference on research and development in information retrieval (pp.
51–58). New York: ACM.

Schapire, R. E., Singer, Y., & Singhal, A. (1998). Boosting and Rocchio ap-
plied to text filtering. In SIGIR ’98: Proceedings of the 21st annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 215–223). ACM.

Shannon, C. (1951). Prediction and entropy in printed English. Bell System
Technical Journal , 30, 50–64.

Shannon, C., & Weaver, W. (1963). A mathematical theory of communication.
Champaign, IL: University of Illinois Press.

Shneiderman, B., Byrd, D., & Croft, W. B. (1998). Sorting out searching: a user-
interface framework for text searches. Communications of the ACM , 41(4),
95–98.

Si, L., & Callan, J. (2003). A semi-supervised learning method to merge search
engine results.ACMTransactions on InformationSystems,21(4), 457–491.

Si, L., & Callan, J. (2004). Unified utility maximization framework for resource
selection. InCIKM ’04: Proceedings of the eleventh international conference



References 507

on information and knowledge management. ACM.
Singhal, A., & Pereira, F. (1999). Document expansion for speech retrieval. In

SIGIR ’99: Proceedings of the 22nd annual international ACM SIGIR con-
ference on research and development in information retrieval (pp. 34–41).
ACM.

Smucker, M., Allan, J., & Carterette, B. (2007). A comparison of statistical sig-
nificance tests for information retrieval evaluation. InCIKM ’07: Proceed-
ings of the 14th ACM international conference on information and knowl-
edge management. ACM.

Song, F., & Croft, W. B. (1999). A general language model for information
retrieval. InCIKM ’99: Proceedings of the eighth international conference on
information and knowledge management (pp. 316–321). ACM.

Song, R., Liu, H., Wen, J.-R., & Ma, W.-Y. (2004). Learning block importance
models for web pages. InWWW ’04: Proceedings of the 13th international
conference onWorldWideWeb (pp. 203–211). ACM.

Sparck Jones, K., Walker, S., & Robertson, S. E. (2000). A probabilistic model
of information retrieval: development and comparative experiments. In-
formation Processing andManagement, 36(6), 779–808.

Strohman, T. (2007). Efficient processing of complex features for information re-
trieval (Unpublished doctoral dissertation). University of Massachusetts
Amherst.

Strohman, T.,&Croft,W. B. (2006). Low latency indexmaintenance in Indri. In
OSIR 2006: Proceedings of the second international workshop on open source
information retrieval (pp. 7–11).

Strohman, T., Metzler, D., Turtle, H., & Croft, W. B. (2005). Indri: A language
model-based search engine for complex queries. In Proceedings of the inter-
national conference on intelligence analysis.

Sun, J.-T., Shen, D., Zeng, H.-J., Yang, Q., Lu, Y., & Chen, Z. (2005). Web-
page summarization using clickthrough data. In SIGIR ’05: Proceedings
of the 28th annual international ACM SIGIR conference on research and
development in information retrieval (pp. 194–201). ACM.

Sutton, C., & McCallum, A. (2007). An introduction to conditional random
fields for relational learning. In L. Getoor & B. Taskar (Eds.), Introduction
to statistical relational learning. Cambridge, MA, USA: MIT Press.

Taghva, K., Borsack, J., &Condit, A. (1996). Evaluation ofmodel-based retrieval
effectiveness with OCR text. ACM Transactions on Information Systems,
14(1), 64–93.



508 References

Trotman, A., & Lalmas, M. (2006). Why structural hints in queries do not
help XML-retrieval. In SIGIR ’06: Proceedings of the 29th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 711–712). ACM.

Trotman,A.,&Sigurbjörnsson, B. (2004). NarrowedExtendedXPath I (NEXI).
In INEX workshop proceedings (pp. 16–40). Springer.

Turpin, A., Tsegay, Y., & Hawking, D. (2007). Fast generation of result snip-
pets in web search. In SIGIR ’07: Proceedings of the 30th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 127–134). ACM.

Turtle, H. (1994). Natural language vs. Boolean query evaluation: a compari-
son of retrieval performance. In SIGIR ’94: Proceedings of the 17th annual
international ACM SIGIR conference on research and development in infor-
mation retrieval (pp. 212–220). Springer-Verlag.

Turtle, H., & Croft, W. B. (1991). Evaluation of an inference network-based re-
trieval model. ACMTransactions on Information Systems, 9(3), 187–222.

Turtle, H., & Flood, J. (1995). Query evaluation: strategies and optimizations.
Information Processing andManagement, 31(6), 831–850.

Unicode Consortium. (2006). The Unicode standard, version 5.0. Addison-
Wesley Professional.

van Rijsbergen, C. J. (1979). Information retrieval (2nd ed.). London: Butter-
worths.

Vasconcelos, N. (2007). From pixels to semantic spaces: Advances in content-
based image retrieval. Computer, 40(7), 20–26.

Voorhees, E. M. (1985). The cluster hypothesis revisited. In SIGIR ’85: Proceed-
ings of the 8th annual international ACM SIGIR conference on research and
development in information retrieval (pp. 188–196). ACM.

Voorhees, E. M., & Buckley, C. (2002). The effect of topic set size on retrieval
experiment error. In SIGIR ’02: Proceedings of the 25th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 316–323). ACM.

Voorhees, E. M., & Harman, D. (Eds.). (2005). TREC: Experiment and evalua-
tion in information retrieval. Cambridge, MA: MIT Press.

Wang, A. (2006). The Shazam music recognition service. Communications of the
ACM , 49(8), 44–48.

Wei, X., & Croft, W. B. (2006). LDA-based document models for ad-hoc re-
trieval. In SIGIR ’06: Proceedings of the 29th annual international ACM



References 509

SIGIR conference on research and development in information retrieval (pp.
178–185). ACM.

Wei, X., & Croft, W. B. (2007). Investigating retrieval performance with
manually-built topic models. In RIAO ’07: Proceedings of the eighth RIAO
conference.

Welch, T. A. (1984). A technique for high-performance data compression. Com-
puter, 17 , 8–19.

Witten, I.H.,Moffat, A., &Bell, T. C. (1999). ManagingGigabytes: Compressing
and indexing documents and images (2nd ed.). San Francisco, CA, USA:
Morgan Kaufmann.

Xia, F., Liu, T.,Wang, J., Zhang,W., & Li,H. (2008). Listwise approach to learn-
ing to rank – theory and algorithm. In ICML ’08: Proceedings of the 25th
annual international conference on machine learning (pp. 1,192–1,199).
Omnipress.

Xu, J., & Croft, W. B. (1998). Corpus-based stemming using cooccurrence of
word variants. ACMTransactions on Information Systems, 16(1), 61–81.

Xu, J., & Croft, W. B. (2000). Improving the effectiveness of information re-
trieval with local context analysis. ACM Transactions on Information Sys-
tems, 18(1), 79–112.

Xu, Z., Fu, Y.,Mao, J., & Su,D. (2006). Towards the semantic web:Collaborative
tag suggestions. InWWW2006:Proceedings of the collaborativeweb tagging
workshop. Edinburgh, Scotland.

Xue,X., Jeon, J.,&Croft,W.B. (2008). Retrievalmodels for question and answer
archives. In SIGIR ’08: Proceedings of the 31st annual international ACM
SIGIR conference on research and development in information retrieval (pp.
475–482). ACM.

Yang, S., Zhu,H., Apostoli, A.,&Cao, P. (2007). N-gram statistics inEnglish and
Chinese: Similarities and differences. In ICSC ’07: International conference
on semantic computing (pp. 454–460). IEEE Computer Society.

Yao, Y. (1995). Measuring retrieval effectiveness based on user preference of
documents. Journal of the American Society for Information Science, 46(2),
133–145.

Yih, W., Goodman, J., & Carvalho, V. R. (2006). Finding advertising keywords
on web pages. In WWW ’06: Proceedings of the 15th international confer-
ence onWorldWideWeb (pp. 213–222). ACM.

Yu, S., Cai, D., Wen, J.-R., & Ma, W.-Y. (2003). Improving pseudo-relevance
feedback in web information retrieval using web page segmentation. In



510 References

WWW ’03: Proceedings of the 12th international conference onWorldWide
Web (pp. 11–18). ACM.

Zamir, O., & Etzioni, O. (1999). Grouper: a dynamic clustering interface to web
search results. Computer Networks, 31(11–16), 1,361–1,374.

Zeng,H.-J., He, Q.-C., Chen, Z.,Ma,W.-Y., &Ma, J. (2004). Learning to cluster
web search results. In SIGIR ’04: Proceedings of the 27th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 210–217). ACM.

Zhai, C., & Lafferty, J. (2004). A study of smoothing methods for language
models applied to information retrieval. ACMTransactions on Information
Systems, 22(2), 179–214.

Zhang, V., Rey, B., Stipp, E., & Jones, R. (2006). Geomodification in query
rewriting. InGIR ’06: Proceedings of theworkshop on geographic information
retrieval, ACM SIGIR 2006.

Zhang, Y., & Callan, J. (2001). Maximum likelihood estimation for filter-
ing thresholds. In SIGIR ’01: Proceedings of the 24th annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 294–302). ACM.

Zhou, Y., Xie, X., Wang, C., Gong, Y., & Ma, W.-Y. (2005). Hybrid index struc-
tures for location-based web search. In CIKM ’05: Proceedings of the 14th
ACM international conference on information and knowledge management
(pp. 155–162). ACM.

Zobel, J. (1998). How reliable are the results of large-scale information re-
trieval experiments? In SIGIR ’98: Proceedings of the 21st annual interna-
tional ACM SIGIR conference on research and development in information
retrieval (pp. 307–314). ACM.

Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM
Computing Surveys, 38(2), 6.

Zobel, J.,Moffat, A., &Ramamohanarao, K. (1996). Guidelines for presentation
and comparison of indexing techniques. ACM SIGMOD Record, 25(3),
10–15.

Zobel, J., Moffat, A., & Ramamohanarao, K. (1998). Inverted files versus signa-
ture files for text indexing. ACMTransactions on Database Systems, 23(4),
453–490.

Zukowski, M., Héman, S., Nes, N., & Boncz, P. A. (2006). Super-scalar RAM-
CPU cache compression. In ICDE: International conference on data engi-
neering (p. 59). IEEE Computer Society.



Index

absolute error, 437
accuracy, 359
ad hoc search, 3, 280, 423
adaptive filtering, 425
adversarial information retrieval, 294
advertising, 218, 371

classifying, 371
contextual, 218–221

agglomerative clustering, 375
anchor text, 21, 56, 105, 280
API, 439, 461
architecture, 13–28
authority, 21, 111
automatic indexing, 400

background probability, see collection
probability

bag of words, 345, 451
Bayes classifier, 245
Bayes Decision Rule, 245
Bayes’ Rule, 246, 343
Bayes’ rule, 342
Bayesian network, 268
bibliometrics, 120
bidding, 218
bigram, 100, 253
BigTable, 57

binary independence model, 246
blog, 111
BM25, 250–252
BM25F, 294
Boolean query, 235
Boolean query language, 24
Boolean retrieval, 235–237
boosting, 448
BPREF, 322
brute force, 331
burstiness, 254

caching, 26, 181
card catalog, 400
case folding, 87
case normalization, 87
categorization, see classification
CBIR, see content-based image retrieval
character encoding, 50, 119
checksum, 60
Chi-squared measure, 202
CJK (Chinese-Japanese-Korean), 50, 119
classification, 3, 339–373

faceted, 224
monothetic, 223, 374
polythetic, 223, 374

classifier, 21



512 Index

clickthrough, 6, 27, 207, 285, 306
CLIR, see cross-language information

retrieval
cluster hypothesis, 389
cluster-based retrieval, 391
clustering, 22, 222–225, 339, 373
co-occurrence, 74, 191
code page, 50
collaborative filtering, 432
collaborative search, 420
collection, 3
collection language model, 256
collection probability, 256, 440
collocation, 74
color histogram, 473
combining evidence, 267–283
combining searches, 441
CombMNZ, 441
community-based question answering,

415
complete-link clusters, 379
compression, 54

lossless, 141
lossy, 142

conditional random field, 122
conflation, see stemming
connected component, 192
content match, 371
content-based image retrieval, 473
context, 115, 201, 211–214
context vector, 206, 464
contingency table, 248
controlled vocabulary, 199, 401
conversion, 49
coordination level match, 257
corpus, 6
cosine correlation, 239
coverage, 8
CQA, 415

crawler, 17, 32
cross-language information retrieval, 226
cross-lingual search, see cross-language

information retrieval
cross-validation, 331

Damerau-Levenshtein distance, 194
dangling link, 107
data mining, 113
database system, 459
DCG, see discounted cumulative gain
deep Web, 41, 448
delta encoding, 144
dendrogram, 375
desktop search, 3, 46
Dice’s coefficient, 192
digital reference, 447
Dirichlet smoothing, 258
discounted cumulative gain, 319
discriminative model, 284, 360
distance measure, 374
distributed hash table, 445
distributed information retrieval, 438
distribution, 23
divisive clustering, 375
document, 2
document conversion, 18
document crawler, 17
document data store, 19
document distribution, 180
document slope curve, 64
document statistics, 22
document structure, 101, 269, 459–466
document summary, 215
downcasing, 87
dumping, 366
duplicate documents, 60
dwell time, 27
dynamic page, 42



Index 513

edit distance, 194
effectiveness, 233, 297
effectiveness measure, 308–322
efficiency, 297, 322–325
elements, 20
enterprise search, 3
entity recognizer, 115
entity search, 464
entropy, 362
error model, 197
estimation, 256
evaluation, 5, 15, 297–335
evaluation measures, 27
exact-match retrieval, 235
expert search, 465
extent, 137
extraction, 21

F measure, 310
facet, 224
fallout, 309
FAQ, 447
feature, 14
feature selection, 362
feature-based retrieval model, 452
federated search, see distributed informa-

tion retrieval
feed, 17, 47
field, 91, 136
fields, see document structure
file-sharing, 442
filtering, 3, 210
fingerprint, 61–63
focused crawling, 17, 41
folksonomy, 401
forum, 448
freshness, 8, 39
frontier, 35

generative model, 115, 284, 359

geographic information system, 213
geometric mean average precision, 313
Gnutella, 444
Google, 28, 100, 106
graphical model, 455

HAC (hierarchical agglomerative
clustering), 376

Hapax Legomena, 76
Heaps’ law, 81
Hidden Markov Model, 115, 293
hidden Web, 41
hierarchical clustering, 375–382
hierarchical P2P, 444
high-dimensional space, 239
highlighting, 25, 215
HITS, 111, 410
HMM, seeHidden Markov Model
homophone, 195
HTML, 18, 101
HTTP, 33
hub, 111

idf, see inverse document frequency
image annotation, 476
image search, 470
index, 8
index term, 14, 73
index vocabulary, 15
indexing, 14
indexing speed, 8, 324
Indri, 8, 273, 294
INEX, 462
inference network retrieval model,

267–273
information extraction, 21, 52, 113, 464
information gain, 362
information need, 6, 187
information retrieval, 1
inlink, 106



514 Index

Inquery, 28, 273, 294
interaction, 15, 231, 336, 480
intermediary, see search intermediary
interpolation, 315
inverse document frequency, 22, 241
inverted file, see inverted index
inverted index, 15, 125
inverted list, 130

document-ordered, 130
score-sorted, 140

Jelinek-Mercer smoothing, 257

K nearest neighbor clustering, 384–386
K-means, 223
K-means clustering, 382–387
Kendall’s tau, 321
kernel function, 356, 465
key frame, 475
keyword, 24, 189, 220, 466
KL-divergence, see Kullback-Leibler

divergence
known-item search, 280
Kullback-Leibler divergence, 261, 440

language model, 196, 252, 440
latency, 323
Latent Dirichlet allocation, 288
Latent semantic indexing, 288
LDA, see latent Dirichlet allocation
learning to rank, 284–288
Lemur, 7, 91, 120
Levenshtein distance, 194
lexical analysis, 86
link analysis, 21, 105–111, 410
link extraction, 104–113
link spam, 111, 365
links, 21
local search, 212
log data, see query log

logistic regression, 294
long-tail query, 218
low-density language, 120
LSI, see latent semantic indexing
Lucene, 7, 28

machine learning, 208, 283–291
machine translation, 227, 417
macroaverage, 315
manual indexing, 199, 400
manual tagging, 401
MAP, seemean average precision
Markov random field model, 454–458
markup language, 19
markup tags, 20
maximal marginal relevance, 405
maximum likelihood estimate, 255
mean average precision, 313
mean reciprocal rank, 319
mean squared error, 438
memory hierarchy, 140
MeSH, 200
metadata, 14, 86, 217, 280
metasearch, 439, 441
metasearch engine, 438
microaverage, 315
MIDI, 477
MMR, seemaximal marginal relevance
morphology, 21, 121
MRF, seeMarkov random field model
MRR, seemean reciprocal rank
multinomial distribution, 254
multinomial model, 348–351
multiple-Bernoulli distribution, 270
multiple-Bernoulli model, 346–348
music information retrieval, 477
mutual information, 201

n-gram, 61, 100–101, 253
naïve Bayes, 246, see Bayes classifier



Index 515

named entity, 21, 113, 468
named entity recognition, 113
Napster, 443
natural language processing, 74
NDCG, see normalized discounted

cumulative gain
near-duplicate documents, 60
nearest neighbor classifier, 361, 372
nearest neighbor clustering, see K nearest

neighbor clustering
network overlay, 443
NEXI, 462
noisy channel model, 196
normalized discounted cumulative gain,

321
noun phrase, 97
novelty, 405

OCR, 471
online community, 408
online learning, 430
online testing, 332
ontology, 213, 341
open source, 7
opinion detection, 369
optimization

safe, 26
unsafe, 26

overfitting, 287, 331

P2P networks, 442–446
P2P search, see peer-to-peer search
PageRank, 21, 106–111, 280
parallel corpus, 227, 419
parameter sweep, 331
parameter value, 330
parsing, 19
part-of-speech tagger, 97
Parzen windows, 388
pay per click, 371

peer-to-peer search, 3, 23, 438, 442
personalization, 211
phrase, 97–101
phrase stitching, 366
plagiarism, 60
politeness policy, 35
politeness window, 35
pooling, 303
POS tagger, see part-of-speech tagger
posting, 130
potential function, 456
precision, 308
preferences, 306, 321
privacy, 212, 305
probability ranking principle, 243
profile, 211, 423
proximity, 188, 269
pseudo-relevance feedback, 201, 208, 264,

458, 476
publishing, 47
pull, 47
push, 47
push application, 423

query expansion, 6, 24, 199–207, 264
query language, 23, 188, 273
query likelihood, 227, 254–261, 391, 440
query log, 24, 27, 193, 198, 206, 212, 284,

305
query processing, 125
query reformulation, 219
query suggestion, 6, 24
query throughput, 8, 323
query-based sampling, 440
query-specific clustering, 392
question answering, 3, 415, 419, 466–470
question classification, 468

R-precision, 337
Rabin fingerprint, 62



516 Index

random variables, 343
randomization test, 328
rank equivalence, 201
ranking, 15
ranking algorithm, 5, 25
ranking SVM, 285
RankNet, 294
readability, 217
recall, 308
recall-precision graph, 312
recency, 8
recommender systems, 432
relational database, 53
relevance, 4, 233, 302

binary, 234
multivalued, 234
topical, 5, 234
user, 5, 234

relevance feedback, 6, 25, 208–211, 242,
248, 429

relevance judgment, 6, 300
relevance model, 261–266, 476
replication, 23
response time, 8
retrieval model, 5, 233–292
ROC curve, 309
Rocchio algorithm, 242
RSS, 18, 47
run-on error, 196

scalability, 8
scoring, 25
scripted page, 42
search

home-page, 280
informational, 279
named-page, 280
navigational, 279
topical, 279
transactional, 279

search engine, 6
monolingual, 118

search engine optimization, 280, 299
search engineer, 10
search intermediary, 188
seed, 35
semantic annotation, 114
semantic web, 401
sentiment, 369
SEO, see search engine optimization
session, 219
shape, 474
sign test, 327
signature file, 129
significance factor, 216
significance test, 325–330
simhash, 62
similarity, 239
similarity measure, 374
simulation, 27
single-link clusters, 378
site search, 17
sitemap, 43
size estimate

collection, 86
result set, 83

small-world property, 450
smoothing, 256
snippet, 16, 52, 215
snippet generation, 215
social media site, 397
Soundex, 195
spam, 8, 22, 111, 364–368
speech recognition, 471
spell checking, 24, 193–199
spoken documents, 471
sponsored search, 371
SQL, 57
static filtering, 424



Index 517

static page, 42
stem class, 191
stemmer, 20

algorithmic, 92
dictionary-based, 92
Krovetz, 94
Porter, 92
query-based, 190
suffix-s, 92

stemming, 20, 91–96, 190
stopping, 20, 90
stopword list, 20, 90
stopwords, 90
structured query, 179
summarization, 215
superpeer, 444
supervised learning, 340
Support Vector Machine, 285, 351–358
SVM, see Support Vector Machine
synonym, 199
syntactic analysis, 87

t-test, 327
tag, 400–408
tag cloud, 407
taxonomy, 213
TDT, see topic detection and tracking
term association, 74, 192, 201
term dependence, 281, 454
term distribution, 181
term frequency, 22, 241, 260
term spam, 365
test collection, 6, 299
test set, 331, 340
text corpus, 299
text encoding, 18, see character encoding
texture, 474
tf, see term frequency
tf.idf, 22, 241
thesaurus, 192, 199

tokenizing, 19, 87–90
tokens, 19
topic, 253
topic detection and tracking, 448
topic model, 253, 288–291
training data, 208, 284
training set, 331, 340
translation-based model, 417
transliteration, 228
TREC, 6
trigram, 100, 253

UIMA, 13
Unicode, 51, 119
Uniform Resource Locator (URL), 33
unigram, 100, 252
unsupervised learning, 340
update, 56
user model, 211
UTF-8, 51, 148

v-byte, 148
vector space model, 237–243
vertical search, 3, 17, 41
video retrieval, 475
visualization, 215
Viterbi algorithm, 117
vocabulary growth, 80
vocabulary mismatch, 5, 219, 288, 403
vocabulary size, 76

weaving, 366
Web 2.0, 397
web community, 409
web search, 3, 279–283
weighting, 22, 241
Wilcoxon signed-rank test, 327
wildcard operator, 188
word frequency, 75
word occurrence, 75



518 Index

Wordnet, 200, 468

XML, 18, 103, 461
XQuery, 104, 461

Zipf distribution, 80
Zipf ’s law, 75



